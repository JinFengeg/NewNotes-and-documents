// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
/*
 * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
 * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
 */
 /dts-v1/;

#include "stm32mp157.dtsi"
#include "stm32mp15xc.dtsi"
#include "stm32mp15-pinctrl.dtsi"
#include "stm32mp15xxaa-pinctrl.dtsi"
#include "stm32mp157-m4-srm.dtsi"
#include "stm32mp157-m4-srm-pinctrl.dtsi"
#include "stm32mp157d-atk.dtsi"
#include "dt-bindings/input/input.h"
#include <dt-bindings/usb/pd.h>
/ {
	model = "STMicroelectronics STM32MP157C eval daughter";
	compatible = "st,stm32mp157c-ed1", "st,stm32mp157";

	chosen {
		stdout-path = "serial0:115200n8";
	};

	aliases {
		serial0 = &uart4;//这里会生成一个名为/dev/ttySTM0的设备文件
		serial1 = &uart5;//这里会生存一个/dev/ttySTM1
		serial2 = &usart3;
	};

	reserved-memory {
		gpu_reserved: gpu@f6000000 {
			reg = <0xf6000000 0x8000000>;
			no-map;
		};

		optee_memory: optee@fe000000 {
			reg = <0xfe000000 0x02000000>;
			no-map;
		};
	};

 	dtsleds {
		compatible ="gpio-leds";
		pinctrl-0 =<&led_pins_a>;
		led0 {
			label ="red";
			gpios =<&gpioi 0 GPIO_ACTIVE_LOW>;
			linux,default-trigger ="heartbeat";
			default-state ="on";
		};
		led1 {
			label ="green";
			gpios =<&gpiof 3 GPIO_ACTIVE_LOW>;
			default-state ="off";
		};
	};

	stm32mp1_led {
		compatible = "atkstm32mp1-led";
		status = "okay";
		reg =<0X50000A28 0X04 /* RCC_MP_AHB4ENSETR */
			0X5000A000 0X04 /* GPIOI_MODER */
			0X5000A004 0X04 /* GPIOI_OTYPER */
			0X5000A008 0X04 /* GPIOI_OSPEEDR */
			0X5000A00C 0X04 /* GPIOI_PUPDR */
			0X5000A018 0X04>;
	};
gpioled {
	compatible = "alientek,led"	;
	pinctrl-names ="default";
	status = "okay";
	pinctrl-0=<&led_pins_a>;
	led-gpio = <&gpioi 0  GPIO_ACTIVE_LOW>;
	};
	
	beep {
		compatible = "alientek,beep"	;
		status = "okay";
		pinctrl-names ="default";
		pinctrl-0=<&beep_pins_a>;
		beep-gpio = <&gpioc 7	GPIO_ACTIVE_HIGH>;
	};
	key {
		compatible = "alientek,key"	;
		status = "okay";
		pinctrl-names ="default";
		pinctrl-0 =<&key_pins_a>;
		key-gpio = <&gpiog 3 GPIO_ACTIVE_LOW>;
		interrupt-parent= <&gpiog>;
		interrupts =<3 IRQ_TYPE_EDGE_BOTH>;
	};
		gpio-keys {
		compatible ="gpio-keys";
		pinctrl-names ="default";
		pinctrl-0 =<&key_pins_a>;
		autorepeat;
		key0 {
			label ="GPIO Key L";
			linux,code =<KEY_L>;
			gpios =<&gpiog 3 GPIO_ACTIVE_LOW>;
		};
		key1 {
			label ="GPIO Key S";
			linux,code =<KEY_S>;
			gpios =<&gpioh 7 GPIO_ACTIVE_LOW>;
		};
		wkup {
			label ="GPIO Key Enter";
			linux,code =<KEY_ENTER>;
			gpios =<&gpioa 0 GPIO_ACTIVE_HIGH>;
			gpio-key,wakeup;
		};
		};

		backlight: backlight {
			compatible ="pwm-backlight";
			pwms =<&pwm4 1 5000000>;
			brightness-levels =<0 4 8 16 32 64 128 255>;
			power-supply =<&v3v3>;
			default-brightness-level =<7>;
			status ="okay";
		};


	panel_rgb: panel-rgb {
		compatible ="alientek,lcd-rgb";
		backlight =<&backlight >;
		status ="okay";
		port {
			rgb_panel_in: endpoint {
				remote-endpoint = <&ltdc_ep0_out>;//原来这里是告诉节点数据应该输出到哪里
			};
		};
	};
 /*
	v1v2_hdmi: regulator-v1v2-hdmi {
		compatible ="regulator-fixed";
		regulator-name ="v1v2_hdmi";
		regulator-min-microvolt =<1200000>;
		regulator-max-microvolt =<1200000>;
		regulator-always-on;
		regulator-boot-on;
	};*/
	usb_phy_tuning: usb-phy-tuning { 
		 st,hs-dc-level = <2>;
 st,fs-rftime-tuning; 
 st,hs-rftime-reduction; 
 st,hs-current-trim = <15>;
 st,hs-impedance-trim = <1>;
 st,squelch-level = <3>;
 st,hs-rx-offset = <2>;
 st,no-lsfs-sc;
 };

 vdd_usb: regulator-vdd-usb { 
	 compatible = "regulator-fixed"; 
	  regulator-name = "vdd_usb"; 
	   regulator-min-microvolt = <3300000>;
 regulator-max-microvolt = <3300000>;
 regulator-always-on; 
  regulator-boot-on; 
   };

vdd: regulator-vdd {
 compatible = "regulator-fixed";
 regulator-name = "vdd";
 regulator-min-microvolt = <3300000>;
 regulator-max-microvolt = <3300000>;
 regulator-always-on;
 regulator-boot-on;
 };
 
 v3v3: regulator-3p3v {
 compatible = "regulator-fixed";
 regulator-name = "v3v3";
 regulator-min-microvolt = <3300000>;
 regulator-max-microvolt = <3300000>;
 regulator-always-on;
 regulator-boot-on;
 };

};
&cpu1 {
	cpu-supply = <&vddcore>;
};

&cryp1 {
	status="okay";
};

&gpu {
	contiguous-area = <&gpu_reserved>;
	status = "okay";
};

&optee {
	status = "okay";
};

&timers1 {
	status="okay";
	/delete-property/dmas;
	/delete-property/dma-names;
	pwm1:pwm {
		pinctrl-0 =<&pwm1_pins_a>;
		pinctrl-1=<&pwm1_sleep_pins_a>;
		pinctrl-names ="default","sleep";
		#pwm-cells =<2>;
		status ="okay";
	};
};

&ltdc {
	pinctrl-names ="default", "sleep";
	pinctrl-0 =<&ltdc_pins_b>;
	pinctrl-1 =<&ltdc_pins_sleep_b>;
	status ="okay";
	port {
		#address-cells =<1>;
		#size-cells =<0>;

 		ltdc_ep0_out: endpoint@0 {
		reg =<0>;
		remote-endpoint =<&rgb_panel_in>;//这就是说明下数据要输出到哪里
		};
	};
};

&timers4 {
	status ="okay";
	/delete-property/ dmas;
	/delete-property/dma-names;
	pwm4: pwm {
		pinctrl-0 = <&pwm4_pins_b>;
		pinctrl-1 = <&pwm4_sleep_pins_b>;
		pinctrl-names ="default","sleep";
		#pwm-cells =<2>;
		status ="okay";
	};
};

&i2c5 {
	pinctrl-names ="default","sleep";
	pinctrl-0 =<&i2c5_pins_a>;//这里是添加下pinctrl子系统
	pinctrl-1=<&i2c5_pins_sleep_a>;
	status ="okay";

	ap3216c@1e {
		compatible ="alientek,ap3216c";
		reg =<0x1e>;
	};

};
/*实时时钟的PZ4被占用*/
/*&i2c4 {
	pinctrl-names ="default","sleep";
	pinctrl-0 =<&i2c4_pins_a>;
	pinctrl-1 =<&i2c4_pins_sleep_a>;
	status ="okay";

	pcf8563@51 {
		compatible ="nxp,pcf8563";
		irq_gpio =<&gpioi 3 IRQ_TYPE_EDGE_FALLING>;
		reg =<0x51>;
	};
	
};*/

&rtc {
	status ="okay";
};

&spi1 {
	pinctrl-names ="default","sleep";
	pinctrl-0 =<&spi1_pins_a>;
	pinctrl-1=<&spi1_sleep_pins_a>;
	cs-gpios =<&gpioz 3 GPIO_ACTIVE_LOW>,
						 <&gpioz 4 GPIO_ACTIVE_LOW>;
						
	status ="okay";

	spidev: icm20608@0 {
		compatible ="alientek,icm20608";
		reg =<0>;//这就是第一个片选信号，iic中的是地址。
		pinctrl-names ="default";
		pinctrl-0=<&icm20608_pins_b>;
		interrupt-parent =<&gpioa>;
		interrupts=<14 IRQ_TYPE_LEVEL_HIGH>;
		spi-max-frequency =<8000000>;//这里是最大时钟频率
	};
	spidev1:ad7606@1 {
                compatible = "adi,ad7606-8";
                reg = <1>;
                spi-max-frequency = <1000000>;
                spi-cpol;
                spi-cpha;
                pinctrl-name = "default";
                pinctrl-0 =<&ad7606_pins_a>;
				interrupt-parent = <&gpioe>;
                interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
                
                adi,range-gpios =<&gpiof 11 GPIO_ACTIVE_HIGH>;
                adi,conversion-start-gpios = <&gpioe 0 GPIO_ACTIVE_HIGH>;
                reset-gpios = <&gpioe 12 GPIO_ACTIVE_HIGH>;
                adi,first-data-gpios = <&gpioi 6 GPIO_ACTIVE_HIGH>;
                adi,oversampling-ratio-gpios = <&gpioe 14 GPIO_ACTIVE_HIGH>,
                                               <&gpioh 13 GPIO_ACTIVE_HIGH>,
                                               <&gpioi 7 GPIO_ACTIVE_HIGH>;
                
                adi,sw-mode;
        };


	
};

&usart3 {
	pinctrl-names ="default";
	pinctrl-0 =<&usart3_pins_c>;
	status ="okay";
};
&uart5 {
	pinctrl-names ="default";
	pinctrl-0=<&uart5_pins_a>;
	status ="okay";
};


&i2c2 {
	pinctrl-names ="default","sleep";
	pinctrl-0 =<&i2c2_pins_a>;
	pinctrl-1 =<&i2c2_pins_sleep_a>;
	status ="okay";

	//ft5426
	ft5426: ft5426@38 {
		compatible ="edt,edt-ft5406";
		pinctrl-0 =<&ft5426int_reset_pins_a>;
		reg =<0x38>;
		interrupt-parent = <&gpioi>;
		interrupts =<1 IRQ_TYPE_EDGE_RISING>;
		//irq-gpios =<&gpioi 1 GPIO_ACTIVE_LOW>;//这里设置的是推挽输出，默认是低电平，为沙不设置中断呢
		reset-gpios =<&gpioh 15 GPIO_ACTIVE_LOW>;
		status ="okay";
	};
 	/*
	hdmi: hdmi-transmitter@39 {
		compatible ="sil,sii9022";
		reg =<0x39>;
		iovcc-supply =<&v3v3>;
		cvcc12-supply =<&v1v2_hdmi>;
		reset-gpios =<&gpioa 3 GPIO_ACTIVE_LOW>;
		interrupts =<6 IRQ_TYPE_EDGE_FALLING>;
		interrupt-parent =<&gpioh>;
		#sound-dai-cells =<1>;
		status ="okay";
		ports {
				#address-cells =<1>;
				#size-cells =<0>;

				port@0 {
					reg =<0>;
					sii9022_in: endpoint{
						remote-endpoint =<&ltdc_ep0_out>;//本质上还是RGB
					};
				};
		};
	};*/
};

&m_can1 {//追加的子节点是153.dtsi上的，但是我并没有包含其头文件
	pinctrl-names = "default","sleep";
	pinctrl-0 = <&m_can1_pins_a>;//追加的引脚配置是pinctrl文件中的，这里需要修改下，因为pin节点名词不是这个
	pinctrl-1=<&m_can1_sleep_pins_a>;
	status = "okay";//enable表示的意思就是okay
};
//USB相关
&usbphyc {
	status ="okay";
};

&usbphyc_port0{
	phy-supply =<&v3v3>;
	st,phy-tuning =<&usb_phy_tuning>;
};

&usbh_ehci {
	phys = <&usbphyc_port0>;
	status = "okay";
};

&usbphyc_port1 { 
	 phy-supply = <&vdd_usb>;
 st,phy-tuning = <&usb_phy_tuning>;
 };

 &usbotg_hs { 
	 phys = <&usbphyc_port1 0>;
 phy-names = "usb2-phy"; 
  usb-role-switch; 
   status = "okay";
   port { 
	usbotg_hs_ep: endpoint { 
		 remote-endpoint = <&con_usbotg_hs_ep>;
 };
 };
 };
 &i2c1 { 
	pinctrl-names = "default", "sleep"; 
	 pinctrl-0 = <&i2c1_pins_b>;
   pinctrl-1 = <&i2c1_pins_sleep_b>;
  status = "okay"; 
 fusb302@22 { 
	 compatible = "fcs,fusb302","fairchild,fusb302"; 
	  reg = <0x22>;
		pinctrl-names = "default"; 
		pinctrl-0 = <&fusb302_pins_a>;
		int-n-gpios = <&gpiog 2 GPIO_ACTIVE_HIGH>;
		vbus-5v-gpios = <&gpioz 6 GPIO_ACTIVE_HIGH>;
		status = "okay"; 
		connector {
		compatible = "usb-c-connector";
		label = "USB-C";
		power-role = "dual";
		power-opmode = "default";

		try-power-role = "sink";
		source-pdos = <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;
		sink-pdos = <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM) PDO_VAR(3000, 12000, 3000) PDO_PPS_APDO(3000, 11000, 3000)>;
		op-sink-microwatt = <10000000>;
		port {
		con_usbotg_hs_ep: endpoint {
		remote-endpoint = <&usbotg_hs_ep>;
 };
 };
 };
 };
  };

  &sdmmc3 {
	pinctrl-names ="default","opendrain","sleep";
	pinctrl-0 =<&sdmmc3_b4_pins_a>;
	pinctrl-1 =<&sdmmc3_b4_od_pins_a>;
	pinctrl-2 =<&sdmmc3_b4_sleep_pins_a>;
	non-removable;
	st,neg-edge;
	bus-width =<4>;
	vmmc-supply =<&v3v3>;
	status ="okay";
	keep-power-in-suspend;
  };

&adc {
 pinctrl-names = "default";
 pinctrl-0 = <&adc1_in19_pins_a>;
 vdd-supply = <&vdd>;
 vdda-supply = <&vdd>;
 vref-supply = <&vdd>;
 status = "okay";
 
 adc1: adc@0 {
 st,adc-channels = <19>;
 st,min-sample-time-nsecs = <10000>;
 assigned-resolution-bits = <16>;
 status = "okay";
 };
 };

 &dac {
 pinctrl-names = "default";
 pinctrl-0 = <&dac_ch1_pins_a>; 
 vref-supply = <&v3v3>; 
 status = "okay";
 dac1: dac@1 {
 status = "okay"; 
 };
 };
  
