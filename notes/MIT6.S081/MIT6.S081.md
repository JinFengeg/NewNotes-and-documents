MIT6.S081:Operating System Engineering笔记

先修要求：体系结构+扎实的C语言功底+RISC-V汇编语言

---

好久没搞技术了，已经忘记了自己的主心骨是什么，说到底还是要以人为本，技术才是自己唯一能抓住的，接下来将近三个月的下午时间专门用来研究下这个大名鼎鼎的MIT课程，让我对操作系统有一个全面的认识，相信对将来工作一定会非常有帮助的。

---

## 1.1课程内容简介

接下来列出这门课程的目标：

1. 理解操作系统的设计和实现。设计是指整体的结构，实现是指具体的代码长什么样。
2. 为深入了解具体的工作原理，通过一个小的叫做xv6操作系统，红的实际动手经验，通过研究现有的操作系统，并结合课程配套的实验，可以获得扩展操作系统，修改并提升操作系统的相关经验，并且能够通过操作系统接口，编写系统软件。

对于操作系统的目标，这里列出几个点，市面上有大量不同的操作系统，通常来说，有一些共同的目标：

1. 第一个就是抽象硬件。通常来说，买一个计算机，里面包含了CPU，内存，但是这是一种非常低层级的硬件。一些应用程序实现了高层级的接口和抽象，例如进程，文件系统。这些高层级的接口和抽象方便了应用的开发，也提供了更好的移植型。

   ---

   这句话是具有全方位理解才能说出来的，对于现在的我是常识。

   ---

2. 操作系统的另一个重要的任务是：在多个应用程序之间共用硬件资源。可以在一个操作系统同时运行文本编辑器，程序编译器，多个数据库等等。操作系统能在不互相干扰的前提下，同时运行这些程序。被称为multiplex。

   ---

   这里指的是时间片轮询吗，硬件资源也就是cpu可以宏观并行，这里指的不是硬件资源，而是多线程。英文是多路复用。这个我记得是指IO多路复用是监控文件的。

3. 因为在操作系统中可能同时运行很多程序，即使程序出现了故障，多个程序之间互不干扰就变得非常重要。所以这里需要隔离性（Isolation），不同的活动之间不能互相干扰。

   ---

   这里指的是线程拥有各自的线程栈，内存不同，不会被干扰。

   ---

4. 但是另一方面，不同的活动之间有时又想要互相影响，不如数据交互，协同完成任务等。举个例子，通过文本编辑器创建了一个文件，希望编译器能读取文件，需要数据共享。所以这个时候需要共享(sharing)。

   ---

   这个就是进程间共享资源，共享内存或者进程间通信

   ---

5. 很多场景下，用户并不想要共享，不想要其他人来读取文件，所以共享的同时也希望在没必要的时候不共享。称为Security。

6. 如果在硬件上花费了大量的金钱，期望应用程序拥有硬件应该提供的完整性能，但很多时候只负责应用程序编程，期望操作系统也必须保证自身提供的服务不会阻止应用程序获得高性能。所以操作系统需要不阻止应用程序获得高性能，甚至需要帮助应用程序获得高性能（Performance）。

   ---

   这里指的是中断和软中断机制。某个应用程序获得高性能必然导致其他线程被阻塞。

   ---

7. 最后，对于大部分操作系统，必须要支持大量不同类型的应用程序，或许操作系统需要支持数据库服务器和云计算。通常，设计并构造一个操作系统代价是非常大的，所以人们总是希望在相同的操作系统上，比如Linux，运行大量的任务，同一个操作系统必须支持大量的不同用户场景。

   ---

   这里指的是软件层需要提供大量的库文件。

   ---

## 1.2操作系统结构

过去几十年，人们将一些分层的设计思想加入到操作系统中，并运行的很好。接下来列出操作系统经典的组织结构，这个组织结构同时也是课程的主要内容，这里的组织结构对于操作系统来说还是挺常见的。

这里实际上就是操作系统内部组成，当想到这里的组织结构时，首先会想到用一个矩形表示一个计算机，这个计算机有一些硬件资源，放在矩形下面，硬件资源包括了CPU、内存、磁盘、网卡。所以硬件资源在最低一层。

|      |      |      |      |
| ---- | ---- | ---- | ---- |
|      |      |      |      |
|      |      |      |      |
| CPU  | RAM  | DISK | NET  |

在这个架构的最上层，运行各种各样的应用程序，需要文本编辑器VI，C编译器CC，还可以运行大量讨论的其他事物，比如command line inferview，命令行界面CLI。这些程序都运行在同一个空间中，这个空间通常被称为用户空间userspace。

| VI   | CC   | Shell | User |
| ---- | ---- | ----- | ---- |
|      |      |       |      |
|      |      |       |      |
| CPU  | RAM  | DISK  | NET  |

区别于用户空间程序，有一个特殊的程序总是会运行，称为kernel。内核是计算机资源的守护者。当打开计算机时，kernel总是第一个被启动。kernel程序只有一个，维护数据来管理每一个用户空间进程。

kernel同时还维护了大量的数据结构来帮助它管理各种各样的硬件资源。

---

这里的数据结构其实就是内核借助C语言实现的对象。

---

以供用户空间的程序使用。kernel同时还有大量内置的服务。例如kernel通常会有文件系统实现类似文件名，文件内容，目录的东西，并理解如何将文件存储在磁盘中。所以用户空间的程序会与kernel中的文件系统交互，文件系统再与磁盘交互。

---

看到最后这段话理解了，指的是文件系统用来管理磁盘这样存储的，上一层是虚拟文件系统。

----

本课程中，主要关注点在kernel、连接kernel和用户空间程序的接口、kernel内软件的架构。

---

这里指的是kernel，系统调用，内核中的架构。

---

会关心kernel中的服务，其中一个服务是文件系统，另一个就是进程管理系统。每个用户空间程序都被称为一个进程，他们有自己的内存和共享的CPU时间。同时，kernel会管理内存的分配。不同进程需要不同数量的内存，kernel会复用内存、划分内存，并为所有进程分配内存。

---

这里复用内存指的是共享内存吧。

---

文件系统通常有一些逻辑分区。目前而言，我们可以认为文件系统的作用是管理文件内容并找出文件具体在磁盘中的哪个位置。文件系统还维护了一个独立的命名空间，其中每个文件都有文件名，并且民工空间中有一个层级的目录，每个目录包含了一些文件，这些都被文件系统管理。

---

我对于文件系统了解不够，这里看起来像页表，多级页表单独存放在一个内存上。体系结构中讲过。

----

还有一些安全的考虑，称之为Access Control。当一个进程想要使用某些资源时，比如读取磁盘中的数据，使用某些内存，kernel中的Access Control机制会决定是否允许这样的操作。对于一个分时共享的计算机，会变得很复杂。每个进程可能属于不同的用户，用不同的Access规则来约定那些资源可以被访问。

---

Linux下的使用页表中的页表项中的控制位来决定哪些页面可以被访问。这也是虚拟内存的功能之一

---

在一个真实的完备的操作系统中，会有很多很多其他的服务，，比如在不同进程之间通信的进程间通信服务。比如很多和网络关联的软件TCP/IP协议栈。比如支持声卡的软件，比如支持数百种不同磁盘，不同网卡的驱动。所以在一个完备的系统重，kernel会包含大量的内容，数百万行代码。

| VI   | CC        | SHell  | USER   |
| ---- | --------- | ------ | ------ |
| FS   | Processes | ACCESS | KERNEL |
| CTL  | alloc     |        |        |
| CPU  | RAM       | DISK   | NET    |

这就是对于kernel的一个快速浏览。

同时也对应用程序是如何与kernel交互，他们接口长什么样感兴趣。这里通常称为kernel的API，他决定了应用程序如何访问Kernel。通常来说，这里是通过所谓的系统调用来完成。系统调用与程序中的函数调用看起来一样，但区别是系统调用会实际运行到内核中，并执行内核中对于系统调用的视线。这里只介绍系统调用在应用程序中是长什么样的。

---

就当复习了，库函数-》系统调用函数-》软中断陷入内核-》找到内核中的系统调用表-》函数在VFS中执行-》进而在FS中实现。

---

第一个例子，如果应用程序需要打开一个文件，调用名为open的系统调用，将文件名作为参数传给open，假设现在要打开一个名为out的文件，那么会将文件名out作为参数传入。还希望写入数据，那么还会有一个额外的参数，这里是1表示写文件。

```c
fd = open("out",1);
```

这里看起来像是个函数调用，open是一个系统调用，他会跳到kernel，kernel可以获取open的参数，执行一些实现了open的kernel代码，或许会与磁盘有一些交互，最后返回一个文件描述符对象，fd全程是file descriptor。之后，应用程序可以使用这个文件描述符作为handle，来表示相应打开的文件。

如果想要向文件写入数据，相应的系统调用是write。需要向write传递一个由open返回的文件描述符作为参数。还需要向write传递一个指向要写入数据的指针，在C语言中，可以简单传递一个双引号表示的字符串。第三个参数是你想要写入字符的数量。

```c
write(fd,"hello\n",6);
```

第二个参数的指针，实际上是内存的地址。这里实际上告诉内核，将内存中这个地址起始的6个字节数据写入到fd对应的文件中。

另一个可能会用到的，是系统调用fork。fork创建了一个域调用进程一模一样的新的进程，并返回新进程的process ID/pid。这里实际上会复杂的多。

```c
pid=fork();
```

这些系统调用看起来和普通函数一样，不同的是他最终会跳到系统内核中。

## 1.3why Hard and Interesting

学习操作系统比较难的一个原因是，内核的编程环境比较困难。在编写，修改，扩展内核，或者写一个新的操作系统内核时，实际上在提供一个基础设施让别人来运行他们的程序。当程序员在写普通的应用程序时，应用程序下面都是操作系统。当我们在构建操作系统时，操作系统下面就是硬件了，这些硬件通常会更难处理。本门课程中，会使用一个叫做QEMU的硬件模拟器，来模拟CPU和计算机。即便如此，编程环境还是比较恶劣。

---

这小节开始感觉有点东西了，硬件模拟器。真爽

----

学习操作系统比较难的另一个原因是，当设计一个操作系统时，需要满足一系列矛盾的需求。

- 其中一个是，想要操作系统既高效又易用，高效意味着需要在离硬件近的low-level进行操作，而易用则要求操作系统为应用程序提供抽象的high-level可移植接口。所以提供一个简单可移植，同时又高效的抽象接口需要一定的技巧。
- 另一个矛盾的点是，我们想要提供一个非常强大的操作系统服务，这样的操作系统才能分担运行应用程序的负担，所以我们需要强大的操作系统服务。但同时，我们也想要有简单的接口。我们不想程序员看到数量巨多，复杂且难以理解的内核接口。所以还想要简单且功能强大的接口。

---

系统调用和标准的函数调用区别：权限不同，严格来说是操作系统处于不同的工作模式下。访问硬件资源。

---

- 最后一个矛盾点是所有的操作系统需要满足的。希望给与应用程序尽可能多的灵活性，不会想要限制应用程序，所以需要内核具备灵活的接口。另一方面，需要在某种程度上限制应用程序，因为安全性。希望给程序员完全的自由，但实际上又不能是真正的完全自由，不希望程序员直接访问到硬件，打扰其他应用程序或者操作系统的行为。

设计一个好的操作系统还是有可能的，另一件使得操作系统的设计难且有趣的点是：操作系统提供了大量的特性和服务，但他们趋向于相互交互。有时，这种交互以奇怪的方式进行，并且需要大量的思考。如果一个应用程序通过open系统调用得到了一个文件描述符fd。之后这个应用程序调用了fork系统调用，fork予以是创建一个当前进程的拷贝进程。而对于一个真正的拷贝进程，父进程中的文件描述符也必须存在且可用。所以子进程还必须访问到fork之前创建的文件描述符fd。此时页表项中必须允许当前进程的子进程也可以访问。

另一件有趣的事情，之前也提到了，操作系统需要能够满足广泛的使用场景。相同的操作系统需要既给数据库服务器使用，又能给手机使用。多核CPU、网速的指数增长都需要重新思考操作系统是如何被设计的。

接下来用更加实际的原因来告诉为什么选择这门课程。

- 如果对于计算机的运行原理感兴趣，打开计算机以后实际发生的事情感兴趣。
- 如果喜欢基础架构，喜欢构建一些其他程序可以使用的服务，这门课都有关基础架构的内容，因为操作系统就是基础架构。
- 如果曾经花费了大量的时间来定位应用程序的bug或者定位安全的问题，会发现这些经历都需要理解操作系统是如何运作的。

## 1.4课程结构和资源

授课内容是这门课程的一大部分，我们会讲解操作系统的基本概念。有几节课会专注于学习XV6中的代码，xv6是我们的一个小的用于教学的操作系统，我们会介绍他是如何工作的，查看他的代码，每节课程之前都会有作业，要求阅读介绍xv6的书籍，书籍的内容是xv6如何运行以及设计思想。所以应该在课程之前完成相应的阅读，比如介绍RISC-V是如何工作的，这是将要完成的一个微处理器。在课程的结束部分，会花几节课时间来阅读一些操作系统相关的论文。

这门课的下一大部分是lab，几乎每周都会有一些编程实验。实验的意义在于帮助你获得一些使用和实现操作系统的实际动手经验。比如接下来的实验是写一些应用程序代码来执行我们之前谈到的系统调用，之后的大部分实验要求实现基本的操作系统功能，或者扩展xv6操作系统。最后一个lab会要求添加一个网络协议栈和一个网络驱动，这样操作系统才能连接到网络上。

## 1.5read,write,exit系统调用

接下来讨论对于应用程序来说，系统调用长什么样。因为系统调用是操作系统提供的服务的接口，所以系统调用长什么样，应用程序期望从系统调用得到什么返回，系统调用是怎么工作的。在第一个lab中使用我们在这里介绍的系统调用，并且在后续的lab中，扩展并提升这些系统调用的内部实现。

接下来会展示一些简单的例子，这些例子中会执行系统调用 ，并在xv6中运行这些例子。xv6是一个简化的类似unix的操作系统，具有相同的文件结构。

xv6运行在一个RISC-V微处理器上，临时可以在一个RISC-V计算机上运行xv6。

## 1.6open系统调用

一般情况下，需要能创建文件描述符，下面是调用open的过程。

```c
int main()
{
    int fd = open("output.txt",0_WRONLY | 0_CREATE);
    write(fd,"000\n",4);
    exit(0);
}
```

文件描述符本质上对应了内核中的一个表单数据。内核维护了每个运行进程的状态，内核会为每一个运行进程保存一个表单，表单的key是文件描述符，这个表单让内核知道，每个文件描述符对应的实际内容是什么。

---

我记得进程结构体中有已打开文件的成员。至于文件描述符是如何对应表单的不知道。

---

关键的点是，每个进程都有自己独立的文件描述符空间，如果运行了两个不同的程序，对应两个不同的进程，如果他们都打开一个文件，或许可以得到相同数字的文件描述符，但因为内核为每个进程都维护了一个独立的文件描述符空间，这样相同数字的文件描述符会对应到不同的文件。

---

这里有点混，打开一个文件应该是让这个文件对两进程都共享，描述符相不相同不知道，但应该对应到同一个文件。也不对，打开的文件是从磁盘下载到内存中，就会导致磁盘中是同一个，下载到不同的内存上。

----

## 1.7Shell

就是单纯的介绍。

## 1.8fork系统调用

fork会拷贝当前进程的内存，并创建一个新的进程，这里的内存包含了进程的指令和数据。之后，我们就有了两个拥有完全一样内存的进程。（地址不同）fork系统调用在两个进程中都会返回。在原始的进程中，fork系统调用会返回大于0的整数，这是新创建的pid，在新创建的进程中，fork系统调用会返回0。所以即使两个进程的内存是完全一样的，也可以通过fork返回值区分旧进程和新进程。

fork系统调用之后，两个进程都在同时运行，QEMU实际上是在模拟多核处理器，所以这两个进程实际上就是同时运行。fork除了拷贝内存外，还会拷贝文件描述符表单。

## 1.9exec，wait系统调用

---

exec我记得是族群函数，类似于fork，同样会生成线程，但线程的执行内容是可以指定的。

---

```c
int main()
{
char *argv[] = {"echo","this","is","echo",0};//这里的0用来表示内核数组的结尾在哪里，这是一个字符指针数组，里面的元素都是指针，最后的0就是null指针。由内核识别到NULL指针结束。
exec("echo",argv);
printf("exec failed!\n");//exec执行成功后直接跳转走了，应该是这样。
exit(0);
}
```

代码会执行exec系统调用，这个系统调用会从指定的文件中读取并加载指令，并代替当前调用进程的指令。从某种程度上来说，这样相当于丢弃了调用进程的内存，并开始执行新加载的指令。

---

相当于执行成功直接结束进程并收尸，内存都不给你留。

----

有关exec系统调用，有一些重要的事情，

1. exec系统调用会保留当前的文件描述符表单。。所以任何在exec系统调用之前的文件描述符，在新的程序中表示相同的东西。（也就是说执行exec之前打开的文件获取到的返回值均有效）
2. 通常来说exec系统调用不会返回，因为exec会完全替换当前进程的内存，相当于当前进程不复存在了，所以exec系统调用已经没有地方能返回了。

所以exec系统调用从文件中读取指令，执行这些指令，然后就没有了。exec系统调用只有当出错时才会返回，因为某些错误会阻止操作系统为你运行文件中的指令，例如程序文件不存在，因为exec找不到文件，exec会返回-1表示。

这就是一个程序用文件中的另一个程序代替自己。实际上在shell运行类似于“echo a b c”的指令，或者ls，或者命令，都不会想要代替shell进程，所以不会希望shell执行exec系统调用。实际上shell会先执行fork，然后fork出的子进程调用exec系统调用，这是很常见的Unix程序调用风格。子进程被结束，主线程继续执行。

```c
//fork then exec
int main(){
    int pid,status;
    pid = fork();//子进程ID
    if(pid == 0)//脑子木了，之前还合计怎么实现父进程不执行exec，根据ID判断即可。
    {
        char *argv[] = {"echo", "THIS","IS","ECHO",0};
        exec("echo",argv);//执行echo文件，打印argv字符串
        printf("exec failed\n");
        exit(1);
    }else{
        printf("parent waiting\n");
        wait(&status);//这里是要给子进程收尸，这里就是赋值的过程，传地址就是为了赋值。
        printf("the child exited with status %d\n",status);
    }
    exit(0);//退出父进程。
}
```

wait系统调用没有收尸之前会等待。所以shell等待指令执行成功后才执行。这里的wait参数status，是一种让退出的子进程以一个整数的格式与等待的父进程通信的方式。之前的wait都是一个参数，这里是收尸的时候对status赋值，所以需要传地址。对地址指向的内容复制。

unix中的风格是，如果一个程序成功退出了，那么exit的参数就是0，如果失败了就传递1，如果关心子进程的状态，父进程可以读取wait的参数。其实就是错误码吧，erron。

这里有一些东西需要注意，先调用fork，再在子进程中调用exec。有一些浪费了，fork首先拷贝了整个父进程的，之后exec整个将这个拷贝丢弃了，用运行的文件替换了内存的内容。这里的拷贝操作浪费了，因为所有拷贝的内存都被丢弃。后期会学到一些优化，比如copy-on-write fork，写时拷贝，这种方式会消除fork的几乎所有明显的低效，这里需要很多涉及到虚拟内存系统的技巧。

---

拷贝页表之类的，记不住了

---

## 1.10I/O Redirect

最后一个例子，展示下将所有这些工具结合起来，实现I/O重定向

---

其实这十个例子已经让我看到了，这个课程并没我想象中那么复杂，没有新知识，其实操作系统的组成就是搭积木，用奇淫巧技将简单的功能结合起来组成一个常见的功能。

---

```c
//run a command with output redirected
int main()
{
    int pid;
    pid = fork();
    if(pid == 0)
    {
        close(1);//这里的1指的的标准输出文件，但只关闭了子进程的标准输出，所以shell依旧可以使用。
        open("output.txt",0_WRONLY | 0_CREATE);
        char *argv[] = {"echo","this","is","redirected","echo",0};
        exec("echo",argv);//看上去应该是打印到output.txt文件中了，但只是关闭了标准流也就是屏幕，没有指定文件。在命令行指定的。这里很神奇，因为先关闭了1，创建文件，此时文件描述符从小给必然是1，而echo默认是标准输出，也就是1，此时1变成了output.txt文件，所以联系上了。
        printf("exec failed!\n");
        exit(1);
    }else{
        wait((int*)0);
    }
    exit(0);
}
```

总结本小节：

1. 看了一些Unix I/O和进程的接口和抽象。接口相对简单，只需要传入表示文件描述符的整数，和进程ID作为参数给相应的系统调用，接口内部的视线逻辑比较复杂。
2. 接口本身简单，将多个接口结合起来形成复杂的用例。

# Lec03 OS Organization and System Calls

没有02，准备工作需要阅读一个chapter2和XV6代码。应该只是看第二章的Operating system organization。这里面也提到了XV6代码。十页左右，全本是110页。我准备英语阅读，不会的单词再翻译，一定非常锻炼我。

---

下午问了下魏旭峰英文阅读的事，人家说先做批注，再看就容易了，满满的就好了。

---

## Chapter2 Operating system organization

对于操作系统而言，一个关键的需求是立刻支持好几个活动，例如，使用系统调用接口在第一章中一个进程可以开始新的进程用fork函数。操作系统必须在多个进程中把操作系统的资源也就是时间分享，再比如，即使这里有更更多进程比起硬件的CPU核数，操作系统必去确保所有的进程都能得到一个机会去执行。操作系统同样必须安排两个进程之间的隔离。也就是说如果一个进程有bug和问题，他不应该影响那些并不依赖于错误进程的进程们。彻底隔离是太难了，因此进程有可能去故意交互。管道就是例子。因此一个操作系统必须满足说那个需求：复用，隔离，交互。

本章提供一个概括对于操作系统是如何被组织去获得这三个需求。事实证明，这里有多重方法去做到。但本文只关注围绕整个内核为核心的主流设计。这种设计常被用作一些Unix操作系统中。本章页提供一个对xv6进程的概述，这在xv6系统中是独立的单元。以及xv6启动时第一个进程的产生。

xv6操作系统运行在一个多核的RISC-V微处理器上。以及他的多个低级功能（比如过程实现）对于RISC-V架构的特定的，RISC-V是一个64位处理器，xv6被写在LP64类型的C语言上，意味着长期，定向在C语言是64位，但int类型是32位。本书假设读者已经写了一些机器级代码在一些架构上，本书也将介绍RISC-V特殊的理念当架构开始的时候。使用者ISA和特权架构是官方规范。

CPU在一个完整的电脑上是被支持硬件包围，大多数以IO接口的形式。xv6被设计为了支持硬件模拟器。包括RAM，一个包含boot代码的ROM，一系列的连接使用者的键盘，屏幕和一个存储磁盘。

---

一页的翻页用了半个小时。。。

---

## 2.1Abstracting physical resources

抽象物理资源。

当遇到操作系统的时候被问及的第一个问题是为什么会有他。因为操作系统可以实现系统调用作为一个带有应用连接的库。在这个计划中，每一个应用可以量身定做自己的库。应用可以直接与硬件资源交互，以及在应用最佳方式下使用那些硬件资源。一些针对嵌入式设备的操作系统或实时操作系统都用这种方法组织起来。

这种库方法的缺点是如果这里有超过一个应用在运行，应用们必须是通用的，例如每个应用必须周期性的放弃CPU，如此以便其他应用可以运行。例如一个协作时间共享安排可能是可以得到，如果所有的应用信任彼此且没有问题。应用之间没有信任反而是典型的。并且有问题。因此人们经常想要更彻底的隔离比起合作计划提供的隔离。

为了得到更强的隔离，禁止应用直接访问敏感的硬件资源是有帮助的。以及把资源抽象到服务中。例如，Unix的应用与存储交互时仅仅通过一个文件系统的open，read和write以及close系统调用。代替直接读写磁盘。这种方式给应用提供了路径名的便利性。允许操作系统去安排磁盘。即使不关心独立，有意交互的程序也更有可能找到一个比起直接使用磁盘更方便抽象的文件系统。

近似的，Unix显然在多个进程之间交换硬件CPU，保存和恢复存储器状态在必要时。以便应用无需知道时间分享了。这种透明允许操作系统分享cpu，即使一些应用无限循环了。

作为另一个例子，UNix进程使用exec系统调用去建立他们的存储映像。代替直接和物理内存交互。这种方式允许操作系统决定在内存的哪里开辟一个进程。如果内存是紧张的，操作系统甚至把进程数据保存在磁盘中。exec也向用户提供文件系统中去保存可执行程序映像的方便。

许多unix进程的交互形式都通过文件描述符发生。文件描述符不仅抽象了很多细节，某种程度上他们也以一种简化交互被定义。例如，如果一个应用处于管道故障，内核产生一个文件结束符号给下一个进入管道的进程。

系统调用接口具有程序员方便性和强隔离可能性的，是很小心被设计提供。unix接口不是抽象资源的唯一方式，他已经证明是很好的一个。

## 2.2User mode,supervisor mode,and system calls

用户模式，监视模式和系统调用。

强隔离需要一个在应用和操作系统之间的边界，如果这个应用犯错误，我们不希望操作系统崩溃或者其他应用崩溃。代替的操作系统应该可以清理那些坏掉的应用以及继续续运行其他应用。为了保证强隔离，操作系统必须安排那些坏掉的应用无法修改操作系统的数据结构、指令，同样无法访问其他进程的内存。

CPU核提供硬件支持对于强隔离。例如，RISC-V提供三种让CPU运行指令的模式。机器模式、监控模式和用户模式。指令在机器模式执行有着充足的特权，一个CPU在机器模式下启动。

---

其实这里的机器模式指的就是svc模式

---

机器模式几乎被用来配置一个电脑。xv6在机器模式下执行几行代码，然后就修改到管理模式。

在管理模式下cpu被允许执行特权指令：例如，使能和禁止中断，读取，写入保存页表地址的寄存器。如果一个应用处于用户模式下尝试执行一个特权指令，cpu不能执行该指令。但交换到管理模式以便管理模式代码可以终止应用。因为有些事情是被禁止的。在第一章的1.1小结中说明这个组织。一个应用可以执行用户模式下的指令，据说运行在用户空间下。当处于管理模式下的软件也可以执行特权指令，运行在内核空间下。该软件在内核空间运行被称之为内核态。

一个想要引用内核功能的软件必须转换到内核态。CPU核提供一个特殊的指令把cpu从用户模式切换到管理模式在内核指定的入口点进入内核。（RISC-V提供调用指令为此目的)一旦CPU已经切换到管理模式，内核就会验证系统调用的参数。决定该应用是否批准执行该请求的操作。要么否定要么执行。。对于内核控制的入口点对于切换到管理模式。如果应用可以决定内核入口点，恶意应用也可以。例如，进入内核在一个被跳过验证参数的点。

## 2.3Kernel organization

一个关键的设计问题是操作系统运行哪部分时要处于管理模式。一个可能性是当整个的操作系统都驻留在内核里。以便所有系统调用的事实都处于管理模式。这种结构被称为单内核。

在这种组织下整个操作系统运行都具有充足的硬件权限。这个组织是方便的因为操作系统设计者不必决定哪个部分不需要操作系统充足的硬件权限。与此同时，对于不同部分的操作系统之间也是更容易去合作。例如，一个操作系统可能有一个缓存可以被文件系统和虚拟内存系统共享。

单内核的劣势是操作系统的不同部分之间的接口是复杂的，因此对于操作系统开发者是很容易去制造麻烦。单内核中麻烦是致命的，管理模式下的错误往往会导致内核崩溃。如果内核失败了，电脑将停止工作，因此所有的应用也失败。电脑必须重新启动。为减少内核错误的风险，操作系统设计者可以最低限度的减少操作系统代码运行在管理模式的比例。在用户空间执行大部分的操作系统。这种内核组织被称为微内核。

在2.1中解释了这种微内核的设计。本小节中，文件系统作为一个用户级进程运行。操作系统服务作为调用服务进程运行。为允许应用和文件服务交互，内核提供一个进程间的交流机制去从用户模式下的进程发送信息给其他的进程。例如，如果一个类似命令行的应用想要去读取写入一个文件，他发送给一个信息给文件服务并等回应。

在微内核中，内核接口有许多低层级函数组成为了启动应用，发送信息访问硬件设备。这种组织允许内核变得相对简单，大部分的操作系统常驻与用户服务。

xv6作为微内核被实现，像大多数unix操作系统一样。因此，xv6内核接口与操作系统接口是一致的。内核实现全部操作系统。因此xv6不能提供服务，他的内核是比一些微内核更小的。但概念上xv6是微内核的。

---

上述其实就是体系结构和内核的概述，作为本科生的课程前期是足够的。但目前还不能让我满意

---

## 2.4 Code:xv6 organization

xv6内核资源在kernel/目录下的分支。资源被分割成多个文件，接下来遵循粗糙的模块化概念，图2.2列举了文件，模块之间的接口被顶一直kernel/def.h文件中。

---

这里好像没要求我阅读代码。。而且给我这么一个内核目录，让我到时候怎么自己创建呢。

---

## 2.5Process overview

在xv6中一个独立的单元是进程，进程抽象防止一个进程破坏或者监视另一个进程的内存、cpu、文件描述符等等进程资源。也禁止了一个进程监视和破坏内核本身。内核必须小心的实现进程抽象，因为一个错误或者恶意的应用可能欺骗内核或者硬件做某些坏事。这种机制被内核使用去实现包含用户/内核模式标识符的进程，地址空间，以及线程的时间片。

为帮助强化隔离，进程抽象提供了一个错觉，好像每个程序都拥有一个私人的机器。一个进程给程序提供了似乎私人内存系统。或者说其他进程无法访问的地址空间。进程也给程序提供了似乎它自己拥有一个CPU去执行程序指令。

| 文件          | 描述                         |
| ------------- | ---------------------------- |
| bio.c         | 文件系统的磁盘块缓存         |
| console.c     | 连接用户的键盘和屏幕         |
| entry.S       | 最开始的启动指令             |
| exec.c        | exec()系统调用               |
| file.c        | 文件描述符支持               |
| fs.c          | 文件系统                     |
| kalloc.c      | 物理页表分配器               |
| kernelvec.S   | 处理内核的陷阱以及定时器中断 |
| log.c         | 文件系统的日志以及故障修复   |
| main.c        | 启动期间其他模块的初始化控制 |
| pipe.c        | 管道                         |
| plic.c        | RISC-V中断控制器             |
| printf.c      | 设计控制台的输出             |
| proc.c        | 进程和调度器                 |
| sleeplock.c   | 放弃CPU的锁                  |
| spinlock.c    | 不放弃CPU的锁，自旋锁        |
| start.c       | 早期机器模式下的启动代码     |
| string.c      | C字符串和字符组库            |
| swtch.S       | 线程切换                     |
| syscall.c     | 发出系统调用去处理函数       |
| sysfile.c     | 文件相关的系统调用           |
| sysproc.c     | 进程相关的系统调用           |
| trampoline.S  | 切换用户和内核模式的汇编代码 |
| trap.c        | 从陷阱和中断处理返回的C代码  |
| uart.c        | 通用部分控制台设备驱动       |
| virtio_disk.c | 磁盘设备驱动                 |
| vm.c          | 安排页表和地址空间           |

xv6使用页表（有硬件实现的）去给每个进程自己的地址空间。RISC-V页表把物理地址翻译成虚拟地址。xv6保持一个独立的页表对于每个进程，这个页表定义了进程地址空间。这是图2.3的解释，一个包含该进程用户内存的地址空间在虚拟内存0处开始。指令首先出现，首先，跟随而来的是全局变量，然后是栈，最后是一个堆空间，这个空间是该进程当需要的时候可以扩展。

---

我记得堆的物理地址和栈并不是连续的，所以堆需要手动释放。

---

这里有许多限制进程地址空间最大值的因素：在RISC-V架构下的指针是64位的；当查看页表上的虚拟地址时会发现硬件仅能使用低39位（权限位占用了一些位）；以及xv6仅使用39位中的38位。因此，最大限度的地址是2^38-1 = 0x3fffffffff=255GB，而Linux下是4GB，这就是MAXVA(最大虚拟地址)。在地址空间的最顶端，

---

Linux内核和ARM架构对于进程地址空间都是简单解释是因为32位的指针所以是4GB，虚拟地址本身也是为了找到页表项中保存的物理地址，所以虚拟地址本身并没有意义，也不需要考虑32位中是否被占用了几位，虚拟地址不会占用页表项，我糊涂了。

---

xv6保存了一页的跳板。（一页一般是1MB，不考虑几级页表）

---

Linux内核中的跳板是一个用于实现动态CPU调度的机制，他可以在不同的CPU之间传递控制流。在这种机制下，每个CPU都有一个跳板，包含了一段指令序列和一些数据结构，用于保存任务的状态并调度其他CPU上的任务。其实这里就相当于是CPU的栈。

当一个任务需要在不同的CPU之间切换时，它会通过跳板将自己的状态保存到一个共享的数据结构中，并将控制流传递给另一个CPU的跳板。（不太像是栈，更像是一个寄存器，模式切换时寄存器会传递参数给另一个模式，这个跳板应该是一个结构体，保存了寄存器）接收到控制流的跳板会根据共享数据中的信息恢复任务的状态，并继续执行任务。

---

以及一个映射进程的陷阱帧，来跳转到内核。（这里的陷阱帧就是保存了一些寄存器，作用还不清楚），第四章的时候讲解。

xv6内核保留许多进程的状态片段，内核将获得一个proc结构体。一个进程最重要的内核状态的片段是他的页表、内核栈、以及进程的运行状态。接下来将使用p->xxx指代proc结构体的成员。例如，p->pagetable指的是进程的页表。

每个进程有一个执行的线程，这个线程执行进程的指令。一个线程可以被暂停甚至被重新开始。为显然的切换进程，内核暂停当前正在运行的线程，重新开始其他进程的线程。许多线程的状态被保存在线程栈。每个进程有两个栈：一个用户栈，一个内核栈。（p->kstack)。当进程正在执行用户指令，他的用户栈正在被使用，他的内核栈是空闲的。当进程进入内核（因为系统调用或者中断，中断会占用当前被打断线程的线程栈），他的用户栈将会保存数据，但不会被有效的使用。一个进程的线程交替使用它的内核栈和用户栈。内核栈是独立的，以便内核可以执行。即使用户栈被破坏了。

---

这本书很厉害，很直接的提出了线程具有两个栈，Linux内核那本书并没有明显的提出，只是因为客观存在而没有回避，ARM架构提出了。

---

一个进程可以通过执行RISC-V的ecall指令来使用系统调用。这个指令提升了硬件权限等级以及改变程序计数器变成了内核定义的入口点。入口点的代码切换内核栈以及执行内核指令从而实现系统调用。当系统调用完成后，内核切换回用户栈返回用户空间通过调用sret指令。导致更低的硬件权限等级和重新开始执行用户指令在系统调用指令之后。一个进程的线程可以在内核中阻塞，以便等待IO当IO完成后重新在他阻塞的地方开始运行。

p->state表明了进程是否被分配，准备运行，正在运行，等待IO或者结束。（很标准的四种状态）

p->pagetable保存进程的页表，以RISC-V硬件所期望的形式。当进程执行在用户空间中时，xv6会导致分页硬件使用进程的p->pagetable。一个进程的页表也会服务去分配给进程内存存储作为物理页面地址的记录。

## 2.6Code:starting xv6 and the first process

代码启动xv6和第一个进程。

为了使得xv6更具体，我们将概述内核是如何开始并执行第一个进程的。小节将会用更多细节的概述来描述机制。

当RISC-V架构的电脑启动，他初始化他自己，并运行一个引导加载，这是保存在只读内存中的。引导加载程序加载xv6内核到内存中。然后进入机器模式（Linux是进入svc模式），CPU在入口执行xv6的启动。RISC-V会将分页硬件mmu禁止并启动：虚拟地址直接映射到物理地址上。

加载者加载xv6内核宁愿在0x80000000也不在0x0是因为地址范围是0x0:0x80000000的这个范围内包含了IO设备。

入口的指令建立一个栈以便xv6可以运行C语言。xv6声明地区为一个初始栈0，在文件start.c中。入口处的代码将stack0+4096的地址加载到栈指针寄存器sp中。也就是栈顶。因为RISC-V的占是向下生长的。现在内核有一个栈，入口直接调用C代码在start处。

start函数将会设置一些只允许在机器模式下修改的配置。然后跳转到管理模式。为了进入管理模式，RISC-V提供了指令mret。这个指令是经常被用来在管理模式下调用，从管理模式跳转到机器模式。start不会从这样的调用中返回，相反会设置一些东西，好像这里已经有一个：start会设置以前的特权模式代替管理模式在mstatus寄存器中，通过写入main的地址到寄存器mepc中来设置到main的返回地址。在管理模式下禁用虚拟地址，通过写入0到页表寄存器satp中。将中断和异常委托给管理模式。

跳转到管理模式之前，start执行一个乃至更多的任务：编写时钟芯片去产生定时器中断。有了这个定时器中断后，通过调用mret指令返回管理模式。这回导致程序计数器变成main。

之后main函数初始化很多设备和子系统，它创建第一个进程通过调用userinit。第一个进程执行一个早已写完的RISC-V汇编的小程序，initcode。这个程序会重新进入内核通过调用exec系统调用。

当我们看第一章的时候，exec用一个新的程序来移除当前进程的内存和寄存器。一旦内核完成了exec，就会返回到init进程的用户空间。如果需要的话，init会创建一个新的控制台设备文件并且打开这个文件作为文件描述符012。然后他在控制台上开始一个命令行。系统建立。

## 2.7Real world

在真是的世界，可以找到单内核和微内核。一些unix内核是单一的。例如Linux有一个单内核，虽然一些OS函数作为用户级服务来运行。像L4、Minix和QNX内核被设计作为一个带有服务的微内核，在嵌入式中有着很广泛的部署。

大多数的操作系统已经采纳了进程概念，大多数进程看起来类似于xv6，现代操作系统，支持一个进程有很多线程。为了允许单一进程去利用多核cpu。支持进程中的多线程涉及到大量xv6所没有的机制，包括潜在接口改变，以控制进程线程分享的方面。

## 2.8Exercises

1. 你可以使用gdb去观察第一个内核到用户的转变，运行命令make qemu-gdb。在另一个窗口，相同的路径下，运行gdb，输入gdb命令，中断0x3ffffff10e，这个地址设置了一个断点在sret指令从 内核跳转到用户空间。输入continue gdb命令，gdb应该在断点处停止，即将执行sret命令。输入stepi，gdb应该马上表明他正在执行0x0地址，这是用户空间下initcode.S文件的最开始的地方。

----

这一章，就是讲述概念，然后介绍代码，但我没看代码，最后的练习是使用在qemu硬件模拟器上使用gdb调试内核运行。这个得明天做了。







