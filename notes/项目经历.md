# 项目经历

## 低温下太阳能供电系统研发

### 硬件系统设计

总结下用到的传感器芯片，外设。电路板部分需要看懂，始终认为项目经历是最重要的，所以这方面要花费大量的时间看懂才可以。用到的一些电容电阻也要搞清楚，芯片手册需要都查一遍。硬件方面提供了哪些功能。

#### 主控部分

采用的是STM32F103CBT6芯片，此芯片具有48引脚、128KB的内部flash。选择此芯片是因为对于我们预估的引脚资源和代码量是满足的。加上此芯片价格便宜。本项目想要实现的不仅仅是自动充放电的功能，还需要根据当前环境参数设置多种工作模式，并将环境参数显示在屏幕上，以及与上位机的无线通信。为了保证整个系统的稳定性以及性价比问题，决定在单片机层次实现功能。

#### 传感器外设方面

1. 温度传感器

   考虑到本项目通过给电池进行保温、加热从而实现在低温环境下的充放电行为，为此需要增加温度传感器，采用的是市场上常用的DS18B20芯片，测温范围在-55℃到+125℃。此芯片采用的是单总线接口。直接直插焊接在电路板上，因为这种特点，温度传感器无法直接检测出电池温度，只能让电路板尽可能靠近电池。
   
2. 光照传感器

   本项目采用的是在低温下利用太阳能板接收太阳能转换成电能实现对电池的充电功能。所以必须采集太阳能相关数据，借此判断在什么情况下可以对电池实现充电。采用的是市场上常见的BH1750芯片。电路板是提供了五个直插的公头引脚，通过杜邦线连接放置在外部的BH1750芯片。因为光照传感器必须与太阳能板放置方向一致。采用的是I2C通信
   
3. 加热模块
   
   本项目可以在低温下工作的保障是保温箱的保温功能以及加热模块的加热功能，这里采用的是PI电热膜，实际功率由主控芯片CBT6负责，决定什么时候开始加热。由于电热膜的加热速度过快，在电池外围包裹一层锡纸起到全局加热。
   

#### 外部存储方面

1. EEPROM模块

   考虑到掉电以后需要保存一些数据比如当前光照强度、当前温度值等等，需要添加一个外部存储器，采用的是AT24C02芯片，I2C通信，存储容量是256B

#### 外部显示方面

1. 蜂鸣器模块

   本项目考虑到在极端环境下电池电压低于放电截止电压，此时继续放电会损坏电池，此时需要更换电池，由蜂鸣器报警通知工作人员更换电池。

2. OLED屏幕模块

   为了便于工作人员从外部观察当前系统参数，添加屏幕模块，考虑到功耗的问题最终采用0.96寸、分辨率为128*64的OLED屏幕，由于屏幕需要镶嵌到保温箱壁上并且主控芯片的引脚资源有限，这里不采用8080/6080的并行接口，采用四线SPI通信，考虑到距离达到几十厘米，所以采用软排线进行连接，在电路板上装有软排线的接口。

#### 远程通信部分

1. RS485通信模块

   需要在不断电的情况下远程控制电路板，考虑到信号稳定性以及传输距离这里采用RS485通信。让串口的输入输出引脚以及方向选择引脚连接SP3485芯片，芯片另一端输出四个引脚分别是vcc/gnd/A/B，其中AB就是差分信号了，这一步是将串口信号转换成RS485信号，再通过RS485专用数据线连接到电脑的USB口。从而实现远程与电脑通信。后来编写的远程控制指令就是以485作为物理层的。

2. ZigBee无线通信模块

   在项目后期需要将采集到的电压等信息发送到上位机和远程控制终端，多个设备绘制充电/放电曲线。这就需要借助无线通信的广播形式实现一对多的传播，电路板上需要给zigbee节点的核心板保留一部分母座。实际上电路板就是提供一对串口输入输出引脚，两个GND，两个VCC负责供电。

#### 烧录程序部分

1. ST-link接口模块

   烧录/调试程序必备的模块，需要四个引脚，分别是VCC和GND，剩下两个连接到主控芯片的SWDIO/SWCLK，实际上只需要三线连接（去掉VCC）就可以实现烧录程序了

2. 有源晶振模块

   因为无源晶振的抗干扰性不强，所以在电路板上焊接一个8M的有源晶振，需要修改系统时钟里面的HSE高速外部时钟。设置倍频。

#### 电源充电/供电部分

1. USB供电模块

   电路板上设计了两个usb口，第一个是用来提供5v电压。第二个是通过稳压器AMS11173.3提供3.3v电压，这两个usb口是在调试板子的时候提供3.3v和5v电压。

2. 太阳能电压转换

   1. 充电电路

      太阳能板可充电电压是28v电压，经过主控芯片引脚同意后，允许太阳能板的电压提供给CN3722芯片，CN3722适合对多节锂电池进行充电管理。此芯片的设置都是硬件设定的。最终提供出之前设计的电池充电电压，此芯片具有恒流和恒压两种充电模式。并且此芯片带有一个done输出引脚，当充电完成后此引脚输出低电平，否则高阻态。

   2. 供电切换电路

      同样是由主控芯片控制引脚，决定是蓄电池还是太阳能电压提供给开关按钮。当按下开关按钮以后将由该电压提供给3.3v供电电路和5v供电电路。
   
   3. 3.3v降压模块
   
      采用MP4462芯片，实现降压成3.3v，此电压提供给包括主控芯片、有源晶振在内的多个设备。
      
   4. 5v降压模块
      
      通过E2405芯片转换成5v电压，用来取代usb口提供的5v电压。
      

####  电量检测部分

本项目需要绘制充电放电曲线，监测电池充放电情况是必须的。采用LTC2944芯片监测电池的充放电、电池本身电压、电流和自身的温度。通过监测通过感应电阻产生的电压来测量电荷。每十秒执行一次温度、电流和电压的转换测量。转换结束后相应的寄存器会被更新，通过I2C通信读取LTC2944芯片采集的数据。该芯片有一个被外部上拉的引脚，连接到主控芯片，当输出为低电平时，说明芯片寄存器超过阈值。

#### 负载供电部分

其实这个电路就是采用了一个三极管和一个mos管，当主控芯片的引脚输出高电平之后，允许蓄电池提供的电压流过mos管。如果此时太阳能板正在给电池充电的话，此时是由太阳能板给负载供电。

#### 远程控制面板部分

项目需要提供远程观察电池的充放电曲线情况，为此采用正点原子的迷你开发板STM32F103RCT6，搭配一个2.4寸的LCD屏幕，移植LittleVGL，通过杜邦线让迷你板连接一个zigbee节点的核心板。实现迷你板与项目板之间的zigbee广播通信。

#### 无线通信部分

采用的是网蜂WB家的zigbee节点。

### 软件系统设计

#### 软件系统的体系架构

首先是对各种芯片、传感器的选型，尽量寻找市场上常用的、大店的芯片，这保证了资料全面、有技术支持并且芯片质量得到保证，有效的回避了因为芯片本身出现问题而导致调试复杂的情况发生。

根据芯片的数据手册以及驱动程序决定是否使用该芯片。

在整个软件系统的设计上，首先编写的是各个芯片的驱动代码，创建excel表来记录主控芯片的硬件资源。统计好使用的每个引脚及其对于电路的作用。

首先将软件系统进行分层，**最底层是硬件层**。主要是

- 对主控芯片的控制引脚函数进行封装并调用
- 对用到的各个芯片驱动进行封装，比如与芯片的通信程序、控制或接收芯片的引脚等与硬件相关的程序。各个芯片驱动程序单独存放在各自的文件中。

因为要尽量缩短中断时间，所以只是在外部和内部中断中更新标志位和数据。然后在main函数中根据标志位决定进入哪种工作模式。

在这一层中解决硬件相关的问题

**第二层是状态机层**，创建前后台以及状态机。

- 接下来是根据每种工作状态的需要编写相应的模块，在模块中调用初始化芯片函数、读取芯片函数等。因为一个工作模块中可能包含对多种芯片的操作，所以工作模块是创建在main文件中。
- 然后需要编写状态迁移表，从代码上观察就是编写多个结构体数组，每个结构体中包含当前状态、事件ID、下一个状态、回调函数。这里的回调函数就是切换到下一个状态所需要的操作。结构体数组表示当前状态可能切换到哪些状态。也就是状态迁移的可能。
- 创建前后台软件模式，编写外部中断服务函数和定时器中断服务程序。其中外部中断是用于其中一种紧急模式的。因为是按钮触发外部中断，需要添加滤波算法也就是延时去抖动，判断是否进入紧急模式的标志位。
- 定时器中断采用的是每秒中断一次，在程序中对每种传感器采集一次，更新数据。实现指示灯闪烁功能表示程序正常运行。并且每秒判断一次应该进入哪种工作模式的标志位。
- 在main函数中实现的是初始化工作以及死循环中轮询应该进入哪种工作模式的标志位判断。
- 编写远程控制指令函数，通过轮询的方式来检查接收到的控制指令。控制指令共有4字节，分别对每个字节进行判断，从而做出相应的操作。这里的操作包括通过串口打印屏幕信息、打印特定信息、保存当前信息到eeprom中、读取eeprom中的信息等。

在这一层中解决软件系统中的工作流程、逻辑部分。

##### 移植状态机的优缺点

不过状态机虽然将各个工作模式以及迁移条件明确清晰化，但也带来了大量的全局变量也就是标志位。这反而增加了代码的复杂性。

##### 前后台的优缺点

前后台的工作模式可以保证代码的及时性，但因为当初没有考虑函数的可重入性问题，导致系统稳定性不强。最重要的是无法系统的统计当前资源、每种工作状态中过多的重复调用同一种任务、没有任务优先级的概念。

第三层是应用层，在项目板上移植FreeRTOS以及在远程控制面板上移植LVGL。

##### 为什么要移植FreeRTOS

移植前是26.9KB，移植FreeRTOS之后是46.9KB，实时操作系统大小是20KB。为了解决上述的问题，移植FreeRTOS实时操作系统，以牺牲部分资源为代价换取更高的性能。FreeRTOS中的任务优先级是从0-31，其中0是空闲任务，31是软件件定时器。这里依次设置三种任务的优先级、任务堆栈的大小。

##### 在项目中是如何借助FreeRTOS的

创建三个任务，第一个任务专门用来轮询标志位判断当前的工作状态。

第二个任务专门用来轮询屏幕显示以及接收远程控制指令。因为屏幕显示是实时的每个工作模块中都包含，所以单独拿出来。在远程控制指令中添加打印系统信息。

第三个任务是将本来定时器中断中的每秒采集一次传感器函数拿出来，在第三个任务中实现对传感器的采集。代码上通俗易懂

在外部中断和定时器中断中只保留判断标识位。通过牺牲一部分内存，使得多任务可以以时间片轮询的方式并发执行，并且提供了任务优先级、任务堆栈大小等概念，可以系统的了解当前资源。

LittleVGL不介绍了，乏善可陈，就是用它创建一个GUI界面，显示充放电曲线。

#### 反汇编部分

考虑到项目的代码闭源问题，需要防止有人对代码的可执行文件进行反汇编从而获得源文件。并且也是为了防止有人通过可执行文件加上复现硬件系统从而实现克隆等问题。在执行整体代码前需要判断当前产品唯一身份标识96位。通过访问主控芯片的特定寄存器，获取该芯片唯一的身份标识并进行判断是否是所允许执行的芯片。

#### 外部晶振部分

因为使用的是外部有源晶振，所以需要

1. 使用HSE时钟来设置系统时钟。
2. 需要设置AHB/APB2/APB1的预分频因子。
3. 设置PLL锁相环的时钟来源和倍频因子。
4. 开启PLL锁相环等待PLL稳定。
5. 把PLL设置为系统时钟SYSCLK。
6. 读取时钟切换状态位，确保PLLCLK被选为系统时钟。

#### 状态机部分

因为本项目的工作环境是不断变化的，所以需要针对每一种可能出现的工作环境设计专门的工作状态，并设计每种工作状态之间发生切换所需要的事件。移植状态机的目的就是为了将每种状态以及状态迁移的条件清晰化。

- 初始化模式：太阳能板不给电池供电、电池不给5v3.3v供电
- 正常模式：太阳能板给电池供电，电池向5v3.3v供电，由电池向负载供电
- 节能模式：太阳能板给电池供电，太阳能板向5v3.3v供电，由电池向负载供电
- 睡眠模式：太阳能板不给电池供电，太阳能板向5v3.3v供电，电池不向负载供电
- 紧急模式：蓄电池向负载供电，太阳能板不向电池供电、电池向3.3v5v供电，判断当前电池电压是否达到放电截止电压，如果达到则电池停止向负载供电。
- 等待充电模式：由太阳能板向负载供电、太阳能板向电池供电、电池提供3.3v5v供电。

#### 项目bug解决部分

本小节主要是介绍下项目研发中遇到的bug实验现象、以及解决问题的思路。

1. **OLED屏幕采用并行8080协议**，但是屏幕需要使用杜邦线连接镶嵌到保温箱外壁上，这导致了屏幕卡死、雪花、黑屏等问题

   解决方法：先判断硬件问题，通过更换更短的杜邦线排除杜邦线铜丝断裂的问题、将OLED屏幕直接固定在电路板母座上，排除OLED屏幕本身硬件问题，从而发现问题在于并行协议无法支持远距离通信。修改为四线SPI

2. **状态机与FreeRTOS的设计思想有何区别，如何修改**

   解决方法：状态机是设计系统的每种工作状态、会遇到的事件、每种状态发生多种事件之后迁移到的下一个状态。核心是状态迁移表。采用的是前后台模式，轮询+中断。而FreeRTOS是创建多个并发执行的任务，每个任务的优先级不同。如果想要在状态机上移植FreeRTOS，本项目是专门有一个任务控制工作状态、一个任务负责屏幕显示、一个任务负责采集传感器信息。采用的是多任务并发执行+中断。

3. **当在现有系统中加入一个模块后导致整体系统瘫痪的问题。**

   解决方法：首先，编写每个模块的时候要保证模块之间的低耦合性，尽量避免在某一个模块中大量调用其他模块的API。其次，采用控制变量法来调试bug，当模块过多的时候，必然会导致整个系统不稳定，所以调试的时候要单独将某个模块拿出来调试。

4. 当轮询与中断共同调用或者访问了共享函数/变量时导致系统不稳定的问题。

   解决方法：在定义全局变量或者函数的时候就要考虑函数的可重入性问题，并且要将变量设置为动态变量，避免编译器优化导致的问题。

5. **调试DS18B20温度传感器的时候出现了温度恒定在85℃的现象。**

   解决方法：通过查阅该芯片的数据手册发现85℃是相应寄存器的初始化值，通过查找代码中调用的该芯片初始化函数发现前后台中都调用了该函数，导致该芯片始终处于初始化阶段，删减该函数被调用次数后解决。

6. 更换新电路板之后，OLED屏幕出现雪花问题

   解决方法：在旧板子上好使，在新板子上不好使，认为和有源晶振相关，通过调整HSE的倍频由低到高，依次调试一遍后解决问题。
   
7. 如何避免过长的时间停留在外部中断和定时器中断上下文的问题

   解决方法：利用中断上下部的思想，将中断服务函数当成中断上半部，在这里修改标志位，在main函数的轮询中判断标志位进而执行不同的指令。

8. **对于软硬件bug的常用调试方法有哪些**

   解决方法：软件部分，最常用的、成本最低的是串口调试printf，其次是借助st-link的Debug功能，但是这个方法对于中断效果不好。

   硬件部分：采用的是万用表、3.3v/5v的led小灯泡、示波器用于检测下通信协议的时序图是否正常以及引脚是否正常输出电平、对于电源类的ic可以使用可调电源来模拟充放电。

9. **主控芯片的管脚无法正常输出高低电平**

   解决方法：通过查看电路板发现是STM32F103CBT6的引脚PD1输出有问题，配置PD1输出高低电平，在电压表上显示的是1.44V，在示波器上显示的是一段波形图，由此认定是引脚硬件本身出问题或者初始化引脚的驱动有问题，通过查阅芯片手册，发现PD0和PD1是连接外部晶振的引脚，如果想做为GPIO输出，需要使能复用的外设时钟。

10. 芯片如何选型、画电路、调试。

    解决方法：首先根据需求上网搜索相应的芯片，找到一批功能相同的芯片之后，需要根据实际要求筛选出合适的几个芯片，然后根据芯片是否国产、芯片价格、是否是大店的、销售额多少、有没有技术支持、配套资料是否足够、大概看看芯片的数据手册等多种因素最终找到适合的芯片。

    之后查看芯片的数据手册，弄懂芯片的工作原理以及引脚功能、看下配置芯片的方法是硬件配置还是软件配置，如果是软件配置看下是哪种通信协议。主控芯片需要提供哪种引脚。

    根据芯片的典型电路以及硬件配置要求绘制电路图。

    这里以充电芯片为例，由于电压的缘故，需要对多节锂电池进行供电，本来选择的一款充电芯片是分别对每一节锂电池进行供电，但是实际上定制的蓄电池只有头尾暴露出来，所以最后采用了CN3722芯片。

### 项目自我介绍

我组设计的是一台可以在低温下利用太阳能对蓄电池和负载供电的发电系统。供电给隔壁项目组的测量雪地摩擦系数的装置。我主要负责的是发电系统的部分芯片选型和整体下位机开发工作。其中芯片选型包括电池充电芯片CN3722、电量检测芯片LTC2944、光敏传感器BH1750、温度传感器DS18B20等以及其他芯片。针对工作环境设计相应的工作状态，绘制状态迁移表，为实现多任务并发操作移植FreeRTOS，为方便调试下位机设计远程控制指令，可以通过RS485或zigbee广播即可发送接收指令。分别对远程控制终端和上位机广播。在远程控制终端上移植LVGL设计控制面板并监测充电曲线。上位机使用的是树莓派连接zigbee节点。

----

思考了很久，复习项目经历吧，低温太阳能的问题是涉及到的硬件比较多，不需要框架。复习起来就是花费时间做体力劳动，我也想认真看看那些协议，但是提不起劲。等到八股复习到IIC的那天晚上看看协议吧。

而且目前项目还是以Linux为主，面试肯定是先聊这个，而且这个有难度，我很喜欢，重点就是IIO框架+驱动模块依赖问题，剩下还得看看教程中配置内核的东西。这个项目没有做完，还需要变成内核驱动，这就需要解决依赖问题了。可以先做项目。这样也算复习了。

---

## 智能机器人

总结下智能机器人的项目经历，严格来说这个项目早在21年就已经结题了，这是属于我的毕业设计以及实验室的课题。重点是软件中的IIO框架，这个项目经历很重要，这是最近的、唯一一个上操作系统真正意义上的Linux驱动的项目。我主要负责的是将主控板从树莓派切换到157，具体的说是调试硬件部分以及编写驱动模块、编写多个IMU级联的应用层App。

### 硬件系统设计

本项目的硬件部分并不是我设计的，我属于接手往届师兄的项目。主要工作是看懂原理图、PCB、芯片手册，确保采集板可以正常工作、接通电源，完成转接板原本的功能，将原来的主控部分从树莓派切换成157，157作为主控板与转接板之间使用跳线连接。

在肌电信号采集板上焊有音频三级柱接口，用于连接音频线，在音频线的另一端则是连接一个纽扣接口，这个纽扣接口连接电极片。本项目采用的是圆形电极片，将电极片贴附于人体皮肤表面从而实现采集肌电信号的功能。采集到的电信号过于微弱，需要依靠肌电信号采集板上的两个放大三极管进行信号放大，将经过放大滤波后的电信号传入肌电信号采集板中的肌电信号采集芯片ad7606，这款芯片与主控芯片之间采用的是SPI通信，实现数据的传递。为了增强信号的传递距离，采用软排线连接，为此设计的一个转接板。转接板连接主控板和采集板，通过跳线连接到主控板。主控板负责实现对肌电信号的采集工作。

本项目还需要提供角速度、角加速度、加速度等运动参数，采用了维特家的WT901C-485模块，这是一个陀螺仪传感器，支持多IMU级联的功能，可以采集多个陀螺仪的数据，将陀螺仪绑定在人体下肢上，从而获得完整的下肢运动信息。数据传入主控板中，在整体项目中157开发板是作为数据采集中心。最终发送给上位机。

#### 肌电信号采集板

因为我负责的是调试采集板确保采集板能够正常工作。首先是查看电路板的电路图、PCB以及使用到的芯片手册。对采集板的工作原理、接口有了清晰的认识。

1. 电源供电部分

   使用12v、5600mA/h的锂电池进行供电，12v的电压首先是经过一个降压芯片KA7810降压成10v，之后10v通过两个负压芯片L7905CV变成5v电压。在电源供电部分有两个显示灯，这两个led灯都是5v压差点亮的，分别两次是10v，5v。和5v，gnd，当两个led亮起时表示降压模块和负压模块正常工作。之所以提供10v和5v是因为肌电信号放大电路中需要使用。
   
2. ad7606部分

   ad7606芯片是16位8通道同步采集的ADC芯片，并且有串行和并行接口，需要5v电压作为参考电压。使用该芯片需要设置过采样倍率等。这款芯片缺点是管脚过多，拥有64pin，内部没有寄存器地址，只能通过外部电平配置芯片。项目中一部分是直接硬件配置了，一部分是由主控引脚设置。8通道采样方面，每个通道分配两个管脚，分别连接的是模拟输入和模拟接地，与主控板通过软排线进行连接。往届师兄出现了引脚画错的现象，将其他的引脚占用了。 这里也有两个指示灯，分别表示提供给ad7606的5v和3.3v电压是否正常。 

3. 信号采集部分

   采用AD8642芯片信号放大器以及AD8220芯片。这两款芯片作用是滤波+放大肌电信号。之前降压和负压转换的10v和5v应用在这里。

#### 软排线转接板

这个其实没什么可讲，当初拿到电路板之后与PCB进行了比对发现有部分电路的走线和布局与实物存在差异，使用万用表中的电流表进行了检查，发现电路并不通。然后在实验室找到了一块通用的转接板，因为没有PCB，使用电流表对比之后发现软排线与母座之间的对应关系很简单，就使用了这个转接板。

#### 多个IMU陀螺仪

支持多个模块级联，物理层使用的是RS485协议，软件层使用的是MODBUS协议。一个IMU连接USB转485线，USB连接到主控板157的USB口上。其中157上的USB作为host主机。其余的IMU使用485线连接。需要在厂家提供的上位机软件中配置每个IMU的设备地址。然后校准。在编写的应用层APP中发送读取寄存器指令即可读取所有IMU的数据。

#### STM32MP157开发板

使用的是正点原子的STM32MP157开发板。

### 软件系统设计

本项目中，我真正的工作量是将代码从树莓派4B移植到stm32mp157上。这包括了调试采集板等硬件、编写ad7606芯片的驱动模块、编写IMU级联的应用层APP。

#### 软件系统的体系架构

这是在Linux平台上运行的软件，从系统移植开始分析、uboot、kernel、rootfs，然后是配置kernel，查看树莓派上的驱动是怎么写，移植到157上，分成驱动模块和应用层APP，以及编写设备树用来描述设备信息。将树莓派上的代码从应用层变成驱动模块和应用层和设备树。分别在加载内核、加载驱动模块、执行应用的时候派上用场。

#### 系统移植部分

1. uboot

   一般不使用uboot官方的代码、因为使用的是开发版厂商正点原子的板子，所以直接使用正点的uboot，uboot的镜像u-boot.stm32这是添加了头部信息的镜像。烧录到外存中。以后上电就会自动执行uboot

2. kernel

   这里使用的是5.4.31版本内核，同样是正点原子出版的内核，调试板子的时候使用的是tftp网络下载，在uboot定义环境参数bootcmd，在这里定义通过tftp方式下载kernel和设备树.dtb文件到c2000000和c4000000地址。通过网络下载的好处就是调试起来会比较快。

3. rootfs

   内核的系统镜像保存在根文件系统中（但是嵌入式Linux因为资源有限，把内核代码镜像保存在外存中了），我们需要加载和运行的驱动模块与APP也保存在根文件系统。根文件系统从哪里下载也是由uboot中的bootargs环境变量决定的，在此环境变量中定义标准输入输出错误是用的哪个外设、以及根文件系统的地址。使用buildroot构建根文件系统。比busybox优秀的地方在于不仅集成了busybox，还集成了各种常见的第三方库和软件。

#### 设备树部分

157和树莓派最大的区别在于157开源，无论是底层的数据手册还是运行的Linux系统都是开源的，而树莓派的底层数据手册不开源，并且运行的是专属于树莓派的操作系统。所以树莓派不可以单独画板，只能使用成品板。正是这个原因，树莓派是无法单独描述设备信息的，所有的代码都放在应用层运行，对硬件的操作是通过专用库中的接口实现的。当树莓派代码移植到157上时，需要重写设备树，首先是在excel上统计用到的主控引脚，本项目中主要驱动的是ad7606芯片，所以就是以ad7606为核心描述设备信息，上ad7606芯片的官网亚德诺，官网上给出了在Linux下的驱动以及设备树。以官网的设备树为基础根据自己用到的引脚来修改。

##### 编写设备树需要哪些文件？

- 需要pinctrl.dtsi文件，这个文件是存放引脚的电气属性比如推挽输出、上拉输入、有效电平为高之类的。
- 需要157d.dts文件，这个文件就是我们真正使用的设备树文件，根据目前要使用的板子修改当前文件，在这个文件中创建设备节点、追加设备节点信息。调用pinctrl.dtsi文件中的引脚电气属性。设置引脚的默认电平、兼容值等信息。
- 需要151.dtsi文件，这个文件中存放的是原始的设备树文件，这是半导体厂商提供的设备树，针对于半导体厂商提供的开发板，dts文件中追加的内容都是追加到当前文件中的。以这个为基础修改成适用于本项目使用的开发板的设备树。

##### 为什么ad7606的设备节点要写在SPI节点下？

ad7606是采用SPI通信的，在驱动模块中实际上是先让内核使能的SPI主机驱动匹配设备树中的设备节点，然后由SPI主机驱动初始化四线SPI通信的四个引脚，其实这里的SPI主机驱动就是AMBA总线下的SSP这是串行接口。分为SPI和IIC，而SPI设备驱动中对相关引脚的控制是依靠SPI主机驱动提供的设备节点。

##### 为什么要把ad7606用到的所有引脚都放在ad7606节点下？

本身设备树意义就是用来描述设备信息的树形结构。用到了面向对象的思想，凡是描述ad7606设备信息的属性都要存放在ad7606节点下，代码逻辑性强，并且方便驱动模块中控制同一个设备节点下的多个引脚。

#### ad7606驱动部分

##### GPIO子系统的两种接口

对于四线SPI的引脚SPI主机驱动会完成初始化，就是通过of前缀的接口获得相应的GPIO编号，对于gpio前缀的接口而言就是使用gpio编号实现的对相应的引脚控制。这种前缀需要先get引脚的gpio编号。通过of_get_named_gpio()函数寻找设备树节点中的属性，返回gpio编号，然后通过gpio_前缀的函数对gpio编号操作进而控制相应的引脚。

对于新的接口gpiod_前缀的函数，返回gpio _dest类型的结构体。使用gpiod _get _index函数，此函数包含了获取、请求、初始化三步。

之所以使用gpiod_前缀的新型接口是因为查找设备节点的工作SPI主机驱动已经实现了，只需要根据SPI主机驱动提供的设备节点就可以实现对引脚的控制。

##### 为什么使用IIO框架，并介绍下IIO框架主要的结构体，及其之间的关系

ad7606芯片属于ADC类的芯片，Linux内核为了管理这些ADC类传感器，特地推出了IIO子系统，也就是工业I/O。随着分散在内核源代码上由不同代码实现的传感器数量的增加，为了减少内核代码的冗余，开发的工业I/O。IIO模型基于设备和通道架构。

- iio_dev结构体，这是IIO设备的设备结构体。
- iio_info结构体，当读取sysfs/bus/iio/iio:device3目录下的属性时，该结构体中的函数指针被调用，触发器与设备之间的绑定验证函数。
- iio_poll_func结构体，用于向iio_trigger申请虚拟中断的结构体。包含了虚拟中断的上下部
- iio_chan_spec结构体，此结构体是用来描述通道的结构体
- iio_buffer结构体，IIO缓冲区的结构体，缓冲区是由内核数据结构kfifo管理的
- access结构体，此结构体实现了缓冲区的访问功能。包括从iio设备推送到缓冲区以及从缓冲区推送到应用层
- iio_trigger结构体，IIO触发器结构体的内部成员大多与虚拟中断相关。

##### 使用IIO缓冲区时，外部中断是如何最终将数据推送到缓冲区的

外部中断被触发->执行iio_trigger_poll->触发iio_trigger创建的虚拟中断控制器->执行虚拟中断上半部->执行中断下半部

##### iio_trigger_poll函数是如何执行的

此函数被外部中断调用，用于触发虚拟中断。循环遍历触发器池中的虚拟中断->判断每个虚拟中断是否被使能了->如果被使能就执行中断。触发器中的poll32位图用来表示哪一位未被申请，遍历的是softirq[]，如果有一个虚拟中断被使能了执行它对应的中断上下部。

##### 触发器与IIO设备之间的绑定本质上是什么

iio_dev中的pullfunc成员作为consumer向iio_trigger申请虚拟中断。

##### 在虚拟中断上半部和下半部中分别执行什么操作

- 上半部：99%的上半部就是获取时间戳
- 下半部：通常是将从每个启用的通道读取数据并送入缓冲区中。附带时间戳

##### devm_iio_triggered_buffer_setup函数具体工作

创建buffer，用kfifo进行管理，创建并初始化iio_poll_func结构体，注册申请/释放虚拟中断的函数。

##### ad7606芯片官网上的驱动问题的调试流程

- 实验现象：sysfs/bus/iio目录下的iio:device存在，dev/下的IIO缓冲区设备节点页存在。
- 说明：iio_dev注册成功，iio_buffer设置成功。
- 实验现象：可以通过读取sysfs目录下的通道属性实现单次读取数据。但是无法通过缓冲区读取数据。
- 说明：因为共用最底层的数据通信，至少SPI框架没有问题，设备树没有问题，可以正常读取芯片数据。问题可能出在完成变量、缓冲区设置上。
- 实验现象：通过设置printk函数在外部中断的两种判定结果中，无论单次读取还是多次读取都可以打印。实际上是iio_info结构体中的函数好使以及外部中断也好使。
- 说明：完成变量complete是正常使用的，该阻塞时阻塞，该释放时释放。可以排除complete的问题
- 实验现象：本以为是iio_trigger_poll函数无法触发虚拟中断，在/proc/interrupts目录下可以看到所有申请的中断，在icm20608实验中存在两个中断，分别是外部中断和虚拟中断。而ad7606实验中只存在一个外部中断。
- 说明：由于ad7606虚拟中断没有进行申请或者申请失败，导致流程断裂，最终数据并没有推送到缓冲区中。
- 实验现象：通过深入了解IIO子系统的结构体成员，发现iio_dev中的iio_poll_func结构体向iio_trigger申请虚拟中断是在postenable函数中进行的。对比了官网和内核驱动的区别，发现在缓冲区的ops操作函数结构体中的启用缓冲区前和禁用缓冲区后两个函数中存在差异。修改后在proc/interrupts目录下找到虚拟中断。
- 说明：官网驱动存在问题，缺少函数，当初因为硬件焊接问题并没有直接使用内核驱动，而是参考官网驱动根据实际焊接情况编写驱动模块。

至此，多次读取的流程完整，可以通过缓冲区读取数据。

##### 驱动模块中如何协调单次读取和多次读取

单次读取指的是通过读取sysfs目录下的通道属性读取的相关数据。

多次读取指的是由外部中断引发虚拟中断将通道中的数据推入缓冲区，读取缓冲区的设备节点实现的多次读取。

实现层面上单次读取采用的是iio_info中的函数，此函数在驱动模块中定义。直接将数据从驱动模块中发送到应用层。

多次读取采用的是外部中断触发虚拟中断，由虚拟中断中的下半部执行推入函数，从用户层读取设备节点触发access结构体中的的read函数从而将数据推送到应用层。

但无论是iio_info还是中断下半部最底层的数据通信是唯一的，这就涉及到线程同步的问题了，采用complete完成变量，在probe函数中初始化，在外部中断中判断如果没有使能缓冲区就释放完成变量，在单次读取函数中等待完成变量的释放，从而实现两种读取方式的同步。具体的说是在单次读取函数中wait_for_completion_timeout函数被调用，在外部中断中判断如果没有使能缓冲区就complete函数执行，使能了就执行iio_trigger_poll函数调用。

##### 官方驱动与学习中编写的驱动优势在哪？

- 首先是对于gpio子系统中接口的使用，在学习中对icm20608芯片通信时，在SPI1节点下的设备节点中并没有出现引脚信息，导致在icm20608驱动模块中没有使用gpio相关接口。四线spi直接由spi主机驱动初始化了。但是在本项目中需要在驱动模块中初始化其他引脚，由此了解到gpiod接口
- 在驱动模块的各个线程中涉及到线程同步的问题，官方驱动采用了完成变量的方式来进行线程同步。
- 官方驱动是针对整个ad7606系列进行的编写，很多地方采用了泛式编程的思想，一个驱动模块在整个系列中通用。
- 官方驱动往往更好的全面的利用芯片的性能，对于芯片提供的每一种功能都会利用上。
- 官方驱动是针对正确焊接芯片的，如果芯片焊接出现差异就不能直接使用官方驱动。

##### 项目板子的芯片焊接出现问题时的解决思路

在查看PCB以及芯片的数据手册时发现ad7606芯片的frstdata引脚也就是回读引脚被当成spi_mosi引脚了，这导致主控芯片无法往ad7606中写入数据，在查看往届树莓派代码中发现并没有写入数据的操作。读取芯片手册时发现，只需要控制相关引脚电平就可以导致ad7606自行发出数据。查看官方驱动之后确认依旧可以读取数据。

##### ad7606与icm20608挂载在同一个SPI下需要注意什么

- 首先需要区分下SPI和IIC之间的总线区别，SPI采用的是cs片选引脚来决定每次和哪个设备通信，而IIC是采用设备地址来进行区分的。
- 所以在编写设备树时需要在SPI1节点下编写两个cs-gpios属性。
- 在SPI节点下创建两个设备节点，这两个设备尽量避免同时访问

##### 驱动模块中的原始值与真实值如何转换

因为要避免在内核态进行浮点数运算，所以将原始值发送到应用层，在应用层的APP中进行浮点数运算。

##### ad7606驱动在157和树莓派的代码上有什么区别

树莓派因为底层的数据手册闭源，所以不存在内核空间，驱动模块和应用层的APP都需要在应用层运行，驱动模块中对硬件的操作也需要借助树莓派的专用库中的接口实现。

##### ad7606没有内部寄存器地址，如何SPI通信

SPI驱动框架中的SPI主机驱动最终会提供给SPI设备驱动一系列的访问设备的函数，但是因为ad7606没有寄存器地址，所以使用的是spi_read函数

#### 多个IMU级联部分

##### 级联使用的物理层和协议层是什么

物理层使用的是RS485，软件层使用的是Modbus协议

##### 如何调试stm32mp157开发板与IMU之间的串口通信

对于主控板通过串口发送的字节需要一种调试手段来查看是否发送正确，以及IMU接收到的控制指令也需要查看是否正确。通过Buildroot创建根文件系统时添加串口功能minicom，但是打印信息是乱码，这里额外使用一款STM32F103RCT6的开发板，搭载2.4寸的LCD屏幕，在这里实现一个串口信息打印到LCD屏幕上的功能，因为157开发板的USB作为主机实现usb转ttl所以连接电脑查看打印的串口信息，这里就是以迷你板作为从机，实现串口转ttl的功能。调试完成后，同样是用迷你板通过跳线直连IMU模块，在LCD屏幕上发送控制指令，观察返回数据是否格式正确。

这个问题将第一个项目和第二个项目联系起来了。

##### 串口的应用层开发需要注意什么

本项目中只需要编程应用层APP即可，在Linux中应用层对串口的开发实际上是针对所有的终端设备开发的框架。将ioctl函数的各种操作封装成一套标准的API。

##### 多IMU级联的调试流程

1. 通过远程控制终端检查一个IMU功能
2. 检查IMU级联功能
3. 在157上驱动CH340芯片，检查usb转ttl设备
4. echo输出指令
5. minicom输出指令
6. 编写应用APP调用write/read读写/dev/ttyUSB0设备节点

##### IMU的Modbus地址怎么设定

使用WT提供的上位机设定的每个IMU模块在Modbus中的地址。

##### 使用的USB转485是如何实现的

在Linux内核驱动中并没有usb直接转485的驱动，实际上是usb通过ch340转换成TTL信号，然后TTL信号通过IMU模块中的sp3485芯片转换成RS485信号。ch340芯片就隐藏在usb转485的数据线内。所以在Linux内核配置驱动中只需要使能USB转TTL的ch340芯片驱动即可。

##### 整体的软件体系是怎么样的

正常来讲IMU的通信同样应该分成驱动模块和应用层APP，驱动模块负责usb转ttl驱动，应用层进行读取设备节点并将原始值通过浮点数运算转化为真实值，但是usb转ttl已经集成到内核里了，直接在配置内核的时候使能该驱动即可。所以设备树和驱动模块不需要考虑。

### 项目自我介绍

1. 低温下太阳能发电系统研发
   - 这是我实验室的横向课题，研发一种在低温下利用太阳能对蓄电池进行充电或者直接给设备供电的系统。
   - 我主要负责的是对充电芯片、电量检测芯片、温度传感器、光敏传感器、0.96寸OLED等芯片的选型以及调试。
   - 因为工作需要考虑温度、光照强度、电池电量、电池充放电电压多种因素，引入状态机将各个工作状态以及迁移条件清晰化。
   - 为了实现多任务并发操作引入实时操作系统FreeRTOS。
   - 为了实现对系统的不断电调试，编写远程控制指令。实现记录当前温度、读取已记录的温度。
   - 考虑实际意义需要将当前系统作为下位机给多个上位机提供电池电量等多种参数。考虑到wifi功耗大、蓝牙信号差，采用zigbee广播实现一对多通信。
   - 上位机有树莓派，正点原子F1系列的迷你板作为远程控制终端。我负责其中的远程控制终端，移植LVGL在触摸屏上实现GUI界面。
2. 智能机器人
   
   这是我实验室的横向课题之一，目的是设计一款穿戴于人体下肢的外骨骼设备用于帮助老年人健步或者病人的康复训练。通过电极片贴附于人体表面获取肌电信号，传入肌电信号采集板中，由ADC类芯片将八通道的电信号转换成数字信号传入主控板。将多个姿态传感器级联挂在小腿大腿采集运动参数。在调试ad7606芯片的时候，发现亚德诺官网驱动有问题，让我仔细学习了下iio子系统。

# 自我介绍

我本科就读于沈阳工业大学，本科期间因为做比赛先后接触到数学建模和单片机，让我对算法和嵌入式有一定了解，考虑到底层开发比较稳定，保研的时候选择了嵌入式方向的实验室。本科毕设也是选择了偏向于控制的机器人毕设。读研期间先后参与了实验室的两个横向课题，低温太阳能的项目让我熟悉了stm32f1系列的芯片、了解了实时操作系统和GUI的本质是牺牲资源获得性能，让我对资源丰富的芯片产生了好奇，智能机器人项目让我接触到Linux领域，自学了计组、操作系统、Linux驱动与应用。编写驱动模块的时候让我对内核产生了好奇，自学了Linux内核设计与实现这本书。现在对芯片架构比较感兴趣。目前正在学ARM嵌入式系统开发这本书。以后有机会想看看Linux内核源码。





​      

   

   

