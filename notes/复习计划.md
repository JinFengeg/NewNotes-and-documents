

# 复习计划

俗话说得好，编筐编篓重在收口，2021/10/1-2022/12/20这将近一年半的学习提高了我的知识面，对技术有了概念并培养了自身的技术栈。C/C++/RTOS/Linux/驱动/应用/内核/LVGL/QT/数据结构/计组/操作系统等等，我想当年王震师兄应该也学不到这么多吧，人家可能只看过驱动部分，GUI没学过。这也让我有一定的底气去选择内核的工作，在接下来的复习阶段中，我不打算继续扩展知识面了，接下来要做的就是有选择的复习像LVGL/QT虽然学了一周但自己本身不打算找相关的工作，而且学的很浅。并且刷题，还需要制作简历，根据不同的岗位需要投递不同的简历。

严格来说，2023/2/1-2023/12/1这十个月都是需要学习的，这十个月也将是我给自身硕士生涯最后也是最重要的一个交代，需要打起比过去12个月更加认真的态度，接下来的十个月将不是以往细致扣每个知识点的时候了，而是将所学所用的知识技术对外输出，厚积薄发的时刻了。首先将2023/2/1-2023/3/31这两个月的工作安排下，这两个月需要复习、刷题、制作简历、投递简历。

## 复习

列举下接下来需要复习的知识点：

- [ ] C/C++(语言方面要以刷题为主，之前的笔记简单看下，主要是做 《**程序员面试笔试宝典第三版**》 )
- [ ] 数据结构（这个也是笔记简单看下，重点是做题leetcode上的题）
- [ ] 计算机组成原理/操作系统（这两个同样是笔记简单看下，重点是看下常见的问题微信公众号上有）
- [ ] FreeRTOS（这个不太重要，到时候拿出几天复习下完事）
- [ ] ARM体系结构（这个不需要看书，找常见问题就行，公众号上有）
- [ ] 低温下太阳能供电系统研发项目(整体的软件开发工作)
- [ ] Linux驱动（直接看笔记）Linux应用（直接看笔记）/Linux内核设计与实现这三个应该是面试的时候问的，而不是笔试，没看到常见问题。
- [ ] Makefile/CMake，这个属于上面的
- [ ] 教育机器人外骨骼的信息采集系统研发项目(Linux驱动的部分，深入了解IIO框架)
- [ ] GUI(LVGL/QT)

## 刷题

网上说是剑指offer和leetCode。主要就是数据结构复习完在牛客网和leetcode上刷题

## 制作简历

 [如何写一份合格的简历？（附简历模版） (qq.com)](https://mp.weixin.qq.com/s/DYHN79vKpMzNhyWigqTeig) 向着这个学习就可以

### 单片机开发

- C/C++
- 数据结构
- 计组/操作系统
- 低温下太阳能供电项目
- Cortex-M3体系结构
- FreeRTOS

### Linux驱动开发

- 包含单片机开发
- Linux驱动
- Linux内核
- 教育机器人项目

### Linux内核开发

- 不包含低温下太阳能供电项目

## 名企真题

正式笔试之前要多做真题。

## 投递简历

## 自我介绍

这里的自我介绍要分为一分钟和三分钟的

先系统的复习，然后再看常见问题。目前有了系统的CC++，CC++和ARM的常见问题答案，计组和操作系统的常见问题和答案。找的资源应该是差不多了，晚上的时候思考下刷题和复习步骤。

仔细看了下嵌入式软件开发笔试面试指南这个pdf，发现这是一个很综合的文件，基本上全包括了，主要是时间问题，我不知道如果我认真的系统复习是否来得及，还是说我先看这个总结好的，然后我再去细扣那些。而且还要刷题，我也许可以一边学然后在那里扩展下，一边刷题。就以这个pdf为核心向外扩展吧，这个pdf上数据结构有刷题的能有几十道，我到时候就是一边学这个一边刷leetCode上的题，明天开始先从制作简历开始学起。

## 目前要做的任务

1. 制作简历，已经有了一个雏形通过markdown-resume制作简历，用wps将个人头像p上去，简历方面要完成的任务：

   - 需要修改项目经历，多写几行，真实地把工作量复现出来。
   - 修改个人头像，可以考虑p上去西服
   - 修改专业技能，要考虑自己学习的水平和研究方向，但也要把花费的时间成本考虑到。
   - 修改荣誉奖项，顺序需要考虑下，是否添加日期。
   - 最后将简历发给公众号老哥，先问问是不是付费。

2. 复习方案

   目前有两种方案复习，直接刷题另一种是先简单全盘复习下，然后再刷题。再一个要考虑的是算法题怎么刷。计组、操作系统、数据结构、C++这些我感觉没必要看原来的笔记，因为后续的Linux驱动、应用、内核都涉及到了，所以直接刷题得了，至于驱动和内核部分应该先看看笔记，然后再刷题。总之这些肯定不是使用同一种方法的，应该多种方法一起使用来复习。还要考虑到上下晚三个时间段应该怎么分配任务，目前感觉是晚上十点半之后修改简历，上午拿来刷算法题，下午用来复习。先看看这个面试总结然后自己就知道怎么学了。

3. 企业信息

   - 华为-嵌入式软件开发工程师，部门未定，目前可以投递，但是截止日期不知道，是勇敢星实习生招聘计划。应该是暑期实习
   - 小米只有日常实习，并且没有Linux驱动这个方向的。
   - 大疆实习是智能驾驶-嵌入式这个方向可以，但是要求稳定实习六个月以上，实际上来不及了。

   总的来看感觉目前暑期实习还没有开始。

## 复习

目前先按照嵌入式软件开发笔试面试教程开始复习。目前打算是上午看数据结构刷题，下午学C/C++，晚上看ARM体系架构。

### 一、C/C++

#### 关键词

##### C语言宏中#和##的用法

=表示的是将右值赋值给左值，这里是值传递，与地址无关

而==表示的是逻辑判定，判断左右两值是否相等，如果相等则a==b这个公式的值为1否则为0

---

这里的#和##我在Linux内核源码中见到过。我记得##表示的是拼接，而#表示的是记不住了。

#字符串化操作符

将宏定义中的传入参数名转换成  用一对双引号   括起来参数名   字符串。其只能用于有传入参数的宏定义中，并且#这个符号必须置于宏定义体中的参数名前。

其实很简单，就是#符号只适用于带有传入参数的宏定义中，将我们传入的参数由a变成"a"。而#要放在传入参数前。传入参数本身与#是没有关系的。字符串化操作符所传入的形参是否有值无所谓，因为在这里会将这个形参字符串化。

```c
#define example(instr)  printf("the input string is %:\t%s\n",#instr)//此时这个instr就是传入参数了，这个传入参数在宏定义中要在前面加上#，然后在宏里面要体现出来
#define example1(instr) #instr//这个例子就更简单了
//接下来看看实例
example(abc) == printf("the input string is %:\t%s\n","abc")
example1(abc) == "abc"//其实就是将#instr变成了"instr"而这里的instr是传入参数，传入的是abc，那就变成了"abc"，这就是字符串化操作符，如果没有#那就是单纯的传入参数了。
```

##符号连接操作符

作用：将宏定义的多个形参转化成一个实际参数名。实际上就是将多个变量拼接成一个变量。我记得是在内核还是驱动模块中见过的，为啥使用记不住了。在uboot的接收命令函数中应用。

```c
#define exampleNum(n) num##n
int num9 = 9;
int num = exampleNum(9)；//本来exampleNum(9) == num##9,但是这里是符号连接操作符，所以num##9变成了num9，所以最终就是num = num9 = 9
```

注意：

1. 当用##连接形参时，##前后的空格可有可无。
2. 连接后的实际参数名，必须为实际存在的参数名或者编译器已知的宏定义。确实，毕竟连接出来的参数名如果未被定义那岂不是出问题了。
3. 如果##后的参数本身也是宏的话，**##会阻止这个宏的展开**。不太明白这个宏展开与否有啥区别？

看一个实例

```c
#include <stdio.h>
#include <string.h>
#define STRCPY(a,b)  strcpy(a ## _p,#b)//这里就是a与_p进行连接，然后对b字符串化
int main()
{
    char var1_p[20];
    char var2_p[30];
    strcpy(var1_p,"aaaa");//这是将var1_p赋值成字符串aaaa
    strcpy(var2_p,"bbbb");
    STRCPY(var1,var2);//这里是先将var1##_p编程var1_p然后赋值成"var2"这里的var2是一个传入参数b的值，所以会变成"var2"
    STRCPY(var2,var1);//var2_p = "var1"
    //STRCPY(STRCPY(var1,var2),var1);
    //将此宏展开后会变成strcpy(STRCPY(var1,var2)_p,"var1")，因为此时STRCPY(var1,var2)_p这是一个宏_p，而##连接后如果是一个宏的话是不允许展开的，所以到此结束。我其实挺好奇的这个宏_p中的宏是独立的。宏本身就是其的定义。所以这里的宏即使有后缀了依旧是原来的宏，只不过这是因为##连接起来的所以宏不会展开。
}
```

至于说为什么宏不会展开，这是语法问题。

##### 关键字volatile有什么含义？并举出三个不同的例子

这个算是我比较常见但不常用的关键字了，将变量设置为动态变量，之前搜索过我记得是这个变量随时会改变。但是没弄明白。

1. 并行设备的硬件寄存器。存储器映射的硬件寄存器通常加volatile，因为寄存器随时可以被外设硬件修改。当声明指向设备寄存器的指针时一定要用volatile，他会告诉编译器不要对存储在这个地方的数据进行假设。这里用自己话翻一下就是，对于同时会被多次访问的硬件寄存器，需要将指向其的指针加上volatile。也就是对其地址进行动态化，因为寄存器所指向的内容随时会被改变，需要告诉编译器不要对该数据进行假设。**在卸载驱动的时候需要释放映射的虚拟地址空间，这里就对我们需要卸载的地址加上volatile修饰了**。内存就是一个并行设备？反正就是多线程访问同一个变量，只不过这里的变量是寄存器地址
2. 一个中断服务程序中修改的供其他程序检测的变量。volatile提醒编译器，他后面所定义的变量随时都有可能改变。因此编译后的程序每次需要存储或读取这个变量时，**都会直接从变量地址中读取数据**。（就是这里，我之前看到的就是这里）如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。编译器默认优化的问题。这里的中断服务程序与其他线程共享变量了，内核中讲过中断不算线程因为不是由CFS完全平均分配调度器调动的。但是在这里也可以看成多线程共同访问同一个变量。
3. 多线程应用中被几个任务共享的变量。和上面没啥区别。其实就是防止编译器对代码进行优化。举个例子

```C
XBYTE[2] = 0X55;
XBYTE[2] = 0X56;
```

对于外部硬件而言，上述四条语句分别代表不同的操作，但是编译器会对上述四条语句进行优化，认为只有XBYTE[2]=0X56，**忽略上一条**，只产生一条机器代码。但是如果添加volatile的话就会**逐一的进行编译**并产生相应的机器代码。

---

从汇编的角度来看的话，volatile会让编译器在编译时采用LDR/STR等直接从主存中读取数据的做法，毕竟硬件寄存器是存储器映射实现的，寄存器在主存上，不可以从cache或者r0等寄存器直接读取。

- 确保读写顺序
- 强制从内存读取
- 禁止寄存器和cache读取数据，这个是对存储单元的cache权限，在页表项上设置的。

---

##### 关键字static的作用是什么？

我理解的是将变量变为全局静态变量。这样的话，其他文件中是不可以引用这个变量的。并且在本文件中到处都可以引用，而不会认为是一个局部变量。

1. 在函数体内，**只会被初始化一次**，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。这里的意思是不是说即使函数同时被调用多次，但是这个静态变量依旧只初始化一次。
2. 在模块内但是在函数体外（这里指的就是在文件中定义，而不是在函数内部定义的局部变量），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其他函数访问。也就是说这是一个本地的全局变量（只能被当前文件使用，即使添加extern外部声明也不好使）。
3. 在模块内，一个被声明为静态的函数只可被这一模块内的其他函数调用。这个函数被限制在声明它的模块的本地范围内使用也就是只能在当前文件使用，和静态变量一样。

##### 在C语言中，为什么static变量只初始化一次？

这也是我之前想问的。是不是多线程调用函数中，函数体内的static变量只初始化一次。

对于所有的对象，初始化都只有一次，而由于静态变量具有记忆功能，初始化后，一直没有被销毁，**都会保存在内存区域中**，所以不会再次初始化。存放在静态区的变量的生命周期一般比较长，所以只需初始化一次，而自动变量也就是局部变量，**由于存放在栈区**，一旦函数调用结束，就会立刻被销毁。我听明白了，多线程调用函数的话，即使一个线程调用结束了，静态变量依旧不会被销毁，所以只需要初始化一次。所谓的保存在内存区域中，其实指的是保存在堆区吧，，也不太对，静态变量是在整个程序执行完就会被销毁。也不需要手动释放，，，反正在内存区域中，而不在内存区域里的栈区中。

 <img src="https://img-blog.csdnimg.cn/20200315003251844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZ2VsRGc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:25%;" /> 这张图说的很明确了，静态变量既不在堆上，也不做栈上，而是在数据段上。即使是函数体内的静态变量依旧与函数体外的静态变量没区别，都是在数据段上的。全局数据也是在这里。

---

内存映射段指的是mmap分配的内存段，其他内存段是内核初始化分配的，匿名映射就是没有关联到文件页的映射，比如进程栈，文件映射就是将文件页映射到该内存段上，实际上就是虚实映射。

---

##### extern"C"的作用是什么？

要注意，这里并不是单独使用extern，后面还加上了"C"。主要作用就是为了**能够正确实现C++代码调用其他C语言代码**。当加上extern"C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++。

##### const有什么作用？

1. 定义变量（局部变量或者全局变量）为常量，例如：

   ```c
   const int N = 100;
   N=50;//错误
   const int n;//错误，常量必须在定义的时候初始化
   ```

2. 修饰函数的参数，表示在函数体内不能修改这个参数的值。void function(const int i)

3. 修饰函数的返回值。

   - 如果用const修饰返回值的类型为指针，那么函数返回值的内容是不能被修改的。此时的指针是一个常量指针，指针所指向的内容是一个常量。

     ```c
     const char GetString()//定义一个函数
         char *str = GetString()//错误，此时返回值不能赋值给普通指针
         const char *str = GetString()//正确，此时等式左侧是一个常量指针
         //char *const str这就是一个常指针了，此时指针赋值的地址不可改变。
         //char const *str这依旧是一个常量指针，str可变，而内容不可变
     ```

   - 如果用const修饰普通的返回值，比如int类型的变量，由于这个返回值是一个临时变量，函数调用结束后，这个临时变量的生命周期也就结束了，因此把这些返回值修饰为const是没有意义的。顺便提一句，这种情况下只能进行值传递，因为传递结束之后地址就会被释放了。

4. 节省空间，**避免不必要的内存分配**。这里需要将const与define进行比较，const定义的常量存储在数据段，只有一份copy。而define进行宏替换在代码区中有若干份copy。发生在C语言的预处理阶段，会进行宏替换，每个宏都需要占用一份内存。（很好理解，这会导致代码段内存占用过大）

   ```c
   #define PI 3.14159
   const double Pi = 3.14159//此时定义了一个常量，但此时并没有分配内存
       double i = Pi//此时为Pi分配内存，以后不再分配，const只有这一份内存
       double I = PI//编译期间进行宏替换，分配内存
       double j = Pi//没有内存分配，所以const节省空间。
   ```


##### 什么情况下使用const关键字？

1. 修饰一般常量。修饰符const可以在类型说明前，也可以在类型说明后

2. 修饰常数组，定义或说明一个常数组可以采用如下格式

3. 修饰常对象，常对象指的是对象常量。C++中提到过，常指针就是指针常量，指针指向不可修改，对象不可修改，因此常对象中只能使用常函数，而常函数只能操控非静态成员，因为静态成员并不在对象内存上，对象内存上是常量。this指针就是一个指针常量，因为this只能指向他的对象，地址不可修改，所以是指针常量

   ```c++
   class A；
   const A a；//实例化对象A，a为常对象
   A const a；
   ```

   定义常对象时，同样要进行初始化，并且该对象不能被更新，修饰符const可以放在类名后面，也可以放在类名前面。

4. 修饰常指针

   ```c++
   const int *p;//常量指针，指针地址可变，内容是常量
   int const *p;
   int *const p;//常指针/指针常量，指针地址不可变，内容是int类型
   const int*const p;//指向常量的指针常量，都不可变
   ```

5. 修饰常引用

   被const修饰的引用变量为常引用，一旦被初始化，就不能再指向其他对象了。

   ```c++
   int &b = a;//取别名，就是将a的地址赋值给b的地址，此时ab地址相同了，之前一直不知道应该如何理解，其实取别名等价于指针
   int *const b = &a;//首先定义了一个指针常量b，然后将a的地址赋值给b，因为此时b是一个指针常量所以b永远只能是&a，这就是取别名。将地址赋值给指针常量。只不过引用自己会*一次。*b = a
   const int &b = a;//这就是常引用了，相当于const int *const b = &a，此时b是一个指向常量的指针常量。所以常引用的地址和内容都不可变
   ```

6. 修饰函数的常参数。

7. 修饰函数的返回值。

8. 在另一个连接文件中引用const常量。

9. ```c++
   extern const int j = 10;
   ```

##### new/delete与malloc/free的区别是什么？

这个问题之前我也想知道，，

1. new/delete是C++中的**操作符**，而malloc和free是标准库函数。也就是说malloc和free本质是系统调用，由内核实现的，而new/delete是由编译器实现的。new a就可以，但是malloc(sizeof(a))，函数**后边要加小括号**
2. 对于非内部数据对象来说，只使用malloc是无法完成动态对象要求的。因为在创建对象时(也就是分配对象内存实例化的时候)需要调用构造函数，对象消亡时(也就是释放对象内存时)自动地调用析构函数。而malloc/free是库函数，并不在编译器的控制范围内，这两个函数不能自动调用构造和析构函数。而NEW在为对象分配内存空间时，可以**自动调用构造函数**，所以可以在分配内存的时候自动初始化对象。同理，delete也是一样。相比之下malloc只是做了一件事，为变量分配了内存。
3. new返回的是**指定类型的指针**，并且可以自动计算所申请内存的大小。而malloc需要我们计算申请内存的大小，并且在返回时**强行转换为实际类型的指针**。(BiTree)malloc就是这样，而new不需要强制转换。

new是编译器专门用来分配内存的，而malloc只是系统调用而已。

##### strlen("\0")=?sizeof("\0")=?

0,2

我之前学过，前者是字符串长度，后者是占用的字节数 。

strlen用来计算字符串的长度，而在c/c++中，字符串是以"\0"作为结束符的，**从内存的某个位置开始扫描直到碰到第一个字符串结束符\0为止**。

返回计数值sizeof是c语言的关键字，以**字节的形式给出其操作数的存储大小**，操作数可以是一个表达式或括在括号内的类型名，操作数的存储大小由操作数的类型决定。也可以是数组名，会得到数组的字节长度。

##### sizeof和strlen有什么区别？

strlen与sizeof的差别表现在以下五个方面。

1. sizeof既是关键字，也是运算符，但不是函数。而strlen是函数，sizeof后边如果是类型必须加上括号比如：sizeof(int)，如果是变量名，则可以不加括弧。比如：sizeof a
2. sizeof运算符的结果类型是size_t，他在头文件中typedef为unsigned int类型。
3. sizeof可以用类型作为参数，而strlen只能用**char*作为参数**，而且必须以\0结尾。sizeof还可以以函数作为参数，比如int g()，则sizeof(g())的值实际上就是函数返回值的int类型，在32位计算机下，int占4个字节，所以是4
4. 字符串长度指的是字符个数，而内存大小指的是字节数，英文字符等于一个字节，中文字符等于两个字节。大部分编译程序的sizeof都是在编译的时候计算的，所以可以通过sizeof(x)来定义数组维数。这里的数组维数指的是数组的指定大小，而不是实际大小。比如char str[20] = "0123"，此时的数组维数是20，所以在32位 机器下，sizeof(char) *20 = 20，**而且sizeof是运算符由编译器在编译的时候就计算了**，而strlen是函数，本质是系统调用，所以是在**运行期**确定的大小，所以字符串长度是实际长度10.makefile中的自动化变量$<不可以出现在宏定义中，因为宏是在编译期间就确定了，而自动化变量是在运行期间确定的。
5. 当数组作为参数传给函数时，传递的是指针，而不是数组，即传递的是数组的首地址。这里得到的是数组长度。

##### 不使用sizeof，如何求int占用的字节数？

指针做偏移操作的时候是根据指针的类型做出移位判断的，char类型的指针每次加1都是移动一个字节的长度。int类型的指针每次移位需要地址加4。

```c++
(char *)(&Value);//这里的Value是宏定义中的传入参数，类型未知，这里是将指向未知类型的指针强制转换为字符串指针。具体过程是先找到Value的内容，然后将内容转换成字符串类型，再返回该字符串类型的地址。所以这里返回的是Value的地址的第一个字节，比如int是四个字节类型，转换以后变成了四个字符组成的字符串，此时返回的就是第一个字符的地址。
(char*)(&Value +1);//这里就有意思了。&Value本身表示该类型的地址，此时+1！注意，这里表示的不是0x01+1 = 0x10这么简单，增加的并不是1而是一个Value类型的字节。如果此时以int为例，那么增加的就是四个字节的大小，所以地址上增加的就是+4，然后再强制转换成字符串指针，所以此时返回的是Value地址的下一个地址的第一个字符串，
xxxx xxxx此时就是(char*)(&Value +1)-(char*)(&Value)
```

重点就是字符串地址就是其首字符的地址，而&a+1表示的是当前变量地址**增加一个该类型**后的地址，两者相减就是该类型所占用的字节数了。

```c++
#include <stdio.h>
#define MySizeof(Value) (char*)(&Value +1) - (char*)(&Value)
int main()
{
    int i;
    double f;
    double *q;
    printf("%d\r\n",MySizeof(i));
    printf("%d\r\n",MySizeof(f));
    printf("%d\r\n",MySizeof(a));
    printf("%d\r\n",MySizeof(q));
	return 0;
}
```

##### printf和scanf实现

scanf底层实现多了一个参数就是数据流stream，单片机进行重定向就是修改到串口，读取getc数据流。针对传入的不同的%类型case不同的接收方式。

printf底层实现

1. 解析format字符串
2. 处理可变参数
3. 格式化输出
4. 返回输出字节数



##### C语言中struct和union的区别是什么？

union在内核源码中出现过，联合体，但没有用过。struct是结构体，结构体成员是连续分布的，所以结构体中不能出现函数，可以出现函数指针。

struct与union是C语言中两种不同的数据结构，两者都是常见的复合结构，其区别主要表现在以下两个方面。

1. 结构体与联合体虽然都是由多个不同的数据类型成员组成的，但不同之处在于**联合体中所有成员共用一块地址空间**，也就是说，联合体只存放了一个被选中的成员，而结构体中所有成员占用空间是累加的，所有成员都存在，不同成员存放在不同的地址。在**计算一个结构型变量的总长度时，其内存大小等于所有成员长度之和**，因为他是连续的地址上，所以还要考虑字节对齐的问题。而在联合体中，所有的成员不能同时占用内存空间，他们不能同时存在，所以**一个联合型变量的长度等于其最长的成员的长度。**
2. **对于联合体的不同成员赋值，将会对其他成员重写**，原来成员的值就被覆盖了，而对结构体的不同成员赋值是互不影响的。实际上对于不同类型的成员是覆盖一部分

在内核中出现联合体应该也是希望其成员同一时间只有一个存在吧。

举个例子：

```c
typedef union{double i;int k[5];char c;}DATE;
typedef struct data{int cat;DATE cow;double dog;}too;
DATE max;
printf("%d",sizeof(too)+sizeof(max));
```

首先是联合体占用的空间，double8字节，int数组20字节，char一个字节，但是联合体里面最大的变量类型是20字节，所以union占用20字节。但是还要考虑字节对齐，而联合体中最大的不可再分的类型是double而不是int[5]所以需要8字节对齐，至少20字节，所以就是24字节。（还要考虑字节对齐的问题）

结构体中int4字节，DATE24字节，double8字节，一共36字节，但是还要考虑结构体内部的字节对齐，这里的double是最大成员的类型，所以也是八字节对齐。应该是8的倍数，而至少36字节，所以说40字节，这里的union的最大成员类型也是8字节。

**当结构体中包含结构体或者联合体的时候，因为其内部已经字节对齐了，所以将其看成是各自结构体内部最大成员类型。**

 字节对齐：一些平台对某些特定类型的数据只能从某些特定地址开始存取 。不然会导致存取效率上的降低。

所以最终sizeof(union) + sizeof(max) = 24+40= 64

##### 左值和右值是什么？

左值是指可以出现在等式左边的变量或表达式，**他最重要的特点就是可写**（可寻址，这里应该是说可以根据其地址修改其内容）。也就是说，他的值可以被修改，如果一个变量或表达式的值不能被修改，就不能作为左值。

右值是指只可以出现在等式右边的变量或表达式，**最重要的特点是可读**。一般的使用场景都是把右值赋值给一个左值。

左值可以作为右值，右值不一定是左值。

##### 什么是短路求值？

```c
#include <stdio.h>
int main()
{
    int i = 6;
    int j = 1;
    if(i>0||(j++)>0);//这里因为i>0已经成立了，所以后边的条件不会执行就是这里直接短路求值了
    printf("%D\r\n",j);//j == 1
    return 0;
}
```

同样的道理，对于&&操作，由于在两个表达式的返回值中，**如果有一个为假则整个表达式的值，都为假，所以不用执行后一个语句了**。

##### ++a和a++有什么区别？两者是如何实现的？

这个好，我总是记混，就记得一个是执行完再加一，一个反过来

a++的具体运算过程为

```c
int temp = a;//将原来变量的值复制到临时的存储空间
a=a+1;
return temp;//所以参与运算的结果还是a，最后是a+1
```

++a的具体运算过程为：

```c
a=a+1;
return a;
```

后置自增运算符需要**把原来变量的值复制到一个临时的存储空间**，等运算结束后才会返回这个临时变量的值。所以前置自增运算符效率比后置自增要高。

```c
int a = 1;
(a++) + 1 = 2;
a = 2
```

#### 内存

##### C语言中内存分配的方式有几种？

这个问题问的也非常好，我对内存一直就是充满疑惑的

1. 静态存储区分配

   内存分配在程序**编译之前完成**，且在程序的整个运行期间都存在，比如全局变量、静态变量，这个是存放在数据段的。代码段等等这些都是编译前就使用结构体确定了。

2. 栈上分配

   在函数执行时，函数内的局部变量的存储单元在栈上创建，函数执行结束时，这些存储单元自动释放。

3. 堆上分配

   也称为动态内存分配，在程序运行期间，使用malloc或new申请任意数量的内存单元。之前讲过malloc只是一个系统调用，所以只做了分配内存这一件事。new是操作符，编译器会自动执行构造函数的。

##### 堆和栈有什么区别？

1. 申请方式

   栈的空间由操作系统自动分配/释放，堆上的空间手动分配/释放。

2. 申请大小的限制

   栈空间有限。**栈是向低地址扩展的数据结构**，是一块**连续的内存的区域**。向下增长，**栈顶的地址和栈的最大容量是系统预先规定好的**，如果申请的空间超过栈的剩余空间就会提示溢出。因此**从栈获得的空间较小**。

   堆是很大的自由存储区。**堆是向高地址扩展的数据结构**，**是不连续的内存区域**。这是由于**系统用链表存储的空闲内存地址**，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小**受限于计算机系统中有效的虚拟内存**。所以堆获得的空间比较灵活，也比较大。内核经常分配和释放空闲链表，用链表来管理数据结构块。

3. 申请效率

   栈由系统自动分配，速度快，但是程序员是无法控制的。

   堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。

##### 栈在C语言中有什么作用？

1. C语言中栈用来存储临时变量，临时变量包括**函数参数和函数内部定义的临时变量**。函数调用中与函数调用相关的**函数返回地址**，函数调用的参数就是通过r0-r3寄存器传递的，如果超过4个参数了，就会使用压栈，使用栈来进行传递。函数中的临时变量，寄存器等均保存在栈中，函数调动返回后从栈中恢复寄存器和临时变量等**函数运行场景**。也就是说保存现场实际上就是把寄存器和临时变量的数值保存在栈中。这就是为什么IRQ要比FIQ慢的原因。FIQ有着自己专属的寄存器。系统自动会保存寄存器的数值和恢复寄存器。而IRQ没有那么多的寄存器，只能手动保存到栈上面，再手动恢复。

2. 多线程变成的基础是栈，**栈是多线程编程的基石，**每个线程都最少有一个自己的专属栈。这就是线程栈了，本来中断服务程序还会占用被打断的线程栈的，然后再恢复。后来专门给中断配备了内核栈。

   用来存储本线程运行时各个函数的临时变量

   和维系函数调用和函数返回时的函数调用关系

   和函数运行场景。

   操作系统最基本的功能是支持多线程编程，支持中断和异常处理，每个线程都有专属的栈，中断和异常处理也具有专属的栈，栈是操作系统多线程管理的基石。
   
   ---
   
   栈分为进程栈、线程栈、内核栈、中断栈，每种处理器模式都有对应的栈。进程的内核栈是进程在内核态下运行的体现，线程栈是多线程的基础，中断栈是中断处理程序运行的基础。
   
   ---

##### C语言函数参数压栈顺序是怎样的？

这个真不知道，之前都没合计过函数参数是通过压栈存储的。

C/C++语言的参数入栈顺序是从右到左，这里以printf为例

```c
printf("%d,%d,%d",a,b,c);//此时编译器是通过读取最左侧的字符串哪种的%个数来确定可变长参数的个数的，在出栈的时候应该是先读取字符串，再读取abc。所以应该从右边开始存入，最后存入字符串。反过来的话，无法获知参数个数了。
```

由于栈顶是系统事先确定的，也就是说高地址已经确定了，而栈是向下增长的，所以从右到左的压栈顺序，导致了**最右边的地址最高**，最左侧的地址最低。栈顶确定了，先放入的后拿出是在高地址。低地址先拿出

因此C语言函数参数采用自右向左的入栈顺序，主要原因是为了支持可变长参数形式。

##### C++如何处理返回值？

C++函数返回可以按值返回和按常量引用返回，（常量引用就是之前学的常引用，作为常量的别名，也就是地址和内容都不可以改变，复习下，int *const a = &b 等价于 int &a = b，本身引用就是一个指针常量，常引用或者说是常量引用就是const int *const a等价于常指针）。偶尔也可以按引址返回。这里是因为函数返回值是存储在栈上面的，随着函数执行完毕就会释放内存了，所以不要使用引址返回。其实也不要使用常量引用返回，就是用值返回是最好的。

##### C++中拷贝赋值函数的形参是否进行值传递？

这里的拷贝赋值函数指的应该是赋值运算符函数

```c++
Person & operator=(const Person &)//正常来说的话，形参是一个常量引用，此时把实参赋值给形参就是对实参进行一次常引用，并不会引起拷贝构造函数。const Person &p =  p1
    //但是，如果此时形参变成了const Person，const Person p=p1，这是值传递的方式给函数传参，正是拷贝构造函数的调用时机。
{
    return *this;
}
```

---

复习下拷贝构造函数的调用时机

1. 使用一个创建完毕的对象**初始化**一个新对象，Person p = p1
2. 以**值传递**的方式给函数传参func(p1)此时形参为Person p = p1
3. 以**值的方式返回**局部对象，return p1，此时Person p = func等价于Person p = p1

---

可以，但是调用拷贝赋值函数的时候，会将实参传递给形参，这会导致一次拷贝构造，但是并不会**无限传递**。

##### C++的内存管理是怎么样的？

在C++中，虚拟内存分为**代码段、数据段、BSS段、堆区、栈区、文件映射区**六部分。

代码段：包括只读存储区和文本区，其中只读存储区存储字符串常量，，文本区存储程序的机器代码。

数据段：存储程序中已初始化的静态变量和全局变量

BSS段：存储**未初始化**的静态变量和全局变量以及被**初始化为0**的全局变量和静态变量

---

零页：特殊的页面，内容全为零，常用于作为文件的映射起始地址，初始化文件为0

---

堆区：由程序员手动分配和手动释放，由链表管理堆区，堆是分散的大量的内存。容易造成**内存碎片**。调用new/malloc函数在堆区动态分配内存。

栈区：存放函数参数、函数返回地址、返回值、局部变量，以及保存上下文的寄存器等。

文件映射区：存储动态链接库(CMake可以生成动态链接库文件，是在程序运行期间链接相应的库)以及调用 mmap函数进行的文件映射。

##### 什么是内存泄漏？

简单的说就是**申请了一块内存空间，使用完毕后没有释放掉**。

他的一般表现方式是程序运行时间越长，占用内存越多，最终用尽全部内存，整个系统崩溃。。有程序申请的一块内存，且没有任何一个指针指向它，那么这块内存就泄漏了。有自己的话说就是这个内存丢失了，没有能找到他的办法了。

##### 如何防止内存泄漏？

1. 良好的编码习惯，**使用了内存分配的函数**，一旦使用完毕，**要记得使用相应的函数释放掉**。
2. 将**分配的内存的指针以链表的形式自行管理**，使用完毕之后从链表中删除。程序结束时可检查链表。内核其实就是这么做的，将空闲内存用链表来管理，内核负责管理空闲链表。链表使用完也不会释放而是回到空闲链表池当中。这么做就是为了有效的管理内存。
3. Boost中的smart pointer**智能指针**，但是我没学过来了，分为shared_ptr指针、weak_ptr指针、uniqued_ptr指针 。循环引用问题就是弱指针解决的
4. 一些常见的**工具插件**，比如ccmalloc
5. 在内核中分配内存更为小心，为此使用slab分配器，用各个高速缓存来分配各个对象，管理空闲链表。

#### 指针

##### 数组指针和指针数组有什么区别？

数组指针本质上是一个指针，指向数组，而指针数组本质上是一个数组，里面的元素是指针。

##### 函数指针和指针函数有什么区别？

函数指针本质上是一个指针，指向函数类型。而指针函数本质上是一个函数，返回值是一个指针。

回调函数其实就是将函数作为另一个函数的参数，就是借助函数指针实现的。

1. 函数指针

   如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为函数的地址，函数名表示的就是这个地址。定义一个指针变量来存放，这个指针变量就叫做函数指针变量。简称函数指针。

   ```c
   int (*p)(int ,int)//先看优先级，这里最高优先级是左侧的括号，内部是一个指针，所以这是一个指针，指向返回值是int，参数是int，int类型的函数
   ```

   需要注意的是，**指向函数调动指针变量没有++和--运算。**因为函数类型未知

   ----

   复习下，之前学到的(&a+1)就类似于p++，此时增加的并不是1而是一个a类型所占的字节大小。而这里就意味着，不能增加一个该函数大小。
   
2. 指针函数

   首先这是一个函数，只不过这个函数的返回值是一个地址值。函数返回值必须用同类型的指针变量来接受。

   ```c
   int *pfun(int,int)//这里因为*的优先级低于()所以，pfun是一个函数，这依旧是一个指针函数，按理说括号内部是两个参数的声明，而不是只有类型
   ```

##### 数组名和指针的区别与联系是什么？

1. 数据保存方面

   不同类型的指针的内存偏移量是由其内容类型决定的，而指针的地址的内存偏移量统一是8个字节。

   ```c
   printf("%d", num);
   	printf("%d", &num);//两者没区别，但是sizeof的话前者为整个数组字节数，后者为首个元素的字节数
   ```

   指针保存的是地址，（保存目标数据地址，自身地址由编译器分配的），内存访问偏移量为四个字节（对于32位机而言），无论其中保存的是何种数据都以地址类型（对于32位机就是int类型）进行解析。

   数组保存的数据。数组名表示的是第一个元素的地址，内存偏移量是保存数据类型的内存偏移量；**只有对数组名取地址（&数组名）时**，才能表示整个数组，**内存偏移量是整个数组的大小。**（sizeof）数组名。如果是&指针，其实就是上面说的32位机就是int类型四个字节的偏移量。

   当sizeof(指针)得到的是地址占用的字节数，sizeof(数组名)得到的是整个数组占用的字节数。正是如此可以借此获得数组元素个数

2. 数据访问方面

   指针对数据的访问方式是间接访问，需要用到解引用符号（*数组名）。

   数组对数据的访问则是直接访问，可通过下表访问

3. 使用环境

   指针多用于动态数据结构和动态内存开辟。比如链表和new返回指针

   数组多用于存储固定个数且类型统一的数据结构和隐式分配。


##### 指针进行强制类型转换后与地址进行加法运算，结果是什么？

其实就是之前不使用sizeo获取变量大小的方法，(char *)(&a +1) -(char *)(&a)

   如果不对地址进行强制转换的话&a+1-&a = 1，这里指的应该是一个类型a的大小，这里强制将地址转换成字符串指针，那么相应的本来是一个int类型，就变成了四个char类型，而char本身占据一个字节，所以通过这种方式观察到了类型的大小。四个字节。

```c
struct BBB
{
    long num;
    char *name;
    short int data;
    char ha;
    short ba[5];
} *p;//结构体大小是至少21字节，需要是四个字节的倍数，所以四字节对齐之后是24字节
这里其实相当于定义了一个指向结构体的指针p
```

**当p = 0x100000;则p+0x200 = ?(ulong)p +  0x200 =?(char *)p+0x200 = ?**

这道题其实非常好，首先知道p的类型占用24字节。

p + 0x200这是指针加法，此时的0x200指的是需要在p后面追加的类型个数，所以是

p +0x200 * 24。而(ulong)p+0x200这里是将指针p强制转换为ulong类型的变量，不再是指针，自然不是指针加法，这里是0x100000 + 0x200。

(char *)p + 0x200，此时仍然是指针加法，将本来指向24字节类型强制转换成char类型的指针。所以此时是0x100000 + 0x200 * sizeof(char)

---

这里提一下之前求类型大小的方式

(char*)(&a+1)-(char *)(&a)，其实这里应用的是指针加法和指针减法。首先是&a+1这里应用了指针加法，所以是&a +1 * sizeof(int)，然后又应用了指针减法。

&a+1 * sizeof(int) - &a *sizeof(char) = sizeof(int)

---

很感谢这一章，让我彻底弄清楚了指针加法和数值加法的应用。

##### 指针常量，常量指针，指向常量的常量指针有什么区别？

###### 1.指针常量

```c
int *const p
```

这个指针本身是一个常量，指向int类型。**不能修改这个指针的指向**，**但是指针所指向的地址上存储的值可以修改**

###### 2.常量指针

```c
const int *p
int const *p
```

这是一个指向常量的指针，**不能通过指针来修改这个指针指向的值。**

###### 3.指向常量的常量指针

```c
const int *const p
```

**既不可以修改指针的值，也不可以修改指针指向的值。**

##### 指针和引用的异同是什么？如何相互转化？

```c
int *const b = &a;//指针常量b指向int类型，地址是&a
int &b = a;//b是a的别名，b是a的引用，b与a相同地址，存放的内容是int类型
```

###### 相同

1. **都是地址的概念**，指针指向某一内存，他的内容是所指内存的地址；引用则是某块内存的别名。
2. 从内存分配上看：**两者都占内存**，程序为指针会分配内存，一般是四个字节；而引用的本质是指针常量，指向对象不能变，但指向对象的值是可以变的。

为什么引用可以称为一段内存的别名呢，汇编层面上可以看到引用是由指针常量实现的，所以引用确实是一段内存的别名是由一个指针实现的，所以引用还是占内存的。

###### 区别

1. 指针是实体，而引用是别名。
2. 指针和引用的自增运算符意义不同，指针是**对内存地址的自**增需要考虑所指向内容的类型，而**引用是对值的自增**。
3. 引用使用时无须解引用(*)，指针需要解引用。(这里我理解啊，因为引用本质是指针常量，所以编译器将p = *p，这样引用就不需要解引用了，并且也解释了为什么引用需要占用内存)
4. 引用只能在定义时被初始化一次，之后不可变，指针可变。
5. 引用不能为空，指针可以为空。
6. sizeof 引用，得到的是所指向的变量的大小，其实就是类型的大小，而sizeof 指针，得到的是指针本身的大小，在32位系统中占用四个字节内存。

其实引用与指针之间的关系，用一句话说明就是引用的本质是指针常量，编译器自动让p = *p所以引用不需要解引用就可以得到值，而指针需要解引用。

###### 转换

1. 指针转引用：把指针用解引用符号就可以转换成对象，可以用在引用参数当中。
2. 引用转指针：把引用类型的对象用&取地址就获得指针了。

```c
int a = 5;
int *p = &a;
void fun(int &x){}//可以传入实参int &x = *p ==*&a == a
```

##### 野指针是什么？

1. 野指针是指向不可用内存的指针，当指针被创建的时候，指针不可能自动指向NULL，**默认值是随机的**，此时的指针称为野指针。顺便复习下，内存泄漏指的是原本手动创建动态内存之后，丢失了指向该内存的指针，导致无法访问该内存了，时间一长这样的内存越来越多最后程序崩溃。申请了，没有释放的内存。
2. **当指针被free或者delete释放掉时**（此时地址没有了），如果没有把指针设置为NULL，则会产生野指针，因为释放掉的仅仅是指针指向的内存，并没有把指针本身释放掉。
3. 第三个造成野指针的原因是**指针操作超越了变量的作用范围**。

##### 如何避免野指针？

1. 对指针进行初始化。

   ```c
   char *p = NULL;//指向NULL
   char *p = (char *)malloc(sizeof(char));//动态分配内存地址
   char *p = num;//用已有合法的可访问的内存地址对指针初始化
   ```

2. 指针用完后释放内存，将指针赋值NULL

   ```c
   delete(p);
   p = NULL;
   ```

   注：malloc函数分配完内存后需注意：

   检查是否分配成功。用if判断返回值

   清空内存中的数据。malloc分配的空间里可能存在垃圾值，用memset或bzero函数清空内存。

   ```c
   void bzero(void *s,int n)
   void memset(void *start,int value,int size);
   ```

##### C++中的智能指针是什么？

**智能指针是一个类，用来存储指针的**（指向动态分配对象的指针）。

因为C++程序设计中使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理。程序员自己管理内存虽然可以提高程序的效率，但是整体来说，堆内存的管理是麻烦的，C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针容易造成内存泄漏(忘记释放)，二次释放，程序发生异常时内存泄漏等问题。

其他避免内存泄漏的方式有：

良好的编程习惯，每次手动申请，最后手动释放

使用空闲链表来管理动态开辟内存的指针。

其他常见的工具插件。

##### 智能指针的内存泄漏如何解决？

智能指针分为三种unique_ptr独占所有权的指针，shared_ptr共享所有权的指针，weak_ptr不占所有权的指针。当多个shared_ptr指向同一块内存的时候就会计数+1，只有当计数=0的时候才会释放该内存。

为了解决循环引用导致的内存泄漏，引入了弱指针weak_ptr，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象内存进行管理。

##### 智能指针有没有内存泄漏的情况？

当两个对象同时使用一个shared_ptr指针指向对方会导致对象内存的引用计数+1造成**循环引用**从而导致引用计数失效，造成内存泄漏

 <img src="https://img-blog.csdn.net/20180920162715818?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pod2VueDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" style="zoom: 50%;" /> 

```c++
class B；
class A{
public:
shared_ptr<B> ptr;
};
class B{
public:
shared_ptr<A>ptr;
};
//创建两个类，并且这两个类带有指向彼此类型的智能指针shared_ptr
int main()
{//再创建两个智能指针指向动态分配的两个类，此时这这两个智能指针的引用计数是1
    shared_ptr<A> pa = new(sizeof(A));
    shared_ptr<B> pb = new(sizeof(B));
    pa->ptr = pb;//让pa指向的类中的指针去指向pb。此时pb的引用计数是2
    pb->ptr = pa;//同样的是2
	return 0;//当返回的时候智能指针pa和pb会被释放，他们对动态分配的内存是具有占有性的，当指针被销毁的时候，内存也会随即释放，但是此时引用计数为1，并不能释放。但是此时指向内存AB的两个指针被销毁了。找不到指向AB内存的指针了造成内存泄漏。如果将类中的shared_ptr修改成weak_ptr的话，弱指针指向同一个内存的时候引用计数不会增加。最后在papb销毁的时候引用计数为0
}
```

#### 预处理

##### 预处理器标识#error的目的是什么？

编译程序时，只要遇到#error就会生成一个**编译错误提示消息**，**并停止编译**。

其语法格式为#error error-message。(在makefile和CMake中也经常出现可以使用make -i来忽略掉错误，或者-k表示该错误的规则停止编译，其他的规则继续编译)

```c
#error "XXX has ben defined"
```

#####    定义常量谁更好？#define还是const?

define既可以代替常数值，又可以替代表达式，甚至是代码段。但是容易出错。const的引入可以增强程序的可读性，它使程序的维护和调试变得更加方便。

1. define只是用来进行**单纯的文本替换**，define常量的**生命周期止于编译期**，**不分配内存空间**，它存在于程序的**代码段** （只读存储区的机器代码和字符串常量），在实际程序中，他只是一个常数；而const常量存在于程序的**数据段**（初始化的全局和局部变量）**并在堆栈中分配了空间**。const常量在程序中存在，可以被调用和传递。
2. **const常量有数据类型**，而define常量没有数据类型。编译器可以对const常量进行类型**安全检查**。而define不行。
3. 很多IDE**支持调试**const定义的常量，而**不支持**define定义的常量。**极大地提高了程序的健壮性**一般更加倾向于用**const来定义常量类型**。

之前提到了使用const的好处是节省空间，避免不必要的内存分配（这里指的是define在代码区的若干个copy吧）

##### typedef和define有什么区别？

typedef与define都是**替一个对象取一个别名**。一次来增强程序的可读性，但是他们在使用和作用上也存在着以下四个方面的不同。

1. 原理不同

   #define是C语言中定义的语法，**他是预处理指令**，在预处理时进行简单而机械的字符串替换，**不做正确性检查**，

   typedef**是关键字**，在编译时处理，所以typedef具有**类型检查**的功能。他在自己的作用域内给一个已经存在的类型一个别名，但是不能在一个函数内部使用typedef。

2. 功能不同

   typdef用来**定义类型的别名**，包括内部类型和自定义类型。使得类型便于记忆的功能。

   #define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。

3. 作用域不同

   #define**没有作用域的限制**，只要是之前预定义过的宏，在以后的程序中都可以使用，而typedef有自己的作用域。

4. 对**指针的操作不同**

   ```c
   #define INTPIR1 int *
   typedef int *INTPIR2;
   INTPTR1 p1,p2; == int    *p1, p2//因为这是宏替换。
   INTPTR2 p1,p2; == int *p1,*p2//这是取了int*类型的别名，将p1和p2变成整形指针。
   ```

##### 如何使用define声明多个常数，用以表明1年中有多少秒？

```c
#define SECOND_PER_YEAR (60 * 60 * 24 * 365UL)
```

不知道这个有啥用。

##### #include<filename.h>和#include"filename.h"有什么区别？

这个我有点印象，前者是标准库，后者是我们自定义的文件。

对于前者，编译器先从标准库路径开始搜索filename.h，使得系统文件调用较快。而对于后者先从用户的工作路径开始搜索filename.h然后去寻找系统路径，使得自定义文件较快。

##### 头文件的作用有哪些？

我之前使用头文件里面写函数声明、宏定义、包含其他头文件，然后让源文件包含头文件即可。

头文件的作用主要表现为以下两个方面：

1. **通过头文件来调用库功能**。出于对源代码的考虑，源代码不便向用户公布，只要**向用户提供头文件和二进制的库即可**。用户只需要按照头文件中的接口声明来调用库功能，而不必关心接口是怎么实现的。编译器会从库中提取相应的代码。

   这是在头文件中声明二进制库的函数，从而实现调用的。应该是没遇到过，基本都是开源的

2. **头文件能加强类型安全检查**。当某个接口被实现或者使用时，其方式与头文件中的声明不一致，编译器就会指出错误，大大减轻程序员调试、改错的负担。

##### 在头文件中定义静态变量是否可行，为什么？

之前学过，静态变量只能在本文件中被调用，并且静态变量只需要初始化一次，哪怕是在函数内部定义的，也不会在函数销毁时一起销毁，静态变量存放在数据段，生命周期很长的，但是并不是说只能初始化一次，可以初始化很多次。而是只需要初始化一次。

如果将静态变量定义在头文件了，等到预处理的时候，会把头文件在被包含的源文件展开，这就导致每个包含头文件的源文件都带有一个静态变量。

再一个原因就是如果在头文件中定义了变量，就会导致每一个包含了头文件的C语言文件中都定义一次变量。声明可以重复无数次。头文件是有措施避免的，这是避免重复的宏定义。但是这里的编译宏并不能防止重复定义的报错。

```c
#ifndef xxx
#define	xxx
#endif
```

----

不可行，如果在头文件中定义静态变量，会造成资源浪费的问题，同时也可能引起程序错误。因为如果在使用了该头文件的每个C语言文件中定义静态变量，按照编译的步骤，**在每个头文件中都会单独存在一个静态变量。**从而引起**空间浪费**或者**程序错误**。（空间浪费就是每个头文件都单独存在一个静态变量。其实这样可以避免重复定义的问题，但是确实造成了空间浪费。

----

##### 写一个标准宏MIN，这个宏输入两个参数并返回较小的一个？

```c
#define MIN(A,B)	((A) <= (B) ? (A) : (B))//如果a小于等于b为真的话，返回A
```

##### 不使用流程控制语句，如何打印出1~1000的整数？

宏定义多层嵌套(10 *10 *10)，printf多次输出。

```c
#include <stdio.h>
int i = 1
#define B P,P,P,P,P,P,P,P,P,P
#define P L,L,L,L,L,L,L,L,L,L
#define L I,I,I,I,I,I,I,I,I,I
#define I printf("%3d",i++)
int main()
{
    B;
    return 0;
}

//另一种写法更简单
#define A(x) x;x;x;x;x;x;x;x;x;x;
int main()
{
    int n =1;
    A(A(A(printf("%d",n++))));
    return 0;
}
//使用递归应该也可以，
void func()
{
    if();//不可以，需要流程控制
    printf("%d",i++);
    func();
}
```

#### 变量

##### 全局变量和局部变量的区别是什么？

全局变量定义在文件内，而局部变量定义在函数内部，局部变量作用域是函数内，全局变量作用域是整个文件。局部变量保存在栈中，全局变量保存在数据段内。

1. 全局变量的作用域是程序块，而局部变量是作用域为当前函数
2. 内存存储方式不同，全局变量（还有静态全局变量和静态局部变量）分配在全局数据区内，而局部变量分配在栈区
3. 生命周期不同，全局变量随主程序创建而创建，随主程序销毁而销毁，局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在了。
4. 使用方式不同，通过声明为全局变量，程序的各个部分都可以用到，而局部变量只能在局部使用。这句话其实就是作用域。

---

学的有点乱，整理下C语言的编译流程：

C语言分为预处理、编译、汇编、链接、装载。

**预处理**期间进行宏替换，并且将那些**被包含的头文件内容加入到源文件**中。然后把源文件编译（汇编）成.o文件，最后将.o文件链接库生成.hex可执行文件。所以当我们在被多次包含的头文件中定义全局变量最后的结果就是在预处理期间在多个文件中出现同名的全局变量。这就导致重复定义了，而如果前面用static修饰的话。就是在多个文件中出现同名的静态变量，而静态变量属于内部链接，此时就没问题了（但会导致每个文件都有一个静态变量从而浪费空间）。编译是将源文件编译成中间目标文件，链接是将中间目标文件与动态/静态链接库进行链接生成可执行文件，而可执行文件在执行的时候会装载到内存中。

----

##### 全局变量可不可以定义在被多个.c文件包含的头文件中？为什么？

这里我的经验与笔试面试指南不同，不可以！如果在被多个.c文件包含的头文件中时，**就会在链接阶段因为多个同等定义的global存在于不同的翻译单元报错，符号被多重定义。**即使编译宏也救不了。

如果把全局变量加上修饰符static的话，外部链接变成内部链接就不会报错，但是这会导致每个包含头文件的源文件中都生成一个静态变量，造成空间浪费了。

---

##### 在路上突然对于内部外部链接的概念混淆了

一个.c文件或者.cpp文件才称之为编译单元，头文件会被加入到源文件中所以不能算是编译单元。，编译器编译的是.cpp/c文件。缺省情况下，常量具有static属性也就是内部链接。当头文件中定义了常量，而头文件被多个源文件包含了，此时并不会报错，但是程序中会出现大量副本，每个编译单元都存在一个常量。

如果在头文件中定义了变量，并且该头文件被多个cpp文件引用，将导致重复定义的编译错误，因为链接时该变量会扩散到全局以供其他编译单元也可以使用/修改它，这就导致了不同编译单元里的该全局变量重定义冲突。实际上是变量重名冲突，地址不冲突，因为各个全局变量都在各自的编译单元中。

条件编译宏是为了防止重复宏定义，而宏定义本身只是字符串常量保存在只读代码段中，条件编译的原理是对一部分内容不进行编译，而符号多重定义是发生在链接期间的。

条件编译宏并不能防止头文件中的变量进行外部链接。

---

##### 局部变量能否和全局变量重名？

当然可以，从内存的角度来说，全局变量存储在数据段，局部变量存储在栈里。从作用域角度，局部变量只作用域函数内部，而全局变量作用域本文件并且可以共享到其他文件的。只要不是在一个函数内部同时调用这两个变量就可以。因为在函数内部调用的话局部会覆盖全局变量的。

能，局部会屏蔽全局变量

局部变量可以和全局变量同名。

##### 在同一个函数内定义多个同名的局部变量是否可以？

对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，这里我做了实验，证明在同一个函数内部，也是存在作用域的。比如在函数开头定义的整个函数中调用都是它。如果在循环体内部调用的比如for，那么在这个循环体内部都是它。局部变量的作用域就在循环体内。

但是!，如果不是一个在函数开头，一个在循环体这种情况的话，而是两个都在函数开头的同名变量就会报错，多重定义。

##### 在函数内部定义多个静态局部变量是否可以？

可以的，但是同样是在不同的作用域下可以，**相同作用域下不管是否静态都不可以**。虽然静态局部变量和全局变量都存储在数据段内，但是静态局部变量只在其作用域内可见，这也是在同一个函数内部依旧可以定义多个静态局部变量的原因。只要作用域不同就可以。

静态局部变量与局部变量的区别：

1. 两者同样是只在作用域内可见
2. 静态局部变量存储在数据段中，局部变量在栈内
3. 静态局部变量生命周期和全局变量相同。局部变量在函数执行完毕后就被销毁了。

#### 函数

##### 请写个函数在main函数执行前先运行

之前的Linux应用学习中，讲过main函数之所以最先运行是因为在main执行前先执行引导程序，而这个引导程序会调用main函数，链接的时候链接器将引导代码连接到应用程序中，一起构成最终的可执行文件。

---

单片机中是由复位异常跳转到__main函数，此函数是编译器自动创建进而跳转到main函数的。

----

attribute可以设置函数属性(Function Attribute)、变量属性(Variable Attribute)、和类型属性(Type Attribute)。这是一个关键字，之前遇到过很多次，一直不知道什么意思，正好学习下。__ attribute __机制是GNU C的一大特色。内核使用的也是这个版本的语言。

gnu对于函数属性主要设置的关键字如下：

| aligned                  | 设置函数对齐方式                                             |
| ------------------------ | ------------------------------------------------------------ |
| always_inline/gnu_inline | 函数是否是内联函数（内联函数在内核中应用比较多，所谓的内联函数又称为字里行间函数，顾名思义在字里行间展开，不需要跳转指令到函数地址，好处就是可以快速的执行函数，坏处是如果频繁调用内联函数会占用更多的内存空间），适用于对时间要求高，本身长度短的函数。准确的说是，不会创建函数栈帧，参数直接在调用函数栈帧中。 |
| constructor/destructor   | 主函数执行之前、之后执行的函数，就是使用这个实现的在main函数执行之前执行函数 |
| format                   | 指定变参函数的格式输入字符串所在函数地址以及对应格式输出的位置。（一看到可变参函数，就想起函数参数的入栈顺序，是从右到左依次从高地址到低地址，向下发展，这样出栈的时候就是最左侧的参数数量先被获取，就可以知道剩下参数的地址了。否则不知道参数个数无法获取其他参数的地址） |
| noreturn                 | 指定这个函数没有返回值。注意，这里并不是指返回值为void，而是向_exit/exit/abord那样，函数执行完进程结束的函数。准确的说是不会将控制权返回给主调函数，需要使用exit直接退出。 |
| weak                     | 指定函数属性为弱属性，而不是全局属性，一旦全局函数名称和指定的函数名称命名有冲突，就使用全局函数，这个之前遇到过，其实和弱指针有点像（智能指针，弱指针不具备对内存的占有性，当释放弱指针的时候，内存不会被释放，当内存被弱指针指向的时候引用计数不会加一） |

完整代码如下：

```c
#include <stdio.h>
void before()	__attribute__((constructor));//给函数before添加属性：在main函数之前执行
void after()	__attribute__((destructor));//给函数添加属性，在main函数之后执行
void before(){
    printf("this is function %s\n",__func__);//这里的__func__是预定义宏，返回当前函数的函数名字符串。也就是"before"
}
```

##### 为什么析构函数必须是虚函数？

首先回顾下函数重写的概念，当父类中定义的虚函数继承到子类，在子类中定义一个返回值类型、函数名称、参数类型完全相同的函数。父子关系有了，虚函数有了，与之类型完全相同的非虚函数也有了。接下来只要让父类的变量得到子类地址即可。

```c
parent &a = son b;//此时是让父类类型的a作为子类类型b的引用，此时&a == &b
parent *a = son &b;//现在知道了，如果再加上parent *const a = son &b此时就和上边等价了。这里也是让父类类型a保存子类类型b的地址。此时*a == b。
```

此时实现了函数重写，在赋值的那一刻就决定了父类中虚函数的地址等于所赋值的子类函数的地址。

---

当析构函数是虚函数的时候，此时父类的析构函数已经变成子类的析构函数。

将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用**基类指针指向该子类对象**，此时发生了函数重写，释放基类指针的时候会调用基类的析构函数，而此时的虚函数析构函数已经**函数重写为子类的析构函数**了，所以实际上调用的是子类的析构函数，释放子类空间，防止内存泄漏。（因为是基类指针指向子类对象的，所以释放基类指针就要想办法释放子类对象，否则就是内存泄漏）。

虽然父类的析构函数不会继承给子类。但是子类中依旧会存在虚函数指针和虚函数表。

当子类的析构函数被调用的时候，会自动调用父类的析构函数

##### 为什么C++默认的析构函数不是虚函数？

这里详细解释下函数重写的过程，定义虚函数之后就会产生虚函数表和虚函数指针，虚函数表中存放的就是虚函数的地址。虚函数指针指向该地址。

而子类继承了父类的虚函数，自然同样也会有虚函数指针和虚函数表。然后我们在子类中定义与虚函数同名的函数，此时就导致子类中的虚函数表的地址被覆盖了，此时子类的虚函数指针指向了同名函数。此时与父类无关。

当父类引用或者指针被子类对象/子类对象地址赋值的时候，就会导致父类的虚函数指针发生偏移，指向子类中的对应函数。从而实现函数重写。这也是多态的表现。

---

回到这个问题，C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚函数指针，占用了额外的内存。而对于不会被继承的类来说，析构函数是虚函数的话，就**浪费内存**了，因此C++默认的析构函数不是虚函数，只有当需要当做父类时，设置为虚函数。

##### C++中析构函数的作用？

当创建一个类实例化的时候，类内的构造函数会被编译器调用自动运行。同样的道理当销毁一个实例化的类内存的时候，类内的析构函数会自动运行，常用于释放手动申请的内存。

这里其实和驱动模块的入口函数和出口函数很像。

----

复习下new和malloc

new是操作符，编译器能识别的，当调用new的时候，编译器会自动调用构造函数。而不仅仅只是分配内存。malloc是系统调用，调用的时候只有分配内存这一个操作。当使用new为对象分配内存的时候，还会调用构造函数实现对象的初始化。

---

如果构造函数打开了一个文件，最后不需要使用时文件就要被关闭，析构函数允许类自动完成类似清理工作，不必调用其他成员函数。

析构函数也是特殊的类成员函数，简单的说，析构函数与构造函数的作用正好相反，他用来完成对象被删除前的一些清理工作，释放申请的资源。

其实析构函数比较特殊，构造函数和析构函数并不能被继承。但是只要父类的析构函数声明virtual关键字，那么子类的析构函数就会自动称为虚析构函数。依旧可以实现函数重写。

##### 静态函数和虚函数的区别？

静态函数在**编译的时候就已经绑定了函数地址，**而**虚函数在运行的时候动态绑定函数地址**。

##### 重载和覆盖有什么区别？

函数重载是让一个函数可以有多种用途，条件是函数名称一致，形参不同，作用域相同。函数具体的地址根据我们传入的参数类型决定的。

1. 覆盖是子类与父类之间的关系，是**垂直关系**，而重载是同一个类中不同方法之间的关系，是**水平关系**。
2. 覆盖要求参数列表相同，重载要求参数列表不同；覆盖要求返回类型相同，重载不做要求。
3. 覆盖关系中，**调用方法体是根据对象类型决定的**（基类还是派生类）；重载关系是根据**调用时的实参表和形参表来选择方法体的**。
4. 重载可以用于运算符重载和函数重载是为了让一个函数有多种用途，而覆盖是函数重写，是多态的表现。
5. 覆盖只能由一个方法或者一对方法产生关系，重载是多个方法之间的关系。覆盖是动态多态，重载是静态多态，前者运行时由父类指针或引用指向子类对象时才确定具体函数地址。而重载是编译时根据实参表和形参表决定好了。

##### 虚函数表具体是怎样实现运行时多态的

父类中的函数设置为虚函数，会自动创建虚函数表和虚函数指针，虚函数表中存储的就是虚函数的地址，子类会继承父类的虚函数，子类定义的函数保证函数名称、函数返回值类型、函数形参类型与子类的虚函数相同。此时垂直关系有了，函数覆盖的条件满足了，当线程运行到父类指针或者引用被子类对象的地址/子类对象赋值的时候，虚函数表中的虚函数地址将会被覆盖成子类对象中对应的函数地址，虚函数指针指向子类函数地址。从而实现运行时动态绑定函数地址。

原理：虚函数表是一个类的虚函数的地址表，每个对象在创建时，都会有一个指针指向该类虚函数表，每一个类的虚函数表，按照函数声明的顺序，会将函数地址存放在虚函数表中，**当子类对象重写父类的虚函数的时候**，**父类的虚函数表中对应的位置会被子类的虚函数地址覆盖**。

作用：再用父类指针调用子类对象成员函数时，虚函数表会指明要调用的具体函数是哪个。这里感觉并不是调用，而是指向子类对象地址的时候就已经完成重写了。

##### C语言是怎么进行函数调用的？

大多数CPU上的程序是**使用栈来支持函数调用操作**，栈被用来传递函数参数、存储返回信息、临时保存寄存器原有的值以备恢复以及用来存储局部变量。FIQ模式下因为有其专属的寄存器是不需要使用栈来保存现场的，所以速度要比IRQ模式快。

**函数调用操作所使用的栈部分叫做栈帧部分**（中断嵌套时将中断栈上的内容拷贝到其他模式栈上称为堆栈帧），这部分之前从来没有讲过。每个函数调用都有属于自己的栈帧结构，栈帧结构由两个指针指定，帧指针指向起始，栈指针指向栈顶，函数对于大多数数据的访问都是基于帧指针。**栈帧就是一个函数执行的环境**，帧指针与栈指针中间的部分就是函数的栈帧部分了。函数本身的存储在代码区的，但是函数的返回地址、函数参数、函数返回值、局部变量是保存在栈中的，实际上就是栈帧部分。

<img src="C:\Users\MACHENIKE\AppData\Roaming\Typora\typora-user-images\1676096098569.png" alt="1676096098569" style="zoom: 50%;" />

这张图，先看栈指针esp部分，正好复习了之前的函数参数压栈顺序，因为函数的第一个参数是整个参数的数量，比如printf第一个参数是字符串，其中的%个数对应了参数个数，根据栈先入后出的原则，压栈顺序应该是从右到左，根据栈向下增长的特点，最右侧的参数地址最高，图中的蓝色部分是调用函数的栈帧结构，比如是main，此时在主函数中调用了fun函数，那么黄色部分的栈帧结构就是fun函数的。返回地址指的是当main函数调用fun函数结束之后需要返回到main函数中的地址。

---

参数压栈顺序是由函数调用约定决定的，默认的是_cdecl，从右到左，由调用者负责清除栈内容。

---

栈指针和帧指针一般都有专门的寄存器，通常使用ebp寄存器作为帧指针，使用esp寄存器作为栈指针。**帧指针指向栈帧结构的头，存放着上一个栈帧的头部地址，栈指针指向栈顶。**这里其实不应该说栈顶，这里应该说是栈底，反正最大地址是被确定了，只能向下增长。

ARM架构中的R10sl表示堆栈限制指针位于栈的最底部，因为栈是向下增长的，所以SP被用来与sl进行比较，只有当sp大于sl时或者说sp在sl的上方好使，否则栈溢出下溢。R11就是FP帧指针位于sp的上方，两者之间是函数栈帧。

##### 请说一说select

这个是用于监控的函数，监控哪个文件有可用资源，学驱动的时候写在应用程序中的。

----

正好复习下IO多路复用，之前看面经有人不知道这个就把IO口的复用讲了，笑死。

多路复用是**通过一种机制可以监视多个文件描述符**，一旦某个文件描述符可以执行IO操作时，能够通知应用程序进行相应的读写操作。

---

1. select函数原型

   ```c
   int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timrval *timeout);//我记得是检测可读、可写、异常的文件描述符集合，timout是超时时间，第一个maxfdp表示最大文件描述符编号值加1。
   ```

2. 文件描述符的数量

   单个进程能够监视的**文件描述符的数量存在最大上限**，通常是1024，这是内核决定的#define __FD _SETSIZE 1024

3. 采用轮询的方式扫描

   select返回的是int，可以理解为返回的是就绪态的文件描述符的个数，如果想知道究竟是哪个文件描述符准备好了，此时三个文件描述符集合中剩余的就是了。不过由于采用轮询的方式扫描文件描述符集合，所以**文件描述符数量越多，性能越差**。

4. **内核/用户空间内存拷贝**

   这也是很少使用select的原因。select每次都会修改内核中的fd集合，每次循环中如果有就绪态的文件描述符了，那么只保留该文件描述符，下一次循环中只剩下该文件描述符了。所以每次调用select函数都需要从**用户空间向内核空间复制所有的fd集合**，产生巨大开销。

5. 优点

   - select的可移植性比较好，可以跨平台
   - select的超时时间可以精确到微妙，用时间结构体timrval

6. 缺点

   - select单个进程监控的**文件描述符上限**为1024
   - 每次调用都会从 用户空间向内核空间**拷贝文件描述符集合**。
   - select返回的就绪文件描述符集合，需要用户遍历所有文件描述符是否在集合中，**无法准确得知哪个文件描述符在其中**。
   - select监控文件描述符集合是通过轮询的方式，数量越大，效率越低

##### 请你说一说fork/wait/exec函数

现代的Linux中fork使用到了写时拷贝的思想，本身fork是由进程调用用来创建子进程的函数，此时子进程与父进程不分先后的执行，以只读的形式共享数据，需要写入的时候才会拷贝一份给子进程。wait函数父进程用来给子进程收尸的函数，如果子进程不结束父进程会一直挂起，所谓的收尸其实是子进程死掉之后没有释放所有资源，还保留着进程控制块PCB，这就占用着进程号，并且还提供退出代码，让父进程知道子进程是如何结束的。exec函数是用来将一个可执行的映像替换父进程的内容。

---

#### 数组

##### 以下代码表示什么意思？

```c
*(a[1]+1)、*(&a[1][1])、(*(a+1))[1]
//    *(*(a+1)+1)、*(&*(*(a+1)+1))、*(*(a+1)+1)
//分析完了之后来看，a[1]表示第二行第一列的地址，a[1]+1表示第二行第二列的地址，*(a[1]+1) 是第二行第二列的元素
//a[1][1]表示第二行第二列的元素，取地址再解引用，还是第二行第二列的元素
//a表示第一行地址，a+1表示第二行地址，*(a+1)表示第二行第一列地址，*(a+1)[1]表示第二行第二列的地址。
//[1]这个其实是(偏移+1)然后解引用的意思等于*(*(a+1)+1)
```

---

这道题非常好，先捋一下

```c
int b[2][2]={0,1,2,3};//之前的(char*)(&a+1)-(char*)(&a)=4表示的是a的内容是四个字节的类型，为了获得a的内容类型，这里取a的地址作为指针，首先进行一次指针加法，然后把a类型的指针强制转换成字符串类型的指针，此时本来(&a+1)-&a=1因为表示的是1个a类型的大小，现在变成了字符大小，a等于4个字符，所以结果是4.
//先来看下跑代码的结果
&b = 6fced060;//此时&b+1是增加了16个字节，此时是把&b作为地址，指向的内容b是16字节的，&b保存的是整个数组的地址。
b = 6fced060;//此时b+1是增加了8个字节，以b为地址，指向的内容*b是8字节。*b或者b[0]保存的内容是第一行的类型。b保存的是第一行的地址。
*b = 6fced060//*b+1是增加了4个字节，以*b为地址，指向的内容是b[0][0]是4字节的，这里很好理解，因为保存的内容是int类型的
b[0] = 6fced060;//保存的是第一行第一列的地址
b[0]+1 = 6fced064
b[1] = 6fced068;
*b[0] = 0
**b = 0
b[0][0] = 0；//保存的是第一行第一列的元素
//第一行第一列元素的地址==第一行的地址==整个数组的地址，虽然地址相同但是意义不同(解引用的次数不同)。当维度下降时，后两个含义相同
    //b[][]==4；表示这里面保存的是四个字节类型，但是只有对其地址偏移+1的时候才是4个字节，b[][]+1这就是值增加1
    //b[]==8；这里面保存的是八个字节，整个一行的内容，b[1]+1表示偏移了一个元素
    //b==16，这里面保存的是16字节，整个数组的内容。整个一行的地址，b+1表示偏移了整个一行，虽然这里面保存了16个字节的类型，但是只有对b的地址偏移的时候才能看出来。b+1反而是把b保存的内容当成地址来偏移，实际操作的是*b的地址。
    //&b，这里面保存的是整个数组的地址。所以此时&b+1表示偏移了整个数组
```

---

##### 数组下标可以为负数么？

可以，数组下标比如a[1]，这里是对当前地址的偏移然后解引用也就是*(a+1)，此时这是一个一维数组，整个数组的含义等于第一行的含义，这是&a的意思，a表示第一列的地址，此偏移+1就是第二列的地址，然后解引用变成第二列的元素。如果此时指向数组的指针是从数组中间的元素作为起始地址的话，就可以是负数进行反向偏移。

```c
#include<stdio.h>
int a[5] = {1,2,3,4,5};
int *b = a+4 == a[4];
b[-1] ==*(b-1)==*(a+4-1)==a[3];
```

#### 位操作

##### 如何求解整型数的二进制表示中1的个数？

```c
#include<stdio.h>
int func(int x)
{
int count = 0;
while(x)
{
	count++;
	x = x &(x-1);
}
return count;
}
int main(void)
{
    printf("%d",func(999));
}
```

核心算法就是x &(x-1)，想要弄明白需要明白两点

- x-1：这一步实际上是将**最右侧的1变成0**,**1右侧的位从0变成1**
- x&(x-1)：这一步实际上是**把最右侧的1去掉**，每一次求交都会去掉一个1位，循环了多少次就去掉了多少个1位，所以返回循环次数。

##### 如何求解二进制中0的个数

先求出1的个数，然后用类型长度比如32位减去就是了.

##### 交换两个变量的值，不使用第三个变量。a=3,b=5;交换之后a=5,b=3

如果采用算法的思路，让a等于两者的集合，让b等于a，此时让a-b就是原来b的值赋值给a

```c
a = (a+b);
b = (a+b)-b =(a)== a-b;
a = (a+b)-(a) == a-b;
```

---

复习下异或^运算在ARM汇编中就是EOR

异或表示如果两个位不相同就是1，相同就是0，比如100^010=110,001^011=010，可以把异或理解为不进位的加法。这种方法是不理解为啥最后能交换。

```c
a=001;
b=010;
a = a^b == 011;
b = a^b == 001;
a = a^b == 010;
```

##### 给定一个整型变量a，写两段代码，第一个设置a的bit3，第二个清除出a的bit3，其他位保持不变。

```c
#define BIT3 (0x1<<3)
static int a;
void set_bit3(void)
{
    a |=BIT3;//实际上就是a = a |1000
}  
void clear_bit3(void)
{
    a &= ~BIT3;//实际上是a = a & 1111 1111 1111 0111，实际上是BIC操作位清零
}
```

---

算法题中遇到的

```c
*i++;//++运算符和*运算符的优先级是一样的，顺序是从右到左，所以如果是想要让*i自加应该是(*i)++
int i,j = 0;//这里实际上是int i;int j = 0，并没有对i进行初始化
```

---

#### 容器与算法

这一章就是C++与数据结构的部分了，C++可以说是我学过的内容中学的最早，忘的最多，基本上也就FreeRTOS和他忘得一边多了。突然看到原来C++还有STL和模板的笔记，我就说map和set看着眼熟肯定学过。。。

##### map和set有什么区别？分别又是怎么实现的？

---

先复习一波

迭代器是容器与算法的胶容器，算法通过迭代器才能访问容器中的数，每个容器都要专属的迭代器，其实迭代器类似于一个指针。

set是集合，属于关联式容器，不允许插入重复的元素，（而multiset可以插入重复元素），自动排序（默认是从小到大），所以无法从头插或者尾插，自定义的类型就要修改set了。插入的同时返回插入结果，表示插入是否成功。底层是用二叉树实现的。set的**实值就是键值**。

map是字典，属于关联式容器，底层是用二叉树实现的，map的成员都是pair对组，对组的第一个元素是键值，第二个元素是实值。map中不允许插入重复的键值，自动排序，根据键值快速找到value值。multimap允许插入重复的键值。

关联式容器：二叉树结构，各元素之间**没有严格的物理上的顺序关系**（比如连续地址）

---

map和set都是C++的**关联式容器**，**其底层实现都是红黑树**（RB-tree）。

由于map和set所提供的操作接口在红黑树中都实现了，所以map和set只是转调红黑树的操作行为而已。（CFS调度器的就绪队列就是由红黑树管理的）

map和set的区别在于：

1. 存储的元素类型不同，map存储的都是**键值对**(key-value)：**键值起到索引的作用**，**键值与实值相关联**。set存储的**都是键值**，**每个元素只有一个键值**，并且**实值就是键值**。
2. set的**迭代器是const类型的**，（这里可以理解为是一个常量指针，指向的是const类型的内容），**不允许修改元素的值**；map允许**修改value实值**，但是**不允许修改key键值**。（之所以不允许修改键值，是因为map和set就是**根据键值进行元素排序**的，如果修改键值，就会导致排序发生变化，iterator迭代器所指向的**地址将会失效**）
3. map支持下标操作，set不支持下标操作（map的[]下标运算符将key值作为下标执行查找，其实就是作为当前地址的偏移，但是如果键值不存在，就会**插入一个具有该键值和mapped_type类型的实值**，所以**慎用下标**，多用find）

##### STL的allocator有什么作用？

我哭了，真的。。。这是C++中 模板的内容，这两个问题让我才想起来，还学过C++中的标准模板库和函数模板。幸好我这方向C++不太重视，而且笔记也不太多。

---

也是需要复习一波

STL标准模板库广义上分为容器、算法、迭代器，实际上分为六个组件：容器、算法、迭代器、仿函数、适配器、空间配置器。其中对于后两者并没有学过，因为难并且用途比较窄。其中空间配置器负责空间的配置和管理。

---

STL的空间配置器**用于封装STL容器的内存管理上的底层细节**。在C++中内存配置如下：

- new运算分为两个阶段：（这里需要复习下，new是关键字也是运算符，所以执行的时候编译器会自动执行对象的构造函数。）1.调用::operator new配置内存，2.调用对象构造函数初始化对象。
- delete运算分为两个阶段：1.调用对象析构函数，2.调用::operator delete释放内存（这里其实和operator++这样一样，都属于运算符）

与上面的内存配置类似，STL allocator分配器将两个阶段操作区分开：内存分配由alloc::allocate()负责，内存释放由alloc::deallocate()负责；对象构造由::construct()负责，对象析构由::destroy()负责。

为了提高内存管理的效率，**减小申请小内存造成的内存碎片问题**。**STL采用了两级配置器**，当分配的空间大小**超过128B**时，使用**第一级空间配置器**；当分配的空间大小**小于128B时**，使用**第二级**空间配置器。第一级空间配置器直接使用malloc/free函数进行内存空间的分配和释放，第二级空间配置器采用了**内存池技术**（上一次看到是内核中），通过空闲链表管理内存。（避免内存泄漏的方法之一就是用空闲链表管理内存，还有小工具、智能指针、良好的编程习惯）。

实际上allocator就是空间配置器。用来实现容器内存管理的底层细节。

##### STL迭代器如何删除元素？

之前提到过迭代器其实就是指向容器中元素的指针。而容器可以分为两类序列容器和关联容器，前者强调排序，每个元素都有固定的位置，各元素没有严格的物理上的顺序结构，采用二叉树结构。所以这道题实质上问的是在两种容器下删除元素之后迭代器如何保证指向的地址依旧有效。

- 对于序列容器vector/deque来说，使用erase(iterator)后，**后边每个 元素的迭代器都失效** 了，但是erase会**返回下一个有效**的迭代器。
- 对于关联容器map/set来说，使用了erase(iterator)后，**当前元素的迭代器失效**，用红黑树结构管理的，删除当前元素的迭代器并不影响后边的，只要在调用erase**之前记录下**一个元素的迭代器即可。
- 对于list来说，采用的是链式结构，也是不连续分配的内存，所以删除当前元素不影响后边的，并且erase方法也会返回下一个有效的iterator。所以上面两种都适用。

序列容器底层实现是数组，关联容器底层实现是二叉树，list底层是链表。

##### STL中MAP数据如何存放的？

map的底层结构是红黑树，multimap的底层结构也是红黑树，在C++的STL笔记中只记了这两种map，指南中又提到了一种，unordered map。这个底层结构是哈希表。

---

需要先介绍下unordered map

顾名思义，unordered_map容器中的元素是无序的。都是存储的键值对pair类型数据。存储的**各个键值对的键互不相同且不允许被修改**。但是由于unordered_map底层采用的是哈希表存储结构，该结构本身不具有对数据的排序功能，所以此容器不会自动对存储的键值对进行排序。

map同样无法修改键值对中的键，且键互不相同。但是底层是用红黑树结构，所以具备自动排序的功能。之前介绍过不允许修改map中的键是因为键值是用来排序的，这里虽然unordered_map因为底层结构的原因不具备自动排序的功能，但是依然不允许修改键值。multimap区别在于可以插入重复键值的键值对。

---

##### STL中map与unorder_map有什么区别？

两者唯一的区别就在于后者不具备自动排序的功能，因为底层结构是哈希表，而map底层是红黑树，红黑树本质是含有红黑节点并能自平衡的二叉搜索树，重点是他是一个二叉搜索树，左子树小于根节点小于右子树。所以按照中序遍历的结果是有序的，左根右。

1. map底层结构是**红黑树**、unordered_map底层结构是**哈希表**。
2. map按照operator<比较判断键值是否相同，插入到树中合适的位置。**中序遍历的结果是有序的**。而unordered_map是计算元素的hash值，根据hash值判断键值是否相同，**遍历结果是无序的**。
3. 使用map的时候需要为key定义**operator<**。而unordered_map的使用需要定义**hash_value**并重载**operator==**。

unordered_map**插入删除和查询的效率要高于map**（与底层结构有关，已知键值直接求出对应的hash值，插入只要保证哈希值不同就行，删除也不需要考虑顺序问题）。所以如果不需要结果排序的话，优先使用unordered_map。

##### vector和list的区别是什么？

vector的底层结构是数组，list的底层结构是链表，前者是连续地址，后者地址不连续。

---

同样需要复习下vector容器

vector底层实现是数组，而vector是一个射线，普通数组是静态分配内存，分配完之后大小固定。而vector是动态分配，当需要扩展数组的时候，会发生内存拷贝将原有的vector中的元素拷贝到新的地址中。原有的容器地址释放。如果vector需要扩展容器一次就扩展一次会浪费时间，所以扩展的时候往往会多申请一部分的内存空间，需要10000字节，可能会申请12000的字节。当容器变短的时候，末尾超出容器长度的元素被删除。当删除容器中间的元素时会导致该元素后边元素的迭代器失效，只能依靠删除函数返回值提供下一位有效地址。可以通过索引找到元素所以是随机访问。

----

1. vector底层结构是数组，list底层结构是双向链表
2. vector是连续内存，list是不连续的内存
3. vector一次性分配内存，每次扩展是整体发生内存拷贝。list扩展一个节点就申请一块地址。
4. vector可以随机访问，list只能遍历找到该节点
5. vector在中间插入删除节点会导致内存拷贝（指的是整体往前移），list插入删除操作的性能更好。

##### STL中迭代器有什么作用？有指针为何还要迭代器？

这道题好，我就是把迭代器当成指针。

----

1. 迭代器

   iterator模式又称为Cursor游标模式，用于提供一种方法可以**顺序访问**一个**聚合对象**（容器）中各个元素，而又**不需暴露**该对象的**内部表示**。让我们在不知道对象内部类型的情况下（如果使用指针就必须知道指向对象的类型），按照iterator提供的方法访问聚合对象中的各个元素。

2. 迭代器和指针的区别

   迭代器是**类模板**，**本质是封装了指针**，提供了比指针更高级的行为，**根据不同类型的数据结构实现不同的++和--操作**（重载了指针的操作符）。返回的是**对象地址**，而不是对象的值。

3. 迭代器产生原因

   为了**不用暴露集合内部的结构**而达到**循环遍历集合**的效果。

---

迭代器提到了类模板，还需要复习下类模板

建立一个通用的类，类中成员，数据类型可以不做具体指定，用虚拟的类型代表。这部分还需要复习。

##### epoll的原理是什么？

---

需要先复习下epoll，查了好久发现的epoll是在驱动中学的。

epoll函数是改良版的poll函数，所以需要先复习下poll函数。

---

select/poll/epoll之间区别

- select应用于BSD、poll应用于UNIX、epoll应用于Linux
- select和poll采用轮询来检查文件描述符状态、epoll通过事件驱动。
- select文件描述符数量为1024上限、poll和epoll无上限。
- select采用fd_set结构、poll采用pollfd结构体。
- select和poll需要将文件描述符拷贝从用户空间拷贝到内核空间。epoll通过mmap文件映射即共享内存实现。

----

poll和select很类似，但是有两个区别：

- 首先是poll不存在监视**文件的上限**，select的文件描述符集合是1024个文件。

- 另一个是接口函数不太一样。

  ```c
  int poll(struct pollfd *fds,nfds_t nfds,int timeout);//poll和select的区别在于传入的并不是三个读写异常文件描述符集合了，而是一个pollfd结构体数组。
  struct pollfd{
      int fd;//监视的文件描述符，这里之所以不是文件描述符集合，是因为传入的是数组
      short events;//监视的事件，可读可写异常
      short revents;//select的文件描述符集合需要拷贝到内核中，因为每次调用都会对集合进行修改，那些发生了所监视事件的集合会被保留下来，从而获知了哪些文件发生了事件。
      //这里是通过revents来观察fd发生了哪些事件。
  }
  //nfds表示数组一共有多少个结构体，返回值就是发生事件的文件个数。
  ```

----

之前学驱动的时候确实讲了下epoll，但是并没有做实验。epoll是为了解决传统select和poll函数监控文件需要轮询遍历所有文件浪费时间的问题，epoll是专门用来处理大并发。常常是在网络编程中用到。

- epoll事件驱动、而非轮询。发生检测的事件时返回。
- epoll可检测的文件描述符无上限
- epoll的API更复杂
- epoll是Linux特有的函数，兼容性差

调用顺序：

```c
int epoll_create(int size);//自从2.6.8版本之后size没有意义了，返回epoll对象
int epoll_ctl(int epfd,int op,int fd,struct epoll_event *event);//epfd是要操作的epoll句柄，op表示要对epoll对象进行的操作，ADD/MOD/DEL添加修改删除文件描述符，fd是监控的文件描述符，event是要件是的事件类型，返回值成功0，失败-1，并设置errno的错误码
int epoll_wait(int epfd,struct epoll_event *events,int maxevents,int timeout);//epfd是要等待发生事件的epfd，events这是由函数填写的具体发生了什么事件数组，maxevents事件数组的大小，超时时间，成功返回就绪的文件描述符数量。
```

event事件在内核中是用红黑树维护的，红黑树应用的很多，CFS的就绪队列就是红黑树维护的，因为红黑树本质是携带红黑节点的自平衡二叉搜索树，利用搜索树的左根右节点数值依次增大的特点，存放分配的时间片。任务队列task_struct就不需要顺序所以是双向循环链表管理的。map和set和multimap都是底层结构为红黑树，所以他们 自动排序，插入的时候就要根据结构插入。unordered_map底层结构是哈希表，所以查找删除添加都很容易，但是没有顺序。

##### STL里resize和reserve的区别是什么？

resize是改变当前容器内**含有元素的数量**（v.resize(len)），如果原来是v的size小于len，那么容器新增(len-size)个元素，元素的值默认是0。也可以通过resize(len,elem)，用elem填入新位置。

reserve是**改变当前容器的最大容量**(capacity)，不会生成元素，只是确定这个容器允许放入多少对象，如果reserve(len)的值大于当前capacity，那么会重新分配一块能存len个对象的空间，（实际上是会**预留出一部分空间**，要去1000给1200，这是为了减少拷贝的次数）然后把之前的对象**拷贝到新地址**，销毁之前的内存。

#### 类与数据抽象

##### C++中类成员的访问权限？

之前复习了一部分，非静态成员函数可以访问非静态的成员变量和静态的成员变量，而静态成员函数只能访问静态成员变量，因为静态成员函数是在类创建之前就可以执行的行为，并不绑定具体的对象，所以无法在函数内部使用this指针找到对象，自然也就无法找到对象中的成员，但是静态成员变量同样是对象创建之前就可以被访问的变量，也不绑定对象，所以只能访问静态的成员变量。

但是非静态成员函数也是多个对象共享的，也就是说即使创建了多个对象，内存上只会**生成一个非静态成员函数的栈帧结构**（一个栈帧意味着其他对象调用该非静态成员函数时的局部变量被共享），但是和静态成员函数的区别在于，他可以调用this，这就可以根据调用函数的对象通过this指针指向该对象。this指针是一个指针常量，指针的地址不可改变，但是对象的内容可以改变。而set的迭代器是一个常量指针（当然，迭代器本身不是指针，他是指针的封装，更高级的行为），指向的值不可以修改。

这里问的成员访问限定符

C++通过public、protected、private三个关键字来**控制成员变量和成员函数的访问权限**，分别代表公共的、被保护的、私有的，被称为成员访问限定符。在类的内部，都是可以互相访问的，没有访问权限的限制。在类的外部只能通过对象进行访问，并且只能访问public成员。后两者在类外都不可以访问，他们的区别体现在继承的时候。

##### C++中struct和class的区别是什么？

注意重点是C++中，此时struct在C++中是可以把函数作为成员的，C中就不可以，所以只能存放函数指针。c中的struct中的成员是连续地址，而函数存放在代码段上，其他成员存放在栈或者数据段上，c++中难道

区别在于：

- struct的**默认继承权限**和**默认访问权限**是public，而class的默认继承权限和默认访问权限是private。
- class还可以定义模板类的形参。这个笔记中没提到，模板还没复习，，，

##### C++类内可以定义引用数据成员么？

这句话没太看懂，指的是类内定义成员函数，然后在函数内部调用成员变量吗？

---

可以，必须通过成员函数初始化列表初始化。

这里的列表是什么？指的就是初始化列表，这是构造函数内部需要初始化的多个成员。

##### 面向对象与泛型编程是什么？

面向对象就是一切变量和函数都存在于对象中，用来描述对象的行为和属性。

泛型编程是用字符代替类型。

1. 面向对象编程简称OOP，是一种程序设计思想。OOP把**对象作为程序的基本单元**，一个对象包含了数据和操作数据的函数。
2. 面向过程的程序设计把计算机程序视为一系列的命令集合，即**一组函数的顺序执行**。为了简化程序设计，面向过程把函数继续切分为子函数，降低系统的复杂度。
3. 泛型编程，让**类型参数化**，方便程序员编码。

##### 什么是右值引用，跟左值有什么区别？

右值引用是充分利用右值的构造来减少对象构造和析构操作以达到提供效率的目的。

```c
//类型 && 引用名 = 右值表达式
```

左值和右值的概念：

- 左值：可写，能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的持久对象。
- 右值：可读，不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。

右值和左值的区别：

1. 左值可以寻址，右值不可以。
2. 左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。
3. 左值可变，右值不可变。

左值引用和右值引用的区别

**首先提下为什么会出现右值引用**

左值引用无法引用立即数，因为立即数存放在寄存器中，并不在内存里。可以该为常量左值引用，这样会把立即数作为临时变量保存在内存中。但这样就无法修改数据，为此引入右值引用。

```c
int &a = 10;//错误，10为立即数，此时无法对寄存器中的立即数取别名。
const int &a = 10;//正确，相当于const int temp = 10;const int &a = temp;
//而立即数、函数返回值等不能取地址、没有名字、临时的就是右值。函数返回值在函数结束后会销毁，因此不能对函数返回值取左值引用。
//类型 && 引用名 = 右值表达式；
int &&a = 10;//此时相当于int temp = 10;int &a = temp;让右值生存期延长到与右值引用相同的生存期。区别就是可以读写
```

- 右值引用就是绑定到右值的引用上
- 左值引用就是绑定到左值的引用上

##### 析构函数可以为virtual型，构造函数不能，为什么？

析构函数是虚函数，这是为了保证父类指针被释放的时候会导致基类对象被释放调用析构函数，而父类的析构函数已经被函数重写为子类的析构函数了，所以当父类指针被释放的时候会导致子类对象被释放。

---

初始化列表，这个就是无参构造函数后边加上：的部分

```c++
Person(int c,string b):age(c),name(b)
```

构造函数不能声明为虚函数的原因是：

虚函数的主要意义在于被派生类继承从而产生多态。派生类的构造函数中，编译器会加入构造基类的代码，如果基类的构造函数用到参数，则派生类在其构造函数的初始化列表中必须为基类给出参数。

虚函数就是开启动态绑定，程序会根据对象的动态类型来选择要调用的方法。然而构造函数运行的时候，这个**对象的动态类型还不完整**，没有办法确定它到底是什么类型，故构造函数不能动态绑定。

动态绑定就是根据对象的动态类型而不是函数名，在调用构造函数之前，这个对象根本不存在，怎么动态绑定？

##### C++中空类默认产生那些类成员函数？

C++中空类默认有以下六个函数：默认构造函数、复制构造函数、析构函数、赋值运算符重载函数、取址运算法重载函数、const取址运算符重载函数。

```c
class Empty
{
    public:
    Empty();//默认构造函数
    Empty(const Empty&);//拷贝构造函数 
    ~Empty();//析构函数
    Empty& operator=(const Empty&);//赋值运算符，可以对类对象操作
    Empty* operator&();//取址运算符
    //上边这两个就是为什么可以直接让父类指针引用指向子类对象了。
    const Empty* operator&() const;//取址运算符const
};
```

#### 面向对象

##### 面向对象和面向过程有什么区别？

面向对象是以对象为编程的基本单位，对象包括数据和函数。面向过程是把程序理解为一系列的函数组成。

面向对象和面向过程有以下四个方面的不同：

1. 出发点不同

   面向对象使用符合常规思维的方式来处理客观世界的问题，强调把**解决问题领域的动作直接映射到对象之间的接口上**。而面向过程则强调的是**过程的抽象化与模块化**，是以过程为中心构造或处理客观世界问题。

2. 层次逻辑关系不同

   面向对象使用计算机逻辑来模拟客观世界中的物理存在，以**对象的集合类作为处理问题的单位**，尽可能地使计算机世界向客观世界靠拢，使得处理问题的方式更清晰直接，面向对象使用类的层次结构来体现类之间的继承与发展。

   面向过程处理问题的基本单位是**能清晰准确地表达过程的模块**，用模块的层次结构概括模块或模块间的关系与功能，把客观世界的问题抽象成计算机可以处理的过程。

3. 数据处理方式与控制程序方式不同

   面向对象将数据与对应的代码封装成一个整体，原则上其他对象不能直接修改其数据，**对象的修改只能有自身的成员函数完成**，控制程序方式上是**通过事件驱动来激活和运行程序的**。 

   面向过程是直接通过程序来处理数据，处理完毕后即可显示处理的结果，在控制方式上是按照**设计调用或返回程序**，不能自由导航，各模块之间存在着控制与被控制，调用与被调用的关系。

4. 分析设计与编码转换方式不同

   面向对象贯穿于软件生命周期的分析、设计及编码中，是一种平滑的过程，从分析到设计再到编码是**采用一致性的模型**表示实现的是一种无缝连接。面向过程强调分析、设计及编码之间按**规则进行转换**贯穿于软件声明周期的分析、设计及编码中，实现的是一种有缝的链接。

##### 面向对象的基本特征有哪些？

面向对象的基本特征有四种

1. 抽象：抽象包括过程抽象和数据抽象。
2. 继承：提供了一种明确表述共性的方法。
3. 封装：把过程和数据包围起来，对数据的访问只能通过已定义的接口。
4. 多态：允许不同类的对象对同一消息做出相应。

##### 什么是深拷贝？什么是浅拷贝？

深拷贝是彻底的拷贝，两对象中所有的成员都是独立的一份，如果成员中有指针，那么深拷贝就是**指针保存的地址不同**，而指针所指向的**内容相同**。

浅拷贝是成员变量可能是共享的。

##### 什么是友元？

友元提供了一种普通函数或者类成员函数访问另一个类中的私有或保护成员的机制。有两种形式的友元：

1. 友元函数：普通函数访问某一个类中的私有或保护成员。
2. 友元类：类A中的成员函数访问类B中的私有或保护成员。

##### 基类的构造函数/析构函数是否能被派生类继承？

基类的构造函数不能被派生类继承，派生类中需要声明自己的构造函数。设计派生类的构造函数时，不仅要考虑派生类锁增加的数据成员初始化，也要考虑基类的数据成员的初始化。

基类的析构函数也不能被派生类继承，派生类需要自行声明析构函数。但是虚函数的析构函数虽然不可以被继承，但是在派生类中也会存在虚函数表，和虚函数指针从而实现多态。

##### 初始化列表和构造函数初始化的区别？

这个问题问得好，之前复习过列表，这个是在构造函数：后边跟着的，表示需要初始化的变量。

```c
Example::Example():ival(0),dval(0.0) {}
Example::Example()
{
    ival = 0;
    dval = 0.0;
}
```

第一行的构造函数显示的**初始化**类的成员；没有使用初始化列表的构造函数是对类的成员**赋值**，并没有进行显示的初始化。

有时候必须用带有初始化列表的构造函数：

1. 成员类型是**没有默认构造函数的类**。需要提供显示初始化式。
2. const成员或引用类型的成员。因为这两种**只能进行初始化**，而不能对他们赋值。属于常量或者指针常量。

##### 类的成员变量的初始化顺序是什么？

成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，**只与定义成员变量的顺序有关**。因为成员变量的初始化次序是根据变量在内存中次序有关，而内存中的排列顺序早在编译期就根据变量的定义次序有关。

静态变量进行初始化顺序是**基类的静态变量先初始化**，然后是他的派生类。直到所有的静态变量都被初始化了。

##### 成员变量的初始化需要注意什么？

1. 类成员在定义时，是不能初始化的。
2. 类中const成员常量必须在构造函数初始化列表中初始化。
3. 类中static成员变量，必须在类外初始化。因为静态成员变量不与任何对象绑定。

##### 当一个类A为另一个类B的成员变量时，如何对其进行初始化？

如果类B中定义的构造函数有初始化列表，那么**必须使用初始化列表**才能构造对象A。

##### C++能设计实现一个不能被继承的类么？

能，不看

##### 构造函数没有返回值，那么如何得知对象是否构造成功？

因为构造函数没有返回值，所以通知对象的构造失败的唯一方法就是**在构造函数中抛出异常**。构造函数中抛出异常将导致对象的析构函数不被执行，而对象发生部分构造之后，已经构造完毕的子对象将会逆序地被析构。

##### Public继承、protected继承、private继承的区别？

公有继承、保护继承、私有继承是常见的三种继承方式。

1. 公有继承

   采用公有继承时，基类的公有成员和保护成员可见，维持原有的可见性，私有成员不可见，子类不可访问

2. 保护继承

   基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被他的派生类成员函数或友元访问。私有成员依旧是私有的。

3. 私有继承

   私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。

##### C++提供默认参数的函数么？

提供的。

1. 在函数声明或定义时，**直接对参数赋值**，这就是默认参数。
2. 在函数调用时，**省略部分或全部参数**，这是就是用默认参数来代替。

```c
void delay(int loops = 1000);//函数声明
```

#### 虚函数

##### 什么是虚函数？

指向基类的指针在操作他的派生类对象时，可以根据指向的不同类对象调用其相应的函数，这个函数就是虚函数。

1. 只需要在声明函数的类体中使用关键字virtual，定义函数不需要。
2. 基类成员函数声明为虚函数之后，派生类中的同名函数自动成为虚函数。
3. 非类函数、静态、全局、构造都不可以定义为虚函数。
4. 基类的析构函数需要定义为虚函数，否则造成内存泄漏。

##### C++如何实现多态？

之前提过太多次了，静态多态是函数重载，动态多态是虚函数表。

##### 纯虚函数指的是什么？

虚函数后边=0；不进行具体的定义。如果基类中有纯虚函数，子类中必须实现这个纯虚函数，否则子类无法实例化。

##### 什么函数不能声明为虚函数？

非类函数、静态函数、全局函数、构造函数、内联成员函数（字里行间展开了）、友元函数。

其中友元函数在C++中不支持继承。

##### C++中如何阻止一个类被实例化？

将类变成抽象类就无法实例化了。或者将构造函数声明为私有属性，就无法被实例化了。























### 三、ARM体系与架构

---

总算学到了这个了，本次二刷就是为了从这里开始将下面的内容重新写一遍一定很有乐趣

---

之前学野火视频的时候搞不懂学的是什么，总线、中断、寄存器等等给人的感觉就是介绍下芯片的功能，后来知道那款芯片是cortex-M3，去图书馆看到了ARM体系架构的书，出于好奇心看了下，从目录能看出来其实就是当初野火的视频。但是一直没有针对这部分进行复习，这次是一个很好地机会，好好学下。

#### 硬件基础

##### NAND FLASH和NOR FLASH异同？

都是flash闪存，nand在157那个板子上出现过我记得是和emmc并列的外存。flah是属于rom的，不可以随机访问。在tf-a中的bl2会初始四种外部flash分别是SD卡、EMMC/NAND/NOR这四种。但是并没有单独讲解各自的区别。

###### 不同点

| 类别            | NOR                                                          | NAND                                                         |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 读              | 快，像访问SRAM一样，可以随机访问任意地址的数据，这句话本身就意味着人家可以直接通过指针指向存储单元，这是**由地址总线**找到的。比如：unsigned short *pwAddr =(unsigned short *)0x02,unsigned short wval; wval = *pwAddr，反正这段代码就是直接通过地址指向内容的，我记得STM32的内存RAM就是SRAM组成的。而这个SRAM一般是寄存器的组成部分，寄存器存储最少访问速度最快，所以这个SRAM最贵 | 快，有严格的时序要求，需要通过一个函数才能读取数据，先发送读命令、发送地址、判断nandflash是否就绪、读取一页数据读命令、发送地址、判断状态、读数据都是通过操作寄存器实现的。这个其实在芯片手册中会提到凡是提供地址的，都是需要走**通信协议**来发送给指令到改地址上。所以这种nand其实就是类似e2prom一样，需要通过iic通信才能访问。其实为啥我们发送指令就可以实现具体的功能，是因为实现芯片已经烧写了固件，具体的函数已经烧写好了，这还是震哥当初讲的。 |
| 写              | 慢，**写之前需要擦除**，因为写只能是1->0，擦除可以使0->1。这个是由于其存储结构导致的特性。 | 快，但是写之前同样需要擦除，因为写只能是1->0，擦除才能从0->1，但是明明都需要擦除为啥这个快呢 |
| 擦除            | 非常慢5s                                                     | 快3ms                                                        |
| XIP（就地执行） | 代码可以**直接**在NORFLASH上运行                             | 不可以                                                       |
| 可靠性          | 比较高，**位反转**的比例小于NAND FLASH的10%                  | 比较低，**位反转比较常见**，必须有校验措施。位反转指的是存储单元中的位会进行01转换 |
|                 | 和RAM接口相同，**地址和数据总线分开**，毕竟随机访问就是地址总线决定的，必然有这些设备 | **IO接口**，毕竟我们就是通过IO口实现的通信                   |
| **可擦除次数**  | 10000-100000                                                 | 100000-1000000                                               |
| 容量            | **小**，1MB-32MB，因为每一个存储单元是由地址总线连接的，容量上限势必会受限制 | **大**，16MB-512MB                                           |
| 主要用途        | 常用于**保存代码和关键数据**，代码段保存代码和常量是因为这两种不会发生变化不需要初始化，这里的 | **用于保存数据**                                             |
|                 | 涉及到地址总线了必然价格**贵**                               | **低**                                                       |

BANK指的是存储库，内存会划分多个存储库，访问存储库的编号就可以，而这个编号占用地址总线的BA位，有两位就是四个存储库，其实这里的BANK其实就是将内存先划分为几个大部分，然后再依次继续划分。

而这里的nandflash和norflash的0地址是不冲突的，norflash占用了BANK地址，这里指的是占有了其BA位，而nandflash不占用BANK地址，他的0地址是内部的。这里的0地址指的是啥？（不理解）

###### 相同点

| 1    | 写之前都要先擦除，因为写操作只能使1->0，而擦除动作是为了把所有位都变12 |
| ---- | ------------------------------------------------------------ |
| 2    | 擦除是以块为单位                                             |

##### CPU/MPU/MCU/SOC/SOPC联系与差别？

这一问题真的是困扰了我太久了，除了最后一个其他的我都学过，但是始终无法准确说出来他们之间的关系。

1. CPU(central processing unit)是一台计算机的运算核心和控制核心。**CPU由运算器、控制器和寄存器及实现他们之间联系的数据、控制及状态的总线构成**。总线可不是计组中的输入输出（这个是冯诺依曼结构的，哈佛结构中是区分存储指令与数据的）。差不多所有的CPU的运作原理可分为四个阶段：提取、解码、执行和写回。（这涉及到几级流水线的问题，和处理器版本有关）CPU从存储器或缓存中取出指令，放入指令寄存器，并对指令译码，并执行指令。所谓的计算机的可编程性主要是指对CPU的编程。主存中的信息通过MDR发送给CPU，由CPU中的控制器中的指令寄存器进行译码，执行，将执行该指令所需要的数据的地址码发送给MAR有这个地址寄存器发送给地址译码器编译成十进制的片选线给主存拿数据。执行完毕后程序计数器PC会自动加一，从而得到新的地址。

2. MPU(micro processor unit)叫微处理器，并不是微控制器，通常代表一个功能强大的CPU，（怎么还是功能强大的CPU了呢），**但不是为任何已有的特定计算目的而设计的芯片**。这种芯片往往是个人计算机和高端工作站的核心CPU。其实指的就是我们的PC机。最常见的微处理器是motorola的68k系列和intel的x86系列。

3. MCU(micro control unit)叫微控制器，是指随着大规模集成电路的出现及其发展，**将计算机的CPU、RAM、ROM、定时计数器和多种IO接口集成在一片芯片上，形成芯片级的芯片**，比如51这些芯片，内部除了CPU外还有RAM,ROM,可以直接加简单的外围器件就可以运行代码了。比如STM32使用的都是内部flash和内部ram，而MPU比如x86、arm这些就不能直接放代码了，他只不过是增强版的CPU，所以需要添加外部RAM和ROM，157从这个角度来说，并不属于MPU，虽然跑操作系统但它是有内部rom、ram的。

   MCU和MPU最主要的区别是能否直接运行代码。MCU有内部的RAMROM，而MPU是增强版的CPU，需要添加外部RAMROM才能运行代码。

4. SOC(system on chip)，指的是片上系统，MCU只是芯片级的芯片，而SOC是系统级的芯片，既有像MCU那样的内置RAMROM，同时又向MPU那样强大的可以放系统级代码，**可以运行操作系统**，将MCU的集成化和MPU强处理力各优点合二为一了。但无论如何，mp157就是属于SOC的了。之前学的cortex是ARM公司的一个系列，而这个系列包括A、R、M三个分支。

5. SOPC(system on a programmable chip)可编程片上系统(FPGA就是其中一种)，之前的四点的硬件配置是固化的，也就是说51就是51不能变成别的，他们的硬件是一次性掩膜成型的，能改的就是软件配置，就是改代码。**而SOPC则是硬件、软件配置都可以修改**，软件配置跟上面一样，硬件可以自己构建，也就是说这个芯片是自己构造出来的！自己构造个芯片出来啊，这种芯片称为白片，什么芯片都不是，把硬件配置信息下载进去了，才是相应的芯片。可以是51，avr甚至是arm，同时SOPC是在SOC基础上的，所以也是系统级的芯片，变成ARM时还得加外围ROM/RAM，不然就是MPU了。这个ARM不能说是具体的某个，可以说MCU也可以是SOC。

##### 什么是交叉编译？

在一种计算机环境中运行的编译程序，能编译出在另外的一种环境下运行的代码，我们就称这种编译器支持交叉编译。这个编译过程就是交叉编译，**就是在一个平台上生成另一个平台上的可执行代码**。

这里需要注意的是所谓平台，实际上包含两个概念：体系结构(Architecture)/操作系统(operatingsystem)。确实啊，平台也分为软硬件的平台，之前项目是跨体系结构从x86到arm。常说的x86linux平台实际上是intelx86体系结构和Linuxforx86操作系统的统称，而x86winNT平台实际上是intelx86体系结构和windowsNTforx86操作系统的统称。

##### 为什么需要交叉编译？

因为目的平台上**不允许或者不能安**装我们所需要的编译器，而我们又需要这个编译器的某些特征；有时是因为目的平台上的资源贫乏，无法运行所需要的编译器，有时是因为目的平台还没有建立，连操作系统都没有，无法运行编译器。

##### 描述一下嵌入式基于ROM的运行方式和基于RAM的运行方式有什么区别？

我的理解就是rom不可以随机访问，掉电保护，而RAM可以随机访问但是掉电不保护一般debug的时候使用，而rom用来存储需要运行的代码和数据。

###### 基于RAM

1. 需要把硬盘和其他介质的代码先加载到ram中，加载过程中一般有**重定位**的操作。我理解的重定位是在加载系统过程中，因为不断的加入uboot、kernel等东西需要不断的将一些东西重新进行定位，这里也是这个意思吗。
2. 速度**比基于rom的快**，可用空间RAM比基于ROM的少，因为所有的代码，数据都必须存放在RAM中。而且RAM本身空间就小于ROM。

###### 基于ROM

1. 速度较基于RAM的慢，因为会有一个把变量，部分代码等从存储器搬移到RAM的过程，MCU就是基于ROM的，SOC有重定位这个过程是基于RAM的
2. 可用RAM资源比基于RAM的多。

#### ARM处理器

##### 什么是哈佛结构和冯诺依曼结构？

之前学的计组并没有区分两者，只是提了下冯诺依曼将指令和数据存放在一起，而缓存采用了哈佛的思想提出了dcache和icache，但是后来学内核的时候发现不是这么回事，实际上这里前者指的是目录项缓存后者是索引节点缓存。（丢人，就是数据cache和指令cache，一般是分开的）

###### 定义

冯诺依曼结构采用**指令和数据统一编址**，使用同条总线传输，CPU读取指令和数据的操作无法重叠。

哈佛结构采用指令和数据**独立编址**，使用**两条独立的总线**传输，CPU读取指令和数据的操作**可以重叠**。

###### 利弊

冯诺依曼结构主要用于通用计算机领域，需要对存储器中的代码和数据频繁的进行修改，**统一编址有利于节约资源**。

哈佛结构主要用于嵌入式计算机，程序固化在硬件中，**有较高的可靠性、运算速度和较大的吞吐。**嵌入式设备的软件在出厂前已经被固化在芯片上了，比如手机，我们直接通过上电就可以运行，只有使用特定的烧写工具才能进行修改。比如st-link

##### 什么是ARM流水线技术？

流水线技术通过**多个功能部件并行工作来缩短程序执行时间**，提高处理器核的效率和吞吐率，从而称为微处理器设计中最为重要的技术之一，**ARM7处理器核使用了典型三级流水线的冯诺依曼结构**，而**ARM9系列采用了基于五级流水线的哈佛结构**。通过增加流水线级数简化了流水线各级的逻辑，进一步提高了处理器的性能。因为哈佛结构导致指令和数据分开存储，这就导致流水线不容易发生冲突，可以并行工作。

PC代表程序计数器，流水线使用三个阶段，因此指令分为三个阶段执行：1、取指(从存储器装载一条指令)；2、译码(识别将要被执行的指令)；3、执行(处理指令并将结果写回寄存器)。而R15(PC)总是指向正在取指的指令，人们习惯将正在执行的指令作为参考点，称为当前第一条指令，根据下面的图可以知道，此时PC内的指令是正在取指的指令而这个指令已经是第三条指令了，就是因为三个阶段是同时进行的，此时第二条指令正在译码，第一条指令正在执行。

<img src="C:\Users\MACHENIKE\AppData\Roaming\Typora\typora-user-images\1675343425604.png" alt="1675343425604" style="zoom:25%;" />

可以看出来此时的F表示取指已经是第三条了，执行才是第一条。在ARM状态下（两种工作状态），每条指令是4字节，所以当前正在取指的地址是PC，而cpu正在执行的指令地址是PC-8，正在译码的地址是PC-4。而此时如果发生中断保存的是PC也就是第三条的指令，此时第一条指令正在执行，第二条指令并没有执行。所以此时恢复上下文的时候需要执行第二条指令，也就是SUB pc lr-irq #4(这里是说pc = lr_irq - 4，中断模式下的链接寄存器-4 = pc)，但是就是要执行PC-4的那条指令。(这里是减法，1r-irq减去立即数4然后将结果存入pc中)

##### ARM有几种工作模式和工作状态？

这个我记得有用户模式，特权模式，系统模式，，，好像是这样。

1. 用户模式USR

   用户模式是用户程序的工作模式，运行在操作系统的用户态，其实就是用户空间，没有权限去操作其他硬件资源，只能执行处理自己的数据，也不能切换到其他模式下，要想访问硬件资源或切换到其他模式只能通过软中断或产生异常。其实就是如何陷入内核态。

2. 系统模式SYS

   系统模式是特权模式，不受用户模式的限制，**用户模式和系统模式共用一套寄存器**，操作系统在该模式下可以方便的访问用户模式的寄存器，而且操作系统的一些特权任务可以使用这个模式访问一些受控的资源。

   用户模式与系统模式两者使用相同的寄存器（故共有一套堆栈），都没有SPSR，已保存程序状态寄存器，但系统模式比用户模式有更高的权限，可以访问所有系统资源。

3. 一般中断模式IRQ

   这些工作模式在驱动部分讲过，ARMv7-A工作模式，到ARMv8就没有工作模式了。

   一般中断模式也叫普通中断模式，**用于处理一般的中断请求**，通常在硬件产生中断信号之后自动进入该模式，该模式为特权模式，可以访问系统硬件资源。

4. 快速中断模式FIQ

   快速中断模式是相对一般中断模式而言的，**他是用来处理对时间要求比较紧急的中断请求**，主要用于高速数据传输及通道处理中。其实就是指向其特有的FIQ中断，快中断有许多R8-R14自己的专用寄存器，**发生中断时，使用自己的寄存器就避免了保存和恢复某些寄存器（其实也需要保存上下文、只不过硬件实现了，不需要软件主动保存）。**
   
5. 管理模式SVC

   管理模式是**CPU上电后默认模式**，因此，在该模式下主要用来**做系统的初始化**，软中断处理也在该模式下，当用户模式下的用户程序请求使用硬件资源时，通过软中断进入该模式。**系统复位、开机、软中断时进入SVC模式下**。

6. 终止模式ABT

   终止模式用于支持虚拟内存或存储器保护，当用户程序**访问非法地址**，没有权限读取的内存地址时，会进入该模式，Linux下编程经常出现的segment fault通常都是在该模式下抛出返回的。段错误会导致数据中止或者预取指中止。段错误属于总线错误

7. 未定义模式UND:

   未定义模式**用于支持硬件协处理器的软件仿真**，这里的协处理器我之前学过。用于减轻系统微处理器的特定处理任务。协助中央处理器完成其无法执行的工作。CPU在指令的译码阶段不能识别该指令操作时，会进入未定义模式。其实是遇到未定义或者不支持的指令

   其实还包括监控模式和超级监控模式，一共九种 。

   除了用户模式外，其他六种模式称为特权模式，所谓特权模式具有以下权利：

   - **MRS**(把状态寄存器的内容放到通用寄存器)这是ARM汇编，uboot源码大量涉及到。

   - **MSR**(把通用寄存器的内容放到状态寄存器)

     为啥这么复杂，是因为状态寄存器中的内容不能改变，需要先将内容复制到通用寄存器中，然后修改通用寄存器中的内容，再把通用寄存器的内容赋值给状态寄存器，即可完成修改状态寄存器的任务。

     剩下的六种除去系统模式外，统称为异常模式。毕竟irq/fiq/und/ABT/SVC都是发生中断、快速中断、未定义、访问非法地址、软中断导致的。

还有三种ARM工作状态：ARM状态支持32位指令、Thumb状态支持16位指令以及Jazelle支持八位指令，需要特定的软件支持：Java虚拟机cpsr对应的就是nzcvqiFt_USER

##### ARM有多少32位寄存器

   ARM处理器共有37个寄存器，包含31个通用寄存器和6个状态寄存器，系统调用号从用户态传入内核态就是通过寄存器实现的。（eax这个寄存器是x86架构下的，ARM下使用哪个寄存器不重要吧）

##### ARM2440和6410有什么区别？

这是两款非常老的ARM开发板，我不认为这里会考，没有了解的必要，但是还是写一遍吧。

| 区别           | ARM2440         | ARM6410                                             | STM32MP157                                                   |
| -------------- | --------------- | --------------------------------------------------- | ------------------------------------------------------------ |
| 主频不同       | 400M            | 533/667M                                            | 650M/209M                                                    |
| 处理器版本不同 | arm920T内核     | arm1176ZJF内核                                      | Cortex-A7/Cortex-M4                                          |
| 视频处理方面   | 弱              | 内部视频解码器、MPEG4等视频格式                     |                                                              |
| 硬解码和编码   |                 | 支持WMV9/xvid/mpeg4/h264                            |                                                              |
| 扩展接口       |                 | tv-out/CF卡和S-Video输出等                          |                                                              |
| 外设接口       |                 | spi/串口、sd接口                                    |                                                              |
| 内存控制器     | SDRAM内存控制器 | DDR内存控制器                                       |                                                              |
| 总线架构       |                 | 双总线架构，用于内存总线和FLASH总线                 |                                                              |
| 启动方式       |                 | SD/NANDFLASH/NorFlash/OneFlash                      | Flash设备启动、工程启动(调试M4内核代码)、第二内核启动、RMA、 |
| Flash架构      |                 | NandFlash支持SLC和MLC两种架构，从而大大扩大存储空间 |                                                              |
| 多路DMA通道    |                 | 具有8路DMA通道，包括LCD/UART/Camera等专用DMA通道    |                                                              |
| 图形加速       |                 | 支持2D和3D的图形加速                                | 3DGPU果然                                                    |

##### ARM指令集分为几类？

两类，分别为Thumb指令集和ARM指令集。ARM指令长度为32位，Thumb指令长度为16位。这种特点使得ARM既可以执行16位指令也可以执行32位指令。但是Thumb指令集只是ARM的一个压缩的子集不能自己独自支持。还有Jazelle指令集支持8位指令

##### 通用寄存器包括R0-R15，可以分为具体哪三类？

通用寄存器包括R0-R15，可以分为3类：

1. 未分组寄存器R0-R7

   在所有运行模式下，未分组寄存器都指向**同一个物理寄存器**，他们未被系统用作特殊的用途。因此在**中断或异常处理进行异常模式转换**时，由于不同的处理器运行模式均使用相同的物理寄存器，所以**可能造成寄存器中数据的破坏**。之前讲的那七中运行模式，其中有五种模式是异常模式。

2. 分组寄存器R8-R14

   对于分组寄存器，每次所访问的物理寄存器都与**当前的处理器运行模式相关**，一共有七个寄存器，可以理解为每次运行的都是各自的寄存器。

   R13常用作存放堆栈指针，用户也可以使用其他寄存器存放堆栈指针，但在Thumb指令集下，某些指令强制要求使用R13存放堆栈指针。

   R14称为链接寄存器LR，当执行子程序时，R14可得到R15也就是程序计数器PC的备份，执行完子程序后，又将R14的值复制回PC，也就是使用R14作为保存返回地址。

   R12是ip指针指向函数栈帧中的局部变量。

   R11是fp帧指针指向函数栈帧的最上方地址

   R10是SL堆栈限制指针，表示堆栈的最大限制，当sp小于sl时，也就是sp在sl下面时，产生下溢，栈溢出错误。

3. 程序计数器PC(R15)

   寄存器R15用作程序计数器PC，在ARM状态下，位[1:0]为0，位[31:2]用于保存PC；在Thumb状态下，位[0]为0，位[31:1]用于保存PC，这里的状态指的是指令集啊。

##### ARM处理器有几种工作状态？

这里要区分工作模式和工作状态，模式是七种模式，而状态是指令集。

从编程的角度来看，ARM微处理器的工作状态一般有ARM和Thumb两种，并且可在两种状态之间切换。

1. ARM状态：此时处理器执行32位的字对齐ARM指令，绝大部分工作在此状态。
2. Thumb状态：此时处理器执行16位的半字对齐的Thumb指令。
3. Jazelle状态：此处理器执行8位对齐的Jazelle指令。

##### ARM系统中，在函数调用的时候，参数是通过哪种方式传递的？

当参数小于等于4的时候是通过r0-r3寄存器来进行传递的，当参数大于4的时候是通过压栈方式进行传递。参数就通过寄存器或者栈来传递。如果浮点数运算，并且有硬件FPU浮点数运算单元，那么压栈的寄存器更多，

##### 为什么2440的内存起始地址是0x30000000?

因为2440处理器有**八个固定的内存块**，**只有两个是可以**作为ROM、SRAM和SDRAM等存储器bank的。这个bank就是存储库，库号会占用地址总线的BA两位。而这两个存储库的**起始地址是0x30000000**.

##### ARM协处理器指令包括哪三类，请描述他们的功能

ARM协处理器指令包括以下三类：

计组中讲过，协处理器就是通道，而通道是有自己的指令的。也就是这里的协处理器指令。

1. 用于**ARM处理器初始化** ARM协处理器的数据处理操作

2. 用于ARM处理器的**寄存器**和ARM协处理器的**寄存器**间的数据传送操作。

3. 用于ARM协处理器的**寄存器**与**内存单元**之间的数据传送操作。

   ----

   其实就是MCR和MRC两个指令，区别在于对协处理器的主寄存器和辅助寄存器的不同组合。具体功能比如配置MMU、cache、写缓冲器、MPU等。

   ---

##### 什么是PLL(锁相环)？

这个名词见过，但是从来没学过。这是电路部分了，输入时钟的存在是作为参考源。锁相环不是为了单纯产生同频同相的信号，这里的锁相指的就是相同的相位。一般**集成仅某种频率综合电路，产生一个不同频但锁相的信号**。

---

复习了裸机开发之后，PLL在时钟系统框图中出现，用于实现倍频的功能，将外部晶振实现x倍频，然后锁相环倍频时钟源作为系统时钟的输入源。

---

对于那些不同源的信号，会导致其相位漂移。而现实应用中很多都要求同源时钟。所以锁相环应用很广泛。

顾名思义，就是用**来使得不同源信号的相位相同的**。

#### 中断与异常

##### 中断与异常有何区别？

中断是指**外部硬件**产生的一个电信号从CPU的中断控制器进入，打断CPU的运行。

异常是指软件运行过程中发生了一些**必须做出处理的事件**,CPU自动产生一个陷入来打断CPU的运行。异常在处理的时候必须考虑与处理器的**时钟同步**因此，**异常也称为同步中断**。

##### 中断与DMA有何区别？

这里的DMA在计组和单片机开发中都遇到过，特点就是**不需要CPU的参与**就能实现外设与内存之间的信息传输。

DMA：是一种**无须CPU**的参与，就可以让**外设与系统内存**之间进行双向数据传输的硬件机制，使用DMA可以使得系统CPU从实际的IO数据传输过程中解脱，大大提高系统的吞吐率。

中断：是指CPU在执行程序的过程中，**出现了某些突发事件时**，CPU必须**暂停执行**当前的程序，转去处理突发事件，处理完毕后，CPU又返回被中断的位置继续执行。

所以中断和DMA的区别在于DMA不需要CPU的参与，而中断是需要CPU的参与的。

##### 中断能不能睡眠，为什么？下半部能不能睡眠？

这个问题其实是内核中讲解的，中断并不是CFS调度器调度的，所以也没有备选队列，如果中断睡眠了就会导致系统无法执行其他进程，下半部其实是属于中断运行后指定要执行的如果使用的是tasklet或者软中断的话，如果下半部是由工作队列实现的话，是允许睡眠的，这个工作队列实际上就是把下半部的工作交给一个内核线程去处理。所以是在进程上下文中执行的。

教程中讲解的是中断不能睡眠的原因，但是下半部并没有提到。

1. 中断处理的时候不应该发生进程切换，因为在中断上下文中，**唯一能打断当前中断handler的只有更高优先级的中断**，所以并不会被进程打断，如果在中断上下文中睡眠了，就没办法唤醒了。所有的wake_up_xxx**都是针对进程的**，而中断上下文中，没有进程的概念，没有一个task_struct进程控制块。
2. schedule在切换进程的时候，**会保存当前的进程上下文**（CPU寄存器的值，进程的状态以及堆栈中的内容），而中断发生后，内核会先保存当前被中断的进程上下文。如果在中断上下文中调用schedule的话会再次保存当前的进程上下文，这就导致保存错误了。
3. 2.4内核中schedule()函数本身在进来的时候**判断是否处于中断上下文**，所以断无可能在中断中调用调度器。
4. 中断handler会使用被中断的进程内核栈。但是！在2.6内核中中断拥有了自己的内核栈。
5. 处于中断上下文的时候，内核是不可抢占的，因此如果休眠，内核一定挂起。

##### 中断的响应执行流程是什么？

中断的响应流程：cpu接收中断信号、保存中断上下文、修改cpsr寄存器，跳转到中断处理例程、执行中断上半部、执行中断下半部、恢复中断上下文。

##### 当一个异常出现以后，ARM微处理器会执行哪几步操作？实际上是SWI指令的执行流程

1. 首先是**保存上下文**，需要将程序计数器PC的值存入LR连接寄存器中作为备份， 而此时PC的值是正在取指的指令。如果异常是从ARM状态进入，那么LR寄存器中保存的是**下一条指令的地址**（如果是三级流水线的话，应该是当前执行指令+8，也就是第三条指令，也就是正在取指的指令）；如果是从Thumb状态进入，则在LR寄存器中保存**当前PC的偏移量，**这样，异常处理程序就不需要确定异常是从何种状态进入的了。在软件中断异常SWI，指令MOV PC，R14_svc总是返回到下一条指令(就是管理模式下的LR寄存器)。
2. **将CPSR复制到相应的SPSR**(用户和系统模式下是有这个寄存器cpsr的，只不过用户模式只能读控制域、读写标志域)中。当前程序状态寄存器和保存的程序状态寄存器。这一步也是属于保存上下文，属于寄存器上下文，SPSR寄存器是FIQ模式才有的。
3. **强制PC存入向量表+0x8地址，从而跳转到相应的异常处理程序**。
4. **根据异常类型，强制设置CPSR的运行模式位**。就是[4:0]，软中断是USER->SVC
5. cpsr i = 1屏蔽IRQ中断。

##### 写一个中断服务需要注意哪些？如果中断产生之后要做比较多的事情该怎么办？

中断服务的时间不能过长，不能阻塞，睡眠 ，优先执行哪些优先级高的，执行快的任务，将其他的任务放到下半部执行。不要嵌套过多的中断，中断的专属内核栈对于32位机是8KB，64位机是14KB，

1. 写一个中断服务程序要注意**快进快出**，在中断服务程序里面尽量**快速采集信息**。然后退出中断，其他的事情使用**工作队列或者tasklet方式**，也就是中断下半部的实现方式。
2. 中断服务程序中**不能有阻塞操作**。因为中断期间是完全占用CPU的，中断被阻塞了，其他进程将无法操作，不存在内核调度。
3. 中断服务程序**注意返回值**，要用操作系统定义的宏作为返回值，而不是自己定义的。一般是两个，IRQ_HANDLED和IRQ_NONE后者是中断源并不是我们注册的中断引起的，前者是正确引起了。这是对于共享中断线的时候用到的。
4. 如果做的事情比较多，就把这些任务放到后半段处理。

##### 为什么FIQ比IRQ要快？

之前提到过，FIQ是有自己专属的寄存器的，这样保存上下文和恢复现场容易很多。

---

解惑了之前的一个问题：处理器的每个工作模式对应着各自的寄存器

banked寄存器指的是一个寄存器在不同的处理器运行模式下对应着不同的寄存器，进入各种模式后，会自动切换映射到各自的寄存器。其实就是编译器帮忙实现自动切换的。

---

1. ARM的FIQ模式提供了更多的banked寄存器，r8到r14这是分组的寄存器还有SPSR，而IRQ模式没有这么多，**R89101112**对应的banked寄存器就没有，这就意味着**需要中断处理程序自己去找通用寄存器或者在主存也就是栈中来保存R8-R12这几个寄存器**，**然后退出中断处理时程序还要恢复这几个寄存器**。

   相比之下FIQ模式有着自己的banked寄存器，所以模式切换的时候，CPU会自动保存这些值到banked寄存器，**退出FIQ模式时也会自动恢复**，所以这个过程FIQ比IRQ快。如果如果FIQ中断处理程序足够用这几个独立的寄存器来运作，**就不会进行通用寄存器的压栈了**，这样就会省了一些时间。这里的压栈就是用来传参的。

2. FIQ比IRQ有**更高优先级**，如果FIQ和IRQ同时产生，那么FIQ先处理。

3. 在symbian(塞班)系统中，当CPU处于FIQ模式处理FIQ中断的过程中，预取指令异常，未定义指令异常，软件中断全被禁止，所有的中断被屏蔽。所以**FIQ就会很快执行，不会被其他异常或者中断打断**，所以他又比IRQ块了。而IRQ不同，当ARM进入IRQ模式处理IRQ中断的时候，如果来一个FIQ中断请求，那正在执行的IRQ中断处理程序会被抢断，ARM切换到FIQ模式去执行这个FIQ，所以FIQ比IRQ快。

4. 另外FIQ的入口地址是0x1c，IRQ的入口地址是0x18.这里的入口地址是什么，是中断向量表的起始地址。**为了不与1C处的FIQ冲突，这个地方只能跳转**，不能放连续安正的中断向量表。但是FIQ不一样，1C以后没有任何中断向量表了，这样可以直接在1C处放FIQ的中断处理程序，这样至少**少了一条跳转指令**。（明白了，就是说0x1c这存放的是处理程序的地址，后面没东西的话，直接把函数实现放这里了）

##### 中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？

这个计组还是内核中提到过，对于那些低速设备比如IO设备都是中断，但是对于吞吐量大的用轮询。好像是多线程那部分。

中断是**CPU处于被动状态**下来接受设备的信息，而轮询是**CPU主动**去查询该设备是否有请求。

如果请求设备是一个频繁请求CPU的设备，或者有**大量数据**请求的网络设备，那么轮询的效率是比中断高。如果是一般设备，**请求的频率比较低**，用中断效率高一些。

#### 通信协议

这个通信协议啊，当年我都能把时序图画出来，232/485/8080/iic/spi/uart/uarst都用过了，，但是就是说不明白。

##### 什么是异步传输和同步传输？

这里问的并不是双工、半双工、单工。

异步传输：是一种典型的基于字节的输入输出，数据按**每次一个字节进行传输**，其传输速度低，比如串口这些都是。所谓的异步指的是**两个字节之间的时间间隔不确定**

同步传输：需要**外界的时钟信号**进行通信，是把数据字节 **组合起来一起发送**，这种组合称之为帧，其传输速度比异步传输快，比如USB通信、常见的无线通信都提到了帧这个概念。iic和spi的时序图就是这个。

##### RS232和RS485通讯接口有什么区别？

这两种都是用过，从代码上来讲就是使用的串口，485需要四根线，vcc、gnd、A/B。所以串口不需要时钟线！！异步传输。并且485是差分信号，这样信号传输才会更远更稳定。并且陀螺仪的modbus级联就是使用RS485实现的。

1. 传输方式不同。RS232采取**不平衡传输**方式，也就是单端通讯。一个参考端一个信号端组成，参考端接地。而RS485采用**平衡传输**，也就是差分传输方式。
2. 传输距离不同。RS232适合本地设备之间的通信，**传输距离一般不超过20m**，而**RS485的传输距离为几十米到上千米**。这里是放屁的，当初我也搜到了这个消息，然后我惊奇的发现淘宝上卖的线最长是3m。
3. 设备数量。RS232只允许**一对一通信**，而RS485接口在总线上是允许连接多达128个收发器。毕竟modbus的物理层就是使用485实现的了。
4. 连接方式。RS232规定用电平表示数据，因此线路是单线路的，用三根线才能达到全双工的目的。发送接收参考。而RS485使用差分电平表示数据，因此必须用两根线才能达到传输数据的基本要求，要实现全双工必须用六根线。但是这四根线我记得AB就是数据线的。A+A-B+B-vccgnd，而且还可以在总线上挂载128个从机，所以一般采用半双工即可。

总结：从某种意义上，可以说，**线路上存在的仅仅是电流，RS232/RS485规定了这些电流在什么样的线路上流动和流动的样式**。就是逻辑1和逻辑0对应的电平

---

SPI和UART在两个主控芯片通信时选择哪个

选择UART，因为串口通信是以码元为单位，码元中有起始位，数据位等多个位，针对不同芯片设置固定位的不同值实现区别不同的数据来源，相比之下spi发送以字节为单位，发送的内容一般是命令或者数据。

----

##### SPI协议

###### SPI的应用

SPI(Serial Peripheral Interface)协议是由摩托罗拉公司提出的通讯协议，**即串行外围设备接口**，**是一种高速全双工**的通信总线。SPI总线系统是一种同步串行外设接口，因为SPI也是有时序图的，需要根据外部时钟信号判断，所以是同步的。他可以使MCU与各种外围设备以串行方式进行通信以交换信息。SPI总线可直接与各个厂家生产的多种标准外围器件相连，包括FLASH、RAM、网络控制器、LCD显示驱动器、A/D转换器（比如：ad7606）和MCU等。

###### 接口

1. MOSI(Master Output,Slave Input)

   这是SPI的数据线，主设备输出、从设备输入，主机的数据从这条信号线输出，从机由这条信号线读入主机发送的数据，即这条线上数据的方向为主机到从机。

2. MISO(Master Input,Slave Output)

   主设备输入/从设备输出引脚，主机从这条信号线读入数据，从机的数据由这条信号线输出到主机，在这条线上数据的方向为从机到主机。

3. SCLK(Serial Clock)

   时钟线，之前说过SPI是一个同步通信，必然会用到时钟线来提供时钟信号。时钟信号线，用于通讯数据同步。他由通讯主机产生，决定了通讯的速率，不同的设备支持的最高时钟频率不一样（在硬件SPI中需要配置通讯时钟的频率）。比如STM32的SPI时钟频率最大为fpclk/2，两个设备之间通讯时，通讯速率受限于低速设备。

4. SS(Slave Select)

   从设备选择信号线，常称为片选信号线，也称为NSS/CS。当一个SPI总线上挂载多个设备的时候就需要使用片选线来决定通讯对象了。一般是拉低CS的时候认为是数据线的有效时间。当有多个SPI从设备与SPI主机相连时，设备的其他信号线SCK/MOSI以及MISO同时并联到相同的SPI总线上，也就是说无论有多少个从设备，都共同只使用这3条总线；而每个从设备都有独立的这一条NSS信号线。本信号线独占主机的一个引脚，即有多少个从设备，就有多少条片选信号线。

   这里与IIC协议就有一定的区别了，IIC协议也是可以挂载多个从设备到总线上的，但是IIC协议中通过设备地址来寻址、选中总线上的某个设备与其进行通讯。这里的设备地址并不是寄存器地址。而是独属于设备的地址。一般是先发送设备地址，然后等待从设备的应答，之后才是正是的通信。

   当主机选中从设备时，把该从设备的NSS信号线设置为低电平，该从设备被选中，即片选有效，接着主机开始与被选中的从设备进行SPI通信，当NSS信号线被拉高作为结束信号。

###### 协议层

其实就是介绍下时序图。SPI通信分为三线SPI和四线SPI，前者就是单工模式，后者是全双工。

 <img src="file:///C:\Users\MACHENIKE\AppData\Roaming\Tencent\Users\1056022510\QQ\WinTemp\RichOle\$07KTJV3B$@EEZ%Q@Y6_HNK.png" alt="img" style="zoom: 25%;" /> 

1. 通讯的起始和停止信号

   NSS信号线由高到低，是SPI通讯的起始信号。NSS信号线由低到高表示本次通讯结束。从机的选中状态被取消。

2. 数据有效性

   SPI使用MOSI及MISO信号线来传输数据，使用SCK时钟线进行数据同步。其实所谓的数据同步就是这里体现出来的。两个数据线在SCK的每个时钟周期传输一位数据，且数据输入输出是同时进行的。数据传输时，MSB先行还是LSB先行没有做硬性规定，（这个大小端模式很重要，在内核中经常能看到相应的宏，比如根据CPU决定）。要保证两个SPI通讯设备之间使用同样的协议，一般都采用上图中的MSB先行模式。

   MOSI以及MISO的数据在SCK的上升沿期间变化输出，在SCK的下降沿时被采样，即在**SCK的下降沿时刻**，两个数据线的数据有效，高电平时表示数据1，低电平是为0.其他时刻数据无效。这里在SCK的上升还是下降沿被采样是可以选择的。

   SPI每次数据传输可以八位或16位为单位，每次传输的单位数不受限制。每次传输的单位数不受限制，这里就被称为帧，对于异步通讯每次发送接收的数据只能是一个字节。。

3. CPOL(时钟极性)/CPHA(时钟相位)以及通讯模式

   就是在这里确定的**时钟上升/下降沿有效的**，同样在硬件SPI寄存器中需要设定，默认的话是下降沿有效。在Linux驱动中就是SPI控制器在内核驱动中设定的。

   上面讲述的图中的时序只是SPI中的其中一种通讯模式。SPI一共有四种通讯模式，主要区别是：**总线空闲时SCK的时钟状态**以及**数据采样时刻**。

   时钟极性CPOL是指SPI通讯设备处于空闲状态时，SCK信号线的电平信号也就是NSS为高电平的时候SCK的状态。CPOL=0时，SCK在空闲状态为低电平。

   时钟相位CPHA是指数据的采样的时刻，当CPHA=0时，MOSI或MISO数据线上的信号将会在SCK时钟线的**奇数边沿被采**样。其实就是上升沿还是下降沿。

##### IIC协议

这个协议的话需要两根线，半双工，芯片有设备地址。

###### 简介

IIC协议是由数据线SDA和时钟SCL构成的串行总线，可发送和接收数据，是一个多主机的**半双工通信方式**。

每个挂载在总线上的器件都有个**唯一的地址**。位速在标准模式下可到100kbit/s，在快速模式下可达到400kbit/s，在高速模式下可达到3.4Mbit/s

I2C总线系统结构其实和SPI的区别就在于只有两根线，并且所有的从设备都并联在这两根线上。并且两条线要接上拉电阻。

###### I2C时序介绍

1. 空闲状态

   当**总线上的SDA和SCL两条信号线同时处于高电平，便是空闲状态**，SPI是由时钟极性决定的。当不传输数据时，SDA和SCL被**上拉电阻拉高**，进入空闲状态。

   一般IIC更常用的是软件IIC也称为模拟IIC，通过程序模拟出数据线和时钟线组合的各种信号，包括起始信号、应答信号、非应答性、结束信号等。

2. 起始信号

   **当SCL为高电平期间，SDA由高到低的跳变，就是总线的启动信号**，**只能由主机发起**，且在空闲状态下才能启动。

3. 停止信号

   **当SCL为高电平期间，SDA由低到高的跳变**，便是总线的停止信号。之前确实没有观察过他们的电平变化，都是直接比对的程序上的输出变化。

4. 传输数据格式

   当发起了起始信号之后，就开始传输数据，（其实这里讲的还是简单了，还有一定的等待时间，这个不需要考虑的，要给硬件反应的时间）。

   当SCL为高电平时，开始读取数据了，SDA数据必须是稳定的，不然就是起始/停止信号了。

   当SCL为低电平时，SDA的电平可以进行变化

   ---

   SCL为高电平时，SDA读取数据，SCL低电平时SDA输出数据，这样就和启动、结束信号区分开了。

   ---

   如果主从机在传输数据期间，被其他进程打断了，**可以主动拉低SCL，使得IIC进入等待状态，直到处理结束再释放SCL，数据传输会继续。**这里之前并没有提到过，现在想想之前的项目做的太简略了，不仅仅之前可重入函数的问题，还有中断下的IIC通信，当初总是会随机出现一些雪花，数据乱码之类的问题，就是因为前后台这种存在异步通知导致的。

5. 应答信号ACK

   I2C总线上的数据都是以**8位数据**进行的，（并不意味着每次只能发送一个字节，这个也是同步通信的）。当发送了一个字节后，**发送方会在第9个时钟脉冲**期间**释放SDA数据**，（因为I2C是半双工通信，主从两方的数据都是通过SDA传输的，此时主机已经发送完毕了，接下来就应该是从机使用SDA了，所以需要规定时间来释放对SDA的控制）。

   当接收方接收该字节成功，便会输出一个ACK应答信号，**当SDA为高电平，表示为飞英达信号NACK**，**当SDA为低电平，表示为有效应答信号ACK**。

   PS：当主机为接收方时，**收到最后一个字节后**，**主机可以不发送ACK**，直接发送停止信号来结束传输，但是，**如果不是最后一个字节的话**，**还是要发送应答信号**的。

   当从机作为接收方时，如果没有发送ACK，就表示错误了，通讯不正常了，可能在忙其他事，或者不匹配地址信号和不支持多主机发送，此时主机发送停止信号 结束通讯，然后再次发送起始信号启动新的传输。

   所以这个应答/非应答信号很重要的。在程序中一定要接收到才能进行下一步。

6. 完整的数据传输

   为啥IIC会这么麻烦呢，相比于SPI，就是因为他有设备地址、半双工通信，导致SDA还需要交替方向，这就会牵扯到应答信号了。

   接下来讲下完整的数据传输

   **发送起始信号**后，发送一个八位的设备地址，其中**第八位是对设备的读写标志**，之后紧跟着就是**数据**了，直到**发送停止信号终止**。

   对于具体的时序图或者说信号顺序多种多样，其实这个主要是看芯片手册。如果第一次是读操作，想要换成写操作的话，直接发送起始信号，然后再发送读的设备地址。不需要停止信号便能实现不同的地址转换。

###### IIC传输数据的格式

1. 写操作

   刚开始主芯片要发出一个**start信号**，然后发出一个设备地址，最后一位**确定方向**。然后等待芯片发送**应答信号**（注意，发送设备地址之前是没有应答信号的，毕竟连从机还没有确定），之后就可以传输数据了。每发送一个字节就需要接收一个**回应信号**，然后再传输下一个字节。数据发送完之后，主机发送一个**停止信号**。

2. 读操作

   起始信号，设备地址，读，应答信号，数据，应答信号，数据，停止信号。

IIC的时序图就是四种信号相应的电平变化，以及写操作和读操作等完整的IIC通信流程信号的顺序。

#### 编程

##### 嵌入式编程中，什么是大端，什么是小端？

大端模式：低位字节存在高地址上，高位字节存在低地址上。

小端模式：高位字节存在高地址上，低位字节存在低地址上。

要注意这里的顺序是以字节为单位的，11 22 33 44 和44 33 22 11

STM32属于小端模式，比如0x1234在小端CPU内存中的存放方式。

| 内存地址 | 存放内容 |
| -------- | -------- |
| 0x4000   | 0x34     |
| 0x4001   | 0x12     |

#####  如何判断计算机处理器是大端还是小端？

首先了解下，结构体（联合体）二者的成员是**依次从低地址开始分配的**，

```c++
#include<stdio.h>
int checkCPU()
{
    union w
    {
        int a;
        char b;
    }c;
    c.a=1;
    return (c.b == 1);//联合体是同时只能有一个成员分配内存，这句话没错，但是此时a占用4字节，b占用1字节，联合体会提供四字节的内存，此时如果同时设置了ab的值，那么此时的a会被b占用一个字节，但是其他三个字节不变。此时的a是00 00 00 01，可以看到最低位的字节是01，而这个b应该是存放在最低位的地址上，此时b是01，说明最低位的地址存放在了最低位的地址上。所以这是小端模模式，b在哪哪里就是最低位，而a应该是0x 00 00 00 01，最左侧是高字节，右侧是低字节。我们从来都是只知道高字节和低字节，而不知道的是低地址在那头。所以所有判断大小端的方式实际上是寻找字节顺序的方式，联合体是所有成员共享内存地址，大家一起从低地址开始。指针截取是只截取低地址。
}
int main()
{
    if(checkCPU())
        printf("小端\n");
    else
        printf("大端\n");
    return 0;
}
```

结构体中的成员是根据他们的声明顺序，依次存放到内存地址中的，也就是说a的地址最大，b的地址最小。

联合体是同一时间只能有一个成员分配内存，所有的成员都是从同一个地址开始从小到大分配的。所以如果此时证明了成员中最低位的字节存放在了最低位的地址上，就是小端。

0x11223344，此时0x44就是最低位的字节，而此时赋值b = 0x55，那么此时联合体的最低位地址的字节变成了55，而a变成了x011223355，此时说明最低位的字节出现在了最低位的地址上。就是小端了，所谓的低地址是内存上的，低字节是我们看到的数据的最右端。

还可以通过指针地址来判断。

---

讨论下强制转换的结果

```c
//值转换
    double b = 22.11;
	int a = (int) b == 22;//这就是值转换，将小数去掉了，但是这并不是从内存角度出发的，而是从值出发的。
//指针转换
int *a = (int *)&b;//此时指针访问的类型从8字节变成了四字节，此时截断只保留低位地址。如果是0x1122334455667788,此时只保留0x55667788就说明是小端了。低位字节在地位地址上
```

----

```c++
#include<stdio.h>
int checkCPU()
{
    unsigned shorted a = 0x1122;
     char b  = ( char *)&a;
    return (b == 0x22);//利用指针截断只保留低位地址的内容
}
int main()
{
    if(checkCPU() == 1)
        printf("小端模式");
    else
        printf("大端模式");
    return 0;
}
```

##### 如何进行大小端的转换？

在Linux内核中有对应的转换宏。具有大小端相互转化的功能，还可以根据CPU本身所属大小端来进行转换。

这里是根据类型划分的多种大小端转换方式。不过这种转换并不是指定转换的，而是相互转换，因为无法预知传入的数据是大端还是小端模式。

```c++
int swapInt32(int intValue){
    int temp = 0;
    temp = ((intValue & 0x000000FF)<<24) | ((intValue & 0x0000FF00)<<8) | ((intValue & 0x00FF0000)>>8) | ((intValue & 0xFF000000)>>24) ;
    return temp;//这里就是将高位字节和低位字节调换了位置。int是四个字节
}
short swapShort32(short shortValue)
{
    short temp = 0;
    temp = ((shortValue & 0x00FF)<<8 | (shortValue & 0xFF00)>>8);
    return temp;
}
//float和double是浮点数类型，浮点数内部结构复杂，不能直接进行大小端转换。指南以及网上都是利用联合体的成员共享内存。这里直接将浮点数放到相同字节数的整数类型中，然后对整数进行大小端移动，最后再将整数赋值给浮点数成员。不过要注意的是相互赋值会发生类型转换。这里并不是指针强制转换，而是值类型转换，都是小数点。
typedef union {
    int i;
    float f;
}u;
float swapFloat(float floatValue)
{
    u U;
    U.i = floatValue;//值转化
    U.f = swapInt32(U.i);
    return U.f;
}//这种方法果然会导致小数部分被截断。而且以上的所有方法都没有考虑符号的问题

//接下来的double类型转换，我其实更倾向于使用之前的方式，转换成long然后利用union最后再变成double。
```

##### 如何对绝对地址0x100000赋值？

```c
//就是将这个地址转换成指针，然后解引用赋值
*(int *)0x100000 = 1234;
```

我其实更好奇所谓的绝对地址是什么意思。

##### 如果想让程序跳转到绝对地址是0x100000去执行，怎么做？

这里的跳转到地址是什么意思，汇编语言让存入R15中么？

这里的意思是将这个绝对地址变成一个函数的首地址，然后执行这个函数。

```c
//直接使用typedef声明一个函数指针的类型
typedef void (*)() funcp
    ((funcp) 0x100000)();//此时前面的括号内已经是一个函数指针了，或者说是一个函数地址，函数名称了，后面加一个后缀括号运算符表示这是一个函数了。指针这部分的代码都是错的。
```

这个ARM体系与架构部分，应该是我学的最不好的部分了，说明之前真的欠缺这方面的知识，仗着自己的单片机基础以为自己学会了，当初学UBOOT源码的时候就发现了，欠缺的不仅仅是计组、操作系统的理论，就是这个**ARM处理器**不懂，其他方面还可以都接触过。

### Linux驱动

今天正式完整的学完了笔试面试指南里知识点的其中一章。C/C++、数据结构、ARM体系与架构、Linux驱动、操作系统。这个ARM体系与架构真的是我所欠缺的知识，有必要的话，我还需要去看看ARM处理器相关书籍。

#### 指令

##### 常用的Linux指令

###### 怎么查看当前进程？怎么执行退出？怎么查看当前路径？

查看当前进程：ps，准确说这个是用来查看当前进程号的

怎么执行退出：exit，这个没用过，但是结束进程的话是kill -9 进程号，就是向该进程发送终止信号。

查看当前路径：pwd，这里看的是绝对路径

###### ls命令执行什么功能？可以带哪些参数？

这是列出指定目录中的文件以及目录。

参数

- -a显示所有文件以及目录（.开头的隐藏文件也会列出）
- -A显示除了隐藏文件以外的所有文件以及目录
- l除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出。
- -r将文件以相反次序显示（原定依英文字母次序）
- -t将文件依建立时间之先后次序列出
- -F在列出的文件名称后加对应的符号；
- -R若目录下有文件，则以下的文件也会依序列出

###### 创建目录用什么命令？

```c
/*mkdir runoob 在工作目录下，建立一个名为runoob的子目录
mkdir -p runoob2/test 在工作目录下，建立一个名为runoob2的子目录以及该目录下建立一个名为test的子目录，如果不加p，那么当 没有runoob2目录时会报错*/
```

###### 创建文件用什么命令？

vi/vim，这个命令会直接创建并打开一个文件file

touch，这是最常用的创建文件方式了

echo

```
echo "111">file3.txt   创建文件并将字符串写入，如果文件原本有数据，那么覆盖，如果文件不存在就创建文件，这个操作在IIO子系统中应用很频繁，当我们需要在应用层修改设定的时候，就是用echo直接把字符串写入
echo "111" >> file3.txt   这里是追加内容，而不是覆盖
```

less/more/cat

三者都是将文件内容输出到标准输出，这里的标准输出是屏幕，其中 less和more可以分页显示，cat是显示全部。之前看开机日志的时候就是使用的分页显示。

三者可以根据已经存在的文件创建新的文件，假设已经存在文件

```c
//其实就是将数据流从标准输出改成文件
cat 1.txt >2.txt
less 1.txt >2.txt
more 1.txt >2.txt
```

cd

cd也可以创建目录，这个主要的作用是切换目录， 但是如果在cd后面跟>或>>再加上文件名就可以创建一个内容为空的文件。和echo区别在于cd并不能写入文件

###### 复制文件用什么命令？

```
cp -r test/ newtest   将当前目录test/下的所有文件复制到心目里newtest下
```

###### 查看文件内容有哪些命令可以使用？

```
vi 文件名	编辑方式查看，可修改
cat 文件名	显示全部文件内容
vim 文件名	编辑软件的区别
more 文件名	分页显示文件内容
less 文件名	与more相似，更好的是可以往前翻页
tail 文件名	仅查看尾部，可以指定行数
head 文件名	仅查看头部，指定行数
```

###### 怎么向屏幕输出带空格的字符串，比如“hello world”？

```
echo hello world
//但如果是想要输出带有 连续的多个空格的字符串，比如"hello    world"
echo "hello    world"   带有双引号的话，其中的空格的\也会被解析显示出来
```

###### 移动文件用哪个命令？改名用哪个命令？

```
mv 文件名 文件名，这就是修改文件名了
mv 文件名 目录，这就是将文件移动到相应目录下
```

###### 删除文件用哪个命令？如果需要连目录以及目录下文件一块删除呢？删除空文件夹用什么命令？

```
rm -rf 这个命令什么都能删，都不需要确认
```

###### 查找文件内容够用哪个命令？

这个命令是很有用的不需要进入文件可以直接查找文件内容，我之前还没有使用过。

```
grep test *file    这里是查找当前目录中，，带有file后缀的文件，查看其中包含test字符串的文件，并打印出该字符串的行
grep -r update /etc/acpi    查找/etc/acpi目录下包括子目录下的所有文件，查看其中包含update字符串的文件
grep -v test *test* 查找文件名中包含test的文件中不包含test的文件
```

这个就是对grep命令的简单介绍

###### 查找文件用哪个命令？

```
find . -name "*.c"	将当前目录及其子目录下所有文件后缀为.c的文件列出来
find . -ctime -20	将当前目录 及其子目录下所有最近20天内更新过的文件列出
```

###### cat命令

```
cat -n textfile1	将文件的文档内容加上行号后输入到屏幕
cat -n textfile1 >textfile2		将文档1的内容加上行号后输入到文件2
cat -b textfile1 textfile2 >>textfile3		将文件1和文件2的文档内容加上行号（不包括空白行）之后追加到文件3中
cat /dev/null >/etc/test.txt		这里是将文件黑洞覆盖到文件中，其实就是清空文档内容
```

##### 常用的GCC命令

GCC编译器很重要的，这里面的命令应该好好学，这个指令学的我有点烦了。GCC是GNU编译器集合。gcc和g++只是驱动器，检测文件类型来调用对应的编译器。

###### 预处理

```
gcc -E test.c -o test.i  //把预处理的结果导出到test.i文件
```

###### 编译为汇编代码

```
gcc -S test.i -o test.s  //编译器将test.i翻译成汇编语言，并将结果存储在test.s文件中
```

###### 编译

```
gcc -c test.s -o test.o 	//将汇编代码编译为目标文件，但不链接
```

链接

```
gcc test.o -o test		//将生成的目标文件test.o链接成最终的可执行文件test
```

###### 一步到位编译

```
gcc test.c -o test		//将源文件test.c编译链接为可执行文件test
```

###### 多文件编译

```
gcc test1.c test2.c -o test		
```

###### 警告处理

```
gcc -w test.c -o test 	忽视编译时的警告
gcc -wall test.c -o test 	编译后显示所有警告
gcc -werror test.c -o test		在产生警告的地方停止编译
```

##### 常用的GDB调试指令
GDB就是用来监控程序的执行流程

```
gcc -g test.c -o test	编译时生成debug有关的程序信息
gdb test	启动调试
help	查看命令帮助，具体命令查询在gdb中输入help+命令
run		重新开始运行文件（run -text：加载文本文件，run -bin：加载二进制文件）
start	单步执行，运行程序，停在第一执行语句
list	查看原代码，list -n，从第n行开始查看代码。list+函数名：查看具体函数
set		设置变量的值，这个GDB真的好强大
next	单步调试，逐过程，函数直接执行，不进入函数内部
step	单步调试，逐语句，跳入自定义函数内部执行，这个GDB和debug好像
backtrace	查看函数的调用的栈帧和层级关系
frame	切换函数的栈帧，这个栈帧指的是函数的调用记录，保存在栈上
info 	查看函数内部局部变量的数值
finish	结束当前函数，返回到函数调用点
continue	继续执行
print	打印值及地址
quit	退出gdb
break+num	在第num行设置断点
info breakpoints num	删除第num个断点
display	追踪查看具体 变量值
undisplay	取消追踪查看变量
watch	被设置观察点的变量发生修改时，打印显示
i watch		显示观察点
enable breakpoints	启用断点
disable breakpoints	禁用断点
x	查看内存
run argv[1] argv[2]	调试时命令行传参
set follow-fork-mode child	makefile项目管理：选择跟踪父子进程
```
简单试了试这个GDB，类似于一个基于shell的小软件，和模拟串口有点像。感觉不太好用

#####  常用的驱动开发指令
######  加载/卸载驱动

```
insmod/modprobe 	加载驱动，这里前者是不会生成依赖的，在正点的出厂系统中，因为依赖已经生成了，所以不能使用modprobe
rmmod		卸载驱动
```

######  Linux驱动如何查看驱动模块中打印信息？
```
dmesg，这个指令我用过，因为当初把驱动模块自动添加到内核中了，所以驱动模块中打印的信息出现在开机日志中了。
```
######  如何查看内核中已有的字符设备的信息？
lsmod和modprobe，lsmod可以查看模块的依赖关系，modprobe在加载模块时会加载其他依赖的模块，所以出厂系统不能使用这个指令
######  如何查看正在使用的中断号？
```
cat /proc/interrupt		这里明明很常用，我却有点陌生了，这个目录是用来查看申请的中断号
/proc/irq	这个目录中是用来查看中断触发的次数的，
```
####  uboot

#####  什么是bootloader?

Linux系统要启动就必须需要一个bootloader程序，也就是说系统上电以后先运行一段bootloader程序。**这段bootloader程序会先初始化时钟，看门狗，中断，SDRAM**等外设，uboot有自己的设备树，以及自己的指令，这些都需要串口才能打印出来。必然会初始化一部分外设。
然后将Linux内核从flash(NAND,NOR,FLASH,SD,MMC等)拷贝到SDRAM中，最后启动Linux内核。NAND是通过协议通信的有io接口，而NOR是直接地址数据总线连接，可以做到随机访问，并且数据稳定不会发生电位反转，所以价格贵，但是内存小。
类似于PC上的BIOS和Windows的关系一样，bootloader就相当于BIOS。**总的来说，bootloader就是一小段程序，他在系统上电时开始执行，初始化硬件设备、准备好软件环境，最后调用操作系统内核。**

----

单片机启动方式中的ISP是在系统启动，实际上就是由厂家固化一个bootloader到内部rom中，地址是0x0~0x1fff ffff，具体工作是决定程序装载地址以及修改向量表VTOR，跳转到用户程序的向量表。从这个角度来说单片机的bootloader和uboot很接近，只不过不具备uboot的命令行功能、并且应该是无法初始化硬件。

----

##### uboot如何加快启动效率？

 Uboot优化：删除部分命令；禁止启动延迟；禁止内核镜像校验；修改内核镜像加载方式；优化U盘升级文件扫描时间 。最后一个看不懂。

##### uboot启动过程中做了那些事？

###### 第一阶段

初始化时钟，关闭快看门狗，关中断，启动ICACHE，关闭DCACHE和TLB，关闭MMU，初始化SDRAM，初始化NAND FLASH，重定位。

###### 第二阶段

初始化一个串口，检测系统内存映射，将内核映像从flash上读到SDRAM空间中，为内核设置启动参数，调用内核。

----

这个八股真的是牛逼啊，分析下，使能、禁用硬件是reset函数实现的，然后重定位。第二阶段就是启动内核了，说白了就是载入内核映像，并为内核设置启动参数，启动内核。没毛病，八股真的神了。

---

##### uboot和内核如何完成参数传递？

uboot启动后已经完成了基本的硬件初始化比如内存、串口等，接下来主要任务就是加载Linux内核到开发板的内存，然后跳转到Linux内核所在的地址运行。

在uboot倒计时结束后启动内核，执行do_bootm_state中的第六阶段BOOTM_STATE_PREP会解析bootargs以及设置内核启动参数r0r1r2。

**PS：只要问到uboot，面试官必问uboot和内核的参数传递！**

具体是如何跳转的？，**直接修改PC寄存器的值为Linux内核所在的地址**，这样CPU就会从Linux内核所在的地址去取指令，从而执行内核代码。合理，PC程序计数器R15本来就是取指令阶段的指令。

在跳转到内核之前，uboot需要做好以下三件事情：

1. CPU寄存器的设置

   之前传入的三个参数分别传入到R0/R1/R2三个寄存器中。指的是内核的地址，给设备树的兼容值，如果不使用设备树的话，就是传递机器ID。第一个参数是0，第二个参数是机器ID，第三个参数是ATAGS用来传递一些命令行信息，或者是设备数DTB的首地址。这里的ATAGS指的是一种格式。

   R0 = 0;

   R1 = 机器类型ID；或者设备数的compation兼容值，用来匹配Linux是否支持该机器，从而决定是否启动，机器类型ID参见linux/arch/arm/tools/mach-types

   R2 = 启动参数标记列表在RAM中起始基地址。这里指的就是**设备树的首地址**。凡是驱动模块都需要先由内核匹配设备树。或者是**bootcmd环境参数**

2. CPU工作模式

   必须禁止中断（IRQS和FIRQ）凡是中断都是需要切换工作模式的。

3. Cache和MMU的设置

   MMU必须关闭。（此时页表还没有创建，虚实映射没建立，不能开启MMU，uboot是使用物理地址）

   指令CACHE可以关闭也可以打开

   数据Cache必须关闭

##### 为什么要给内核传递参数？

移植内核之前，uboot已经完成了硬件的初始化，可以说已经适应了这块开发板，然而，内核并不是对于所有的开发板都能完美适配的。此时，内核对于开发板的环境一无所知。所以，要想启动Linux内核，uboot必须要给内核传递一些必要的信息来**告诉内核当前所处的环境**

##### 如何给内核传递参数？

uboot把**机器ID通过R1传递给内核**，Linux内核运行时，首先从R1中读取机器ID来判断是否支持当前机器。这个机器ID实际上就是**开发板CPU的ID**，如果内核支持设备树的话，芯片的信息写在设备树中了，此时读取设备树即可。每个厂家生产出一款CPU的时候都会给他指定一个唯一的ID。通常是由处理器的协处理器的专用寄存器保存。

R2**存放的是块内存的基地址**，这块内存中存放的是uboot给Linux内核的其他参数。之前uboot定义在bootargs环境参数中了，这些参数有：**内存的起始地址、内存大小、Linux内核启动后挂载文件系统的方式等信息。**或者存放的是设备树的起始地址。而这里参数有多个，不同的参数有不同的内容，为了让Linux内核能精确的解析出这些参数双方在传递参数的时候要求参数在存放的时候需要**按照双方规定的格式存放**。

**除了约定好参数存放的地址外，还要规定参数的结构**。Linux2.4以后的内核都期望以**标记列表**(tagged_list)的形式来传递启动参数。标记列表就是挨着存放的多个标记。标记列表以标记ATAG_CORE开始，以标记ATAG_NONE结束。这里的tag我当初在内核中并没有学到。这应该是不太常用的内核数据结构。

标记的数据结构为tag，它由tag_header结构和一个联合体union组成。tag_header结构表示标记的类型及长度，比如是表示内存还是表示命令行参数等。对于不同类型的标记使用不同的联合，比如表示内存时使用tag_mem32，表示命令行时使用tag_cmdline。每种类型的信息都需要一个tag表示。union每次只存在一个成员的特点就是用在这里。

可以看出，struct_tag结构体由structtag_header+联合体union构成，结构体structtag_header用来描述每个tag的头部信息，比如tag的类型，tag大小。联合体 union用来描述每个传递给Linux内核的参数信息。

这种包含头部信息的方式很熟悉，uboot好像也有这种操作。

##### 为什么uboot要关掉caches?

cache是由cp15协处理器负责管理，刚开始还没有初始化cache所以禁用。

##### 为什么uboot必须关闭Dcache，而Icache可关？

因为此时MMU被禁用，无法判断哪些内存是可cache的，比如外设区域被缓存了会导致cache和内存数据不一致问题。而Icache是缓存指令的，指令风险较低。

#### 文件系统

##### 什么是根文件系统？

根文件系统首先是一种文件系统，该文件系统不仅具有普通文件系统的存储数据文件的功能，相对于普通的文件系统，他的特殊之处在于，他是**内核启动是所mount挂载的第一个文件系统，内核的映像文件保存在根文件系统中。**系统引导启动程序会在根文件系统挂载之后从中把一些**初始化脚本**（rcS、inittab）**和服务**加载到内存中去运行，这里面包含了Linux系统能够运行**所必需的应用程序、库**等比如：可以提供操作Linux的控制界面shelll程序、动态连接的程序运行时需要的glibc库。甚至之前讲过的Linux指令其实都是一个个文件保存在根文件系统中。

文件系统和内核是完全独立的两个部分，毕竟内核空间不大，在内核空间中的系统调用所使用的的C语言都不是标准库，而是GNU C版本。

如果只有内核是无法真正的启动Linux操作系统的，会出现无法加载文件系统的错误。其实是内核无法找到根文件系统，内核惊恐

##### 根文件系统为什么这么重要？

**如果没有这个根文件系统，其他的文件系统也就没有办法进行加载。**根文件系统包含系统启动时所必须的**目录和关键性文件**，以及使得其他文件系统成功挂载所必要的文件。比如

- **init进程的应用程序必须运行在根文件系统上**。这个进程是第一个进程
- 根文件系统提供了根目录“/”
- Linux挂载分区时所依赖的信息存放于跟文件系统/etc/fstab这个文件中。
- shell命令程序必须运行在根文件系统上，比如cd、ls等命令。

##### 可执行映射文件通常由几部分构成，他们有什么特点？

- 一个或多个代码段，代码段的属性为只读
- 零个或多个包含初始化数据的数据段，数据段可读写
- 零个或多个不包含初始化数据的数据段可读写

回顾下虚拟内存的分布

- bss段：未初始化的全局和静态变量包括被初始化为零的变量
- 代码段：存放机器代码和字符串常量。只读存储区
- 数据段：存放初始化的全局和静态变量
- 堆区：手动释放，内存碎片
- 栈区：自动变量，函数返回值，函数地址，函数参数，以及寄存器的值，保护现场
- 文件映射段：动态链接库和mmap映射过来的文件

#### 中断

##### 硬中断/软中断是什么？有什么区别？

###### 硬中断

1. 硬中断是由**硬件产生**的，**每个设备或者设备集都有他自己的IRQ中断请求**。基于中断请求，CPU将相应的请求分发到对应的硬件驱动上。
2. 处理中断的程序是需要运行在CPU上的，因此，当中断产生的时候，CPU会中断当前正在运行的任务，来处理中断。一般一个中断只能中断一颗CPU。
3. **硬中断可以直接中断CPU。**中断代码本身也可以被其他的中断打断。
4. 对于时钟中断，他的存在是为了让调度代码可以调度多任务。

###### 软中断

这里指的软中断指的其实是中断下半部，并不是异常这样的同步中断。

1. 软中断的处理非常像硬中断。**他们是由当前正在运行的进程**产生的。其实是中断服务程序执行完之后交给内核线程调用中断下半部。
2. 通常软中断是一些对I/O的请求。对于某些设备，IO请求需要被立即处理，而**磁盘IO请求通常可以排队并可以稍后处理**。
3. 软中断仅仅与内核相联系。
4. **软中断并不会直接中断CPU**，只有当前正在运行的代码才会产生软中断。事实上软中断的产生就是因为频繁的中断CPU会导致 性能降低，对于软中断而言 会延迟一段时间之后再执行。这种中断是一种需要内核为正在运行的进程去做一些事情的请求。（换句话说软中断并不会打断进程）

###### 区别

1. 软中断是**执行中断指令产生**的，硬中断是由外设引起的。就是汇编指令+中断号引起相关的软中断。（这里还是有歧义，软中断是由中断上半部标记从而触发)
2. 硬终端的中断号是由**中断控制器提供**（果然没错，就是由NVIC提供，中断号是计算出偏移再+向量表基地址）的，软中断的中断号**由指令直接指出**，无需使用中断控制器。异常是必须要处理的错误，而软中断是需要配合当前进程做的操作。
3. 硬中断是**可屏蔽**的（所谓的中断优先级就是通过屏蔽实现的），软中断不可屏蔽
4. 硬中断处理程序要确保他能快速地完成任务，这样程序不会等待太长的时间，称为上半部。
5. 软中断处理硬中断未完成的工作。是一种推后执行的机制，属于下半部。

##### 中断为什么要区分上半部和下半部？

这是因为**中断频繁会导致CPU的性能下降**，为此将那些着急处理的任务放到上半部，讲那些可以延迟执行的任务放到下半部。ksoftirqd看名字就能看出来，这是内核软中断，保证在软中断频繁的时候其他进程也不会饥饿，会唤醒ksoftirqd线程来处理这些负载，这些线程在最低的优先级上运行。

Linux中断分为硬件中断和内部中断，调用过程：**外部中断产生**->**发送到中断控制器查看是否屏蔽**->**通知处理器产生中断的中断号**（就是我们驱动模块中申请的中断号，软中断的中断号是编译的时候就确定了）

**为了中断处理过程中被新的中断打断**，将中断处理一分为二，上半部登记新的中断，快速处理简单的任务，剩余复杂耗时的处理留给下半部处理。下半部处理过程中可以被中断，上半部处理时不可被中断。

##### 中断下半部一般如何实现？

软中断、tasklet、工作队列。详细版看Linux内核笔记吧。

##### Linux中断的响应执行流程？中断的申请及何时执行？

中断的响应流程：**CPU接受中断->保存中断上下文->切换处理器模式->跳转到中断处理例程->执行中断上半部->执行中断下半部->恢复中断上下文**

中断的申请request_irq的正确位置：**在硬件告知中断控制器之前**。也就是说在产生中断信号之前。

#### Linux驱动模型

本节内容，重在理解，面试的时候如果面试官让我挑一个熟悉的驱动讲的话毫无疑问了，IIO框架，无论是难度还是熟悉程度都是它了。

##### 驱动初始化

驱动初始化中涉及到一个设备描述结构的概念。在任何一种驱动模型中，设备都会用内核中的一种结构来描述。字符设备在内核中使用struct cdev这种结构来描述。

```c
struct cdev
{
    struct kobject kobj;//这是设备描述中的最重要的结构体，实现了对象层次化，kobjcet就是sysfs的一个目录项
    struct module *owner;//本模块的拥有者
    const struct file_operations *ops;//设备操作集。
    struct list_head list;//这是链表。内核的链表结构很神奇，list节点，但是这个节点内部只有上下节点的指针，并没有数据。每次插入删除节点的时候只需要传入list_head类型节点即可。数据存放在包含链表的父结构中。保证在链表类型统一的同时可以给每个节点不同的数据类型。这里就是让cdev变成了链表节点的父结构。
    dev_t dev;//设备号。
    unsigned int count;//设备数量
}
```

count表明该类型设备的数目。我说这个结构体成员怎么一点印象都没有呢，cdev结构体并不是我们自定义的，是内核结构体，没有给这个成员初始化的话，内核会自动初始化为默认值的。

dev是设备号，包含有主设备号和次设备号。主设备号用来区分设备的类型，次设备号用来标记相同类型的设备的不同个体。

dev_t实质是32位的unsigned int。其中高12位是主设备号，低20位是次设备号。经常使用的是动态分配设备号，也就是通过内核API来向内核申请设备号。

1. 知道主设备号和次设备号，可通过dev_t dev = MKDEV(主设备号，次设备号)获得设备号；其实这里就是合并成一个设备号。
2. 从设备号中分解出主设备号：主设备号 = MAJOR(dev_t dev)
3. 从设备号分解出次设备号：次设备号 = MINOR(dev_t dev)

主设备号是一个重要的资源，可以通过静态申请和动态分配为设备分配一个主设备号：

1. 静态申请：开发者自己选择一个数字作为主设备号，然后通过函数register_chrdev_region向内核申请使用。缺点就是如果选择的数字已经被内核中的其他驱动使用了，就会导致申请失败。
2. 动态分配：使用alloc_chrdev_region由内核分配一个可用的主设备号。不会分配到已经被使用的号。

设备号是一种资源，设备驱动模块卸载的时候都应该释放该资源。使用unregister_chrdev_region函数释放这些设备号。

ops是操作函数集。file_operations是一个很重要的结构，该结构的成员基本都是函数指针，并且是文件操作的函数的指针。当注册ops之后，本来系统调用是由VFS提供的通用函数，这里相当于将其中一部分通用函数覆盖成我们编写的了，这样在应用APP调用标准库函数或者系统调用的时候就可以执行我们注册的函数了。

struct file_operations是一个函数指针的集合，定义能在设备上进行的操作。结构中的函数指针指向驱动中的函数，这些函数实现一个针对设备的操作，对于不支持的操作设置函数指针为NULL。

该结构体表示应用程序能够对设备文件使用函数，当执行到函数的时候，内核根据该结构体转移到驱动程序中注册的函数去执行。

驱动初始化有四大步骤：

1. 分配

   cdev变量的定义可以采用静态和动态两种办法：

   这里其实常用的是动态分配，IIO并没有申请设备号。静态分配：struct cdev mdev;动态分配：struct cdev *pdev = cdev_alloc();

2. 初始化
    struct cdev的初始化使用cdev_init函数来完成。

  原型：

  ```c
  cdev_init(struct cdev*cdev,const struct file_operations *fops)
  ```

  cdev：待初始化的cdev结构

  fops：设备对应的操作函数集。

  其实看到这个就能明白。所谓的初始化指的是对cdev结构体中的ops进行初始化。

3. 注册

   字符设备的注册使用cdev_add函数来完成。

   这个注册应该是在cdev成员都初始化了之后才进行了。

   原型：

   ```c
   cdev_add(struct cdev *p,dev_t dev,unsigned count)
   ```

   参数：

   p：待添加到内核的字符设备结构

   dev：设备号

   count：该类设备的设备个数。想起来了，设备个数经常定义成宏，所以才没印象的。

4. 硬件初始化

   根据相应硬件的数据手册完成初始化，其实这里可以分为好多种，如果可以使用设备树的话就将设备信息写到设备树中，然后调用设备树中的节点。配合gpio子系统和pinctrl子系统，其实现实中常用的是gpiod子系统。
##### 实现设备操作

由struct file_operations可以看出，要实现的操作并不少。

```c
int (*open)(struct inode *,struct file*)//打开设备，响应open系统调用，这里涉及到两种结构体
```

   inode是索引节点对象，这是对文件的控制信息文件的描述。而file是由open创建，close销毁，是已打开文件在内存上的描述。

file结构体的重要成员有：

```c
loff_t f_ops;//文件读写指针
struct file_operations *f_ops;//该文件所对应的操作
```

每一个存在于文件系统里面的文件都会关联一个inode结构体，该结构主要用来记录文件物理上的信息。他和代表打开文件的file结构是不同的。一个文件没有被打开的时候不会关联file结构，但是却会关联一个inode结构。该结构体有重要的成员：

```c
dev_t i_rdev//设备号，学内核的时候并没有讲解这些对象结构体的内部
```

一个设备支持的函数操作称为设备方法。

open设备方法是驱动程序用来为以后的操作完成初始化准备工作的。完成如下工作：表明次设备号，启动设备。但其实代码上是将file的结构体中的private data成员进行赋值。将我们自己创建的设备结构体赋值给他。当然这个设备结构体中包括设备号和cdev。想起来了，有意思的是当这个open是空的也没事。应该是内核会默认初始化。也可以在这里添加初始化芯片的函数，因为应用层访问驱动模块首先就是open函数。

release设备方法的作用与open相反，这个设备方法也称为close，完成的工作是关闭设备。

read设备方法通常完成两件事情：从设备中读取数据，将读取到的数据返回给应用程序，这个函数很常用，驱动模块中的read函数是用来读取采集到的数据，然后将数据返回给应用层，使用的是copy_to_user函数。

```c
ssize_t (*read)(struct file *filp,char __user *buff,size_t count,loff_t *offp)//这里的参数其实是从应用层传下来的，buff就是返回给应用层的数据缓冲区。需要通过copy_to_user函数将数据填充到数据缓冲区中。
```

filp：与字符设备文件关联的file结构体指针，在调用open函数的时候返回值就是文件描述符，然后将fd传入read函数中。其实就是这个file结构体。

buff：从设备读取到的数据，需要保存到的位置，由read系统调用提供该参数。因为buff参数是来源于用户空间的指针，这类指针都不能被内核代码直接引用，必须使用专门的参数。

count：请求传输的数据量，由read系统调用提供该参数，其实就是要读取的字节数。

offp：文件的读写位置，由内核从file结构中取出后，传递进来。但是这个参数一般是用不上的。

```c
int copy_to_user(void __user *to,const void *from,int n)
int copy_from_user(void *to,const void __user *from,int n)
```

write设备方法通常完成两件事情：从应用程序提供的地址中取出数据，将数据写入设备。

```c
ssize_t(*write)(struct file*,const char __user *,size_t loff_t*)
```

##### 驱动注销

驱动注销：当我们从内核中卸载驱动程序的时候，需要使用cdev_del函数来完成字符设备的注销。

这里介绍的字符设备驱动模型有一种浅尝即止的感觉。我到时候看Linux驱动笔记复习一下驱动框架。

#### LCD驱动模型

当初学的时候LCD这一章就是很难的，驱动框架我记得是编译进内核驱动了。所以学的水一些，正好在这里复习下。

写个LCD驱动入口函数，需要以下四步：

1. 分配一个fb_info结构体：framebuffer_alloc();
2. 设置fb_info
3. 设置硬件相关的操作
4. 使能LCD，并注册fb_info：register_framebuffer()

需要用到的函数：之前的驱动学习中只是提了下DRM的内核驱动框架，并没有具体的API。

```c
void *dma_alloc_writecombine(struct device *dev,size_t size,dma_addr_t *handle,gfp_t gfp);//之前GPU涉及到了共享内存来实现进程间通信，这样保证快速的填充显存。
//返回值为：申请到的DMA缓冲区的虚拟地址，如果为NULL表示分配失败，需要使用dma_free_writecombine()释放内存，避免内存泄漏。
//*dev指针，这个很常见了，经常把设备结构体中的device用来赋值，这里填0，，？表示申请的缓冲区里没有内容。
//size：分配的地址大小（字节单元）
//handle：一般来说这个单词表示的是回调函数，但是这里表示的是申请到的物理起始地址。
//gfp：这是分配出来的内存参数，分为行为修饰符、区修饰符、类型标志，其中类型标志是前两者的组合。行为是使用特定的方法分配内存，区修饰符表示从哪分配内存。
//提下区：由于硬件的限制，内核并不能对所有的页一视同仁。所以内核将页分为了不同的区zone，
//ZONE_DMA：包含的页都是用来执行DMA操作的
//ZONE_DMA32：这些页面只能被32位设备访问。
//ZONE_NORMAL：这个区包含的都是能正常映射的页
//ZONE_HIGHEM：包含高端内存，其中的页并不能永久的映射到内核地址空间中。
//之前学到的存储区BANK，将内存分成了多个区，并且占据了地址总线的BA位。不过内核中说这种区是逻辑结构，并没有实际物理意义。
```

分配一段DMA缓冲区，分配出来的内存会禁止cache缓存（因为DMA传输不需要CPU）他和dma_alloc_coherent()函数相似，不过dma_alloc_coherent()函数是分配出来的内存会禁止cache缓存以及禁止写入缓冲区。

```c
dma_free_writecombine(dev,size,cpu_addr,handle);//这里的cpu_addr是虚拟地址，而handle是物理地址。为啥虚实地址都写出来
```

接下来介绍操控FB的函数。FB框架是比DRM更古老的框架。framebuffer表示的是帧缓冲，可以理解为是图片的缓冲区，下面的fb指的应该是用来描述帧缓冲的输入输出的结构体

```c
struct fb_info *framebuffer_alloc(size_t size,struct device *dev);//申请一个fb_info结构体，size：额外的内存，*dev：指针，这里依旧是填0也就是不初始化这个结构体。
int register_framebuffer(struct fb_info *fb_info);//向内核中注册fb_info结构体，如果内存不够，注册失败返回负数。
int unregister_framebuffer(struct fb_info *fb_info);//注销内核中的fb_info结构体
```

对于这个fb_info结构体，驱动中提到了一嘴，是在介绍使用设备树之前是如何保存设备信息的。

接下来介绍下fb_info结构体：

感觉没啥用的东西，直接跳过

最后在驱动init入口函数中：

1. 分配一个fb_info结构体
2. 设置这个fb_info
   1. 设置固定的参数fb_info->fix，id,lcd的名字
   2. 设置可变的参数fb_info->var，一行的像素点
   3. 设置操作函数fb_info->fbops
   4. 设置fb_info其他的成员。
3. 设置硬件相关的操作

我实在是写不下去了，，，

#### 总线设备驱动模型

将设备信息写到设备树中，每次需要调用的时候与设备树节点进行匹配，从而实现总线、驱动、设备三者的分离。总线是为了实现设备信息与驱动分离。设备树是为了降低内核中的冗余设备信息。

之前其实对于总线、控制器还有点分不清楚，其实很简单总线，控制器，设备这是一个模型，总线是虚拟总线，控制器是驱动。然后是总线、驱动、设备。这里的总线是SPI，驱动是SPI总线上的具体的挂载芯片，设备就是使用的除了SPI通信用到的引脚以外的其他引脚。

自从内核2.6版本开始，需要关注的是总线、设备和驱动这三个实体，总线将设备和驱动绑定。在Linux内核系统中注册一个设备/驱动的时候，会寻找与之对应驱动进行匹配；

在Linux设备中有太多的是没有对应的物理总线，SPI/IIC这些都属于物理总线，可以挂载多个设备的。**为了适配Linux的总线模型，内核针对这种没有物理总线的设备开发了一种虚拟总线--platform总线。**

将设备和驱动独立开，驱动尽可能写的通用，当来了一个类似的设备以后也可以使用这个驱动，让驱动程序可以重用。这体现了Linux驱动的软件架构设计的思想。

按照这个思路，Linux中的设备和驱动都需要挂载在一种总线上，**eeprom作为设备，eeprom的驱动都挂载在iic驱动上。**但是在嵌入式系统中，**soc系统一般都会集成独立的iic控制器，**（这里所谓的控制器，是因为我们使用硬件iic，这需要配置寄存器，而这部分是通用的，所以提取公因式，控制器也需要匹配设备信息的，最终是提供给驱动一个通用的通信接口）。**控制器也是需要驱动的，但是无法按照设备-总线-驱动模型进行设计，因为无法找到一个合适总线去挂载控制器设备和控制器驱动。**

iic控制器是挂载在cpu内部的总线上，而不是iic总线上。所以Linux发明了一种虚拟总线，**称为platform总线，相应地设备称为platform_device(控制器设备)，对应的驱动称为platform_driver(控制器驱动)，用platform总线来承载这些相对特殊的系统。**

这个虚拟总线并不具备物理意义，实现的功能也仅仅是将设备与驱动匹配到一起。。

**所谓的platform_device并不是与字符设备、块设备和网络设备并列的概念，而是Linux系统提供的一种附加手段。**

控制器归纳为platform_device，**本身就是字符设备**。**platform驱动只是在字符设备驱动外套一层platform_driver的外壳**

引入platform模型会带来一些便利。

设备驱动中引入platform概念，隔离BSP(板级支持包)和驱动，在BSP中定义platform设备和设备使用的资源、设备的具体匹配信息，而在驱动中，只需要通过API去获取资源和数据，做到板相关代码和驱动代码的分离，使得驱动具有更好的可扩展性和跨平台性。

分析下总线设备驱动模型的匹配过程

device_add()函数除了将device结构体放到bus总线的dev链表之外，还会**从另一边的drv链表中取某个driver结构**，用总线里的一个函数指针（.match）来进行比较，看一下另一边的driver是否支持device。如果支持的话，就调用软件驱动部分的.probe函数。（这个过程其实之前看总线的时候看到过）

driver_register函数会将bus_drv_dev模型中较稳定代码driver结构体放到虚拟总线的drv链表中。**从另一边的dev链表**中取出每一个device结构用bus中的.match函数来做比较，如果支持则调用.probe函数。

这两个方向谁先谁后呢，我们一般都是手动加载驱动模块的，所以第一种方向，如果把驱动模块加入到内核的话，就是第二种了。

在.probe函数中做的事情有自己决定，这个probe函数需要注册到platform驱动结构体中，然后将驱动结构体的注册函数作为函数入口。其实probe函数本身就是入口函数，一般在这里进行模块的初始化。

#### 输入子系统模型

这个输入子系统模型是专门用来输入的，比如按键输入，虽然我们可以不使用输入子系统，而是自己编写。但是输入子系统的功能很强大，比如可以添加时间戳给每一个信息。还可以上报事件。

输入子系统分为三层，分别是驱动层，核心层，事件层。

驱动层：输入设备的具体驱动程序，以及向核心层上报输入事件。

核心层：承上启下，为驱动层提供输入设备注册和操作接口，通知事件层对输入事件进行处理。

事件层：主要和用户空间进行交互。

每个硬件都有一个input_dev结构体，每个软件都有一个input_handler结构体。input_dev和input_handler分别通过input_register_device()、input_register_handler()向核心层注册硬件和软件。

前者input_dev需要在驱动模块中申请结构体，然后向核心层注册。注册函数如下：

```c
int input_register_device(struct input_dev *dev)//这里的dev就是我们注册并初始化的驱动设备结构体
{
    list_add_tail(&dev->node,&input_dev_list);//这个就是内核中操作链表的API了，表示插入到链表尾部。表示向指定链表的input_dev_list节点前插入node结构体。将输入设备结构体插入到链表之后，开始遍历对应的事件处理链表。
    list_for_each_entry(handler,&input_handler_list,node)//handler表示包含链表节点的父结构，&input_handler_list表示要遍历的链表的链表头，该链表在父结构handler中作为成员存在，成员名称是node。
    input_attach_handler(dev,handler);//这里是将输入设备结构体和处理捆绑着一起，软件和硬件结合
}
```

从input_dev方向分析：input设备在增加到input_dev_list链表上之后，会查找input_handler_list事件处理链表上的handler进行匹配，**这里的匹配方式与总线设备驱动模型的device与driver匹配过程相似。**不过input子系统中的是输入设备与对应的事件处理相匹配。与总线不发生关系。也不存在设备与驱动的概念。

所有的input_device都挂在input_dev_list上，所有类型的事件都挂在input_handler_list上，进行匹配，如果匹配上了，就调用input_handler的connect函数进行连接。设备就是在此时注册的。因为输入设备input_dev需要和对应的事件处理一起注册到核心层，所以只有在调用iput_attach_handler函数之后才可以。

从input_handler方向分析：将handler挂到链表input_handler_list下，然后遍历input_dev_list链表，查找并匹配输入设备对应的事件处理层，如果匹配行了，就调用connect函数进行连接，并创建input_handle结构。这个才是真正的注册设备结构体。

这么来看并不是所谓的驱动层->核心层->事件处理层，而是驱动层与事件处理层并行的，然后才是核心层将驱动和处理的结构体合并成一个input_handle结构，所谓的事件处理层与用户空间对应指的应该是事件处理会把信息传递到用户空间中。

所以，不管新添加input_dev还是input_handler都会进入input_attach_handler()判断两者id是否有支持，若两者支持便进行连接。

##### platform总线的匹配规则是什么？在具体应用上要不要先注册驱动再注册设备？有先后顺序没？

这里的匹配规则就是对比两者的compatible，如果匹配成功了就直接执行probe了。这个先后顺序没有研究过，不过应该是先注册设备，因为在内核启动的时候就会访问设备树，然后就注册设备了，等到我们手动注册驱动的时候再匹配。

---

总线，设备，驱动。匹配规则就是当有一个新的设备挂起时，总线被唤醒，match函数被调用，这里的device名字进行匹配，是在不使用设备树情况下，自己创建设备信息的文件。关于设备与驱动的匹配方式有四种：

1. OF类型的匹配，这个OF前缀的API都是访问设备树节点的，of_driver_match_device函数，device_driver结构体表示设备驱动，其中就有一个名为**of_match_table**的成员变量，此成员变量保存着驱动的compatible匹配表，设备树中的每个设备节点的compatible属性会和of_match_table表中的所有成员比较，查看是否有相同的条目，如果有的话probe函数了。
2. 第二种是ACPI匹配方式，没学过
3. 第三种是id_table匹配，这种页不常用
4. 第四种是直接比较驱动和设备的name字段，如果相等就匹配成功。这里的name是在不使用设备树，而是自己编写一个设备信息文件的时候用到的。内核驱动常用这种匹配方式。

注册的platform平台驱动结构体里面就有name成员和of_match_table，分别对应这第四种和第一种匹配方式。

---

指南中介绍的就是第四种方式。用device名字区跟本总线下的所有驱动名字去比较。相反就是用驱动的名字去device链表中与所有device的名字比较。如果匹配上了，才会调用驱动中的probe函数（这个函数也是注册到platform平台的设备驱动结构体）。

先后顺序，指南和我都是同样的理解不会有影响该，不管谁先谁后，bus都会完成匹配工作。

##### 谈谈对Linux设备驱动模型的认识

设备模型分为字符设备、块设备驱动、网络 设备驱动三种，字符设备应用最广泛，一般都采用总线、设备、驱动三者模型。从而实现内核中的冗余信息最小化。可以变成驱动模块在系统启动以后手动挂载到内核上。也可以编译成内核驱动，系统启动时自动挂载。无论哪种驱动模块都是在内核空间下工作的。所以驱动模块开发者必须对Linux内核有一定的了解会用到很多的内核数据结构以及同步方式，而虚拟文件系统也会把驱动模块中的属性显示给应用层，所以还要对应用空间有一定的了解。驱动开发者编写的驱动模块要尽可能的利用内核中现有的资源去最大限度使用芯片性能。

设备与驱动分离很好的奠定了热插拔机制，比如：插入键盘。在插入之后才会挂载相应的驱动模块，其实这本身就是设备与驱动的匹配。

#### Linux内核

##### 内核镜像格式有几种？分别有什么区别？

内核压缩以GNUzip也就是gzip和bzip2两种形式发布。bzip2在压缩上更具有优势。

内核镜像格式的话，我记得有Image/uImage/zImage。这和包含头部信息有关。（一说头部信息就让我想起了tag数据结构由结构体+联合体组成的，结构体在低地址位，就是用来表示头部信息的，联合体中有很多类型的成员，头部信息要求是什么显示该成员）。

uImage是157使用的，zImage是阿尔法使用的。Image好像就是没有添加头部信息的镜像吧。

1. uboot经过编译直接生成的elf格式的可执行程序是u-boot。这个只能烧录进emmc中启动，不能通过网络启动，因为不算tf-a的话，uboot才是第一个初始化诸多硬件的引导程序，比如时钟、串口、SDRAM等。这个程序类似于windows下的exe格式，**在操作系统下是可以直接执行的**。**但是这种格式不能用来烧录下载**，当前开发板的环境无法让uboot直接执行。只能通过烧录下载。

   用来烧录下载的是u-boot.bin，这个东西是由u-boot使用arm-linux-objcopy工具进行加工的。157使用的是arm-none-linux-gnueabihf-objcopy工具将ELF格式的uboot文件生成的u-boot-nodtb.bin文件，这个是不加设备树的二进制文件。

   这个镜像就是用来烧录到Nand中执行的。不过157还没有结束。实际上烧写到板子上的是u-boot.stm32文件，**这个文件是在u-boot.bin加上头部信息256B生成的**。需要u-boot.stm32.cmd文件完成。

2. Linux内核经过编译后也会生成一个elf格式的可执行文件，叫做vmlinux/vmlinuz，**这个就是原始的未经任何处理加工的原版内核elf文件**。嵌入式系统部署时烧录的也不是这个，是用objcopy工具制作成烧写镜像格式，不过不加bin后缀。经过制作加工的文件叫做Image，把78M大小的精简到7.5M。**因此这个制作烧录镜像主要目的就是缩减大小，节省磁盘。**正点提供的vmlinux是260M，删减后是19MB

3. 生成Image文件，其实就是取消了vmlinux中的其他信息，这是没经过压缩的。原则上Image是可以直接被烧录到Flahs上进行启动执行的。但是Linux的作者们觉得Image还是太大了所以对Image进行了压缩，并且在Image压缩后的文件的前端附加了**一部分解压缩代码**，构成了一个压缩格式的镜像就叫**zImage**，这里是通过**gzip**压缩的(GNU zip)，当年Image大小刚好比一章软盘大，为了节省一张软盘的钱才设计了这种压缩Image成zImage的技术。

4. uboot为了启动Linux内核，发明了一种内核格式叫**uImage**。uImage是由zImage加工得到的，uboot中有一个工具，可以将zImage加工生成uImage。注意：**uImage与Linux内核无关了**，Linux内核最终只得到zIamge。然后uboot中的**mkimage**工具将zImage加工生成uImage来给uboot启动。**这个加工过程其实就是在zImage前面加上64字节的uImage的头信息。**

5. 原则上uboot启动时应该给他uImage格式的内核镜像，但是实际上uboot中也可以支持zImage，是否支持就看x210_sd.h中是否定义了LINUX_ZIMAGE_MAGIC这个宏。所以有些uboot是支持zImage启动的，有些不支持，但是**所有的uboot都支持uImage启动**。

6. 如果直接在kernel目录执行make uImage，会提供mkimage command not found。解决方案是去uboot/tools下cp mkimage /usr/local/bin/，复制mkimage工具到系统目录下，再去make uImage即可。应该是找不到工具了 。毕竟和内核没有关系了，所以在内核源码目录下找不到。

如果通过uboot启动内核，Linux最好是uImage格式。

##### 内核中申请内存有哪几个函数？有什么区别？

###### kmalloc

```c
void *kmalloc(size_t size,gfp_t flags)//后一个参数刚复习完，有行为修饰符、区修饰符和类型标志三种。
```

kmalloc是内核中最常用的一种内存分配方式，他通过调用kmem_cache_alloc函数来实现。kmalloc一次最多能够申请的内存大小由include/linux/kmalloc_size.h的内容来决定，在默认的2.6.18内核版本中，kmalloc**最多一次能申请128KB字节的连续物理内存。**乐鑫的笔试问了如果申请大于128KB的连续物理内存会不会导致缺页中断。

###### vmalloc

```c
void *vmalloc(unsigned long size)
```

上一种kmalloc函数虽然分配的内存有限，但是它分配的内存在虚拟地址和物理地址上都是连续的，大多数情况下，只有硬件设备需要得到连续的物理地址内存，因为硬件设备存在于内存管理单元之外。所以硬件设备用到的任何内存区都是物理上连续的块。

vmalloc分配的往往是虚拟地址连续，但是物理地址分散的内存。vmalloc通过分配非连续的物理内存块，再修改页表，把内存映射到逻辑地址空间的连续区域中。很多的内核代码其实都用kmalloc()来获得内存。主要是出于性能的考虑，vmalloc函数为了把物理上不连续的页转化为虚拟地址空间上连续的页，必须专门建立页表项，通过vmalloc获得的页必须一个一个的映射，这导致了比直接内存映射大得多的**TLB抖动**。就是频繁的对快表中的页表项进行换入换出。因为这些原因vmalloc只有在不得已的时候使用，比如模块被动态的插入到内核中时。

----

前面介绍的kmalloc内存分配方式是物理连续的，能保证较低的平均访问时间。毕竟不需要专门建立页表项、一一映射、TLB抖动了。但是某些场合中，对内存区的请求不是很频繁，较高的内存访问时间也可以接受，比如驱动模块加载到内核。这就可以分配一段虚拟地址连续、物理地址不连续的内存。好处就是**一次可以分配较大块的内存**。vmalloc对一次能分配的内存大小没有明确限制。出于性能考虑，避免较高的内存访问时间，应谨慎使用vmalloc函数。最大能一次分配1GB的空间。

###### dma_alloc_coherent

这个函数还是之前讲LCD驱动框架的时候提到的，这是为了与外部存储器使用DMA通信分配的内存。这个内存是**禁止cache缓存禁止写入缓冲区**。因为DMA不需要CPU的参与，所以这部分内存不需要保存到cache中。（指的是禁止cache、以及写缓冲器）

```c
void *dma_alloc_coherent(struct device* dev,size_t size,ma_addr_t *dma_handle,gfp_t gfp);
```

DMA是一种硬件机制，允许外围设备与主存之间直接传输IO数据，而不需要CPU的参与，使用DMA机制能大幅提高与设备通信的的吞吐量。DMA操作中，涉及到CPU高速缓存和对应的内存数据一致性问题。必须保证两者的数据一致。乐鑫笔试提到了cache的一致性问题。（这里的高速缓存指的是slab分配器，因为DMA内存禁止cache，所以和cpu的cache无关）

###### alloc_pages

```c
struct page* alloc_pages(gfp_t gfp_mask,unsigned int order)//最核心的函数，分配2^order次幂个连续的物理页，并返回第一个页的page结构体。这也是分配高端内存的时候采用这个，因为虚实映射非永久，这里返回页的结构正合适。内核空间非永久分配是因为内核空间有限。
```

###### __get_free_pages

```c
unsigned long __get_free_pages(gfp_t gfp_mask,unsigned int order)//这个函数与alloc_pages作用相同，不过返回的是第一个页的逻辑地址，就是编号
```

dma_alloc_coherent和**get_free_pages函数实现差别不大，前者调用的是alloc_pages函数**，因此一次分配内存的大小限制和后者一样。__get _free _pages分配的内存同样可以用于DMA操作。

###### ioremap

```c
void *ioremap(unsigned long offset,unsigned long size)
```

ioremap是一种更加直接的内存分配方式，**这个函数用于指针的虚实转换**。我们**提供物理起始地址和需要分配的内存大小，然后将该段物理地址映射到内核地址空间**。与之前的几种内存分配方式不同之处在于**用到的物理地址是事先确定的**。并不是分配一段新的物理内存。ioremap多用于设备驱动，而且是不使用设备树+gpio子系统+pinctrl子系统，自己查找需要的寄存器地址，然后手动转换成虚拟指针。

##### 什么是内核空间，用户空间？

---

对于32位操作系统而言，他的寻址空间 (虚拟地址空间，或者叫做线性地址空间)为4GB，(32位操作系统的地址总线是32位，所以能延伸到的存储单元是2^32字节)。也就是说一个进程的最大地址空间为4GB。

操作系统的核心是内核kernel，它独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证内核的安全，**现在的操作系统一般都强制用户进程不能直接操作内核。**具体的实现方式基本都是由**操作系统将虚拟地址空间划分为两部分。**一部分为内核空间，一部分为用户空间。针对Linux操作系统而言，**最高的1GB**(从虚拟地址0xc0000000到0xffffffff)由内核使用，**称为内核空间**。而**较低的3GB**(从虚拟地址0x00000000到0xBFFFFFFF)由各个用户空间下的进程使用，**称为用户空间**。

也可以这么理解：

每个进程的4G地址空间中，最高1GB都是一样的，也就是内核空间，剩下3GB才归进程自己使用。**最高1GB的内核空间是被所有进程共享的**。内核空间的虚实映射也就是页表项是多进程共享的，因为进程切换的时候如果前后指令地址映射关系不一致会导致问题，这也是进程切换在内核空间的原因。

<img src="C:\Users\MACHENIKE\AppData\Roaming\Typora\typora-user-images\1675865622434.png" alt="1675865622434" style="zoom: 25%;" />

##### 为什么需要区分内核空间与用户空间？

这里就是为了系统安全考虑的。

在CPU的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃，**比如清内存、设置时钟等**。如果允许所有的程序都可以使用这些指令，那么系统崩溃的概率将大大增加。

所以，CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通应用程序只能使用那些不会造成灾难的指令。比如Intel的CPU将特权登记分为4个级别：Ring0~Ring3。

而Linux系统只使用了Ring0和Ring3两个运行级别。当**进程运行在R3级别时被称为运行在用户态**，而**运行在Ring0级别时被称为运行在内核态**。是处理器工作模式不同以及页表项的权限位不同导致的。

其实就是为了系统安全考虑以及处理器模式不同而带来的不同权限。

----

##### 用户态切换到内核态做什么？

所谓的进程运行到内核态，之前处理器为用户模式，并且使用用户空间下的进程栈保存上下文，现在切换成SVC模式，使用内核空间中的内核栈保存上下文。所以要做的事情首先从进程描述符中获得内核栈指针，将当前用户模式下的进程栈指针保存，保存被暂停执行的程序的下一条指令。执行内核态的程序。

----

##### 什么是内核态和用户态？

当进程运行在内核空间时就处于内核态，当进程运行在用户空间则处于用户态。

在内核态下，进程运行在内核地址空间中，此时CPU可以执行任何指令（也就是处于Ring0级别），运行的代码也不受任何的限制，可以自由地访问任何有效地址，也可以直接进行端口的访问。

在用户态下，进程运行在用户地址空间中，被执行的代码要受到CPU的诸多检查，他们只能访问映射其地址空间的页表项中**规定的在用户态下可访问页面的虚拟地址**，只能对**任务状态段(TSS)中IO许可位图(I/O Permission Bitmap)中规定的可访问端口**进行直接访问。如果进程访问无效地址，会发生什么，段错误，访问的虚拟地址没有建立虚实映射或者该页被填充为错误，访问权限问题导致的数据中止和预取指中止。

---

其实我对于端口一直没学过，这应该就是一个物理接口吧，理解为外设。上面这段太绕了，还有这个任务状态段到底是什么意思。

TSS是内存中的一个结构体而已。这个和处理器架构好像有点关系，也许学完ARM之后才能知道

---

对于以前的DOS操作系统来说，是没有内核空间、用户空间以及内核态、用户态这些概念的。可以认为所有的代码都是运行在内核态的，因而，用户编写的应用程序代码可以很容易的让操作系统崩溃掉。

对于Linux来说，通过区分内核空间和用户空间的设计，**隔离了操作系统代码**（操作系统代码比应用程序代码健壮很多）**与应用程序代码**，即便是单个应用程序出现错误，也不会影响到操作系统的稳定性，这样其他的程序还可以正常的运行(Linux可是多任务系统)。所以，**区分内核空间和用户空间本质上是要提高操作系统的稳定性及可用性。**

##### 用户空间与内核通信方式有哪些？

其实要说的话用户空间与驱动模块的通信也算的，copy_to_user和copy_from_user两种。使用虚拟文件系统VFS让用户空间看到在内核中的属性并且可以操作。软中断从用户空间陷入到内核空间。

1. 使用API

   ```c
   get_user(x,ptr);//在内核中被调用，获取用户空间指定地址的数值并保存到内核变量x中。在内核中用到过get_user_pages函数
   put_user(x,ptr);//在内核中被调用，将内核空间的变量x的数值保存到用户空间指定地址处。
   Copy_from_user()/Copy_to_user();//驱动设备读写函数中，通过系统调用read触发。
   ```

2. 使用proc文件系统

   这个主要使用的是proc/irq和proc/interrupt两个目录，前者提供了中断被使用的次数，后者提供了中断号。和sysfs文件系统类似，也可以作为啮合空间和用户空间交互的手段。/proc文件系统是一种虚拟文件系统，通过它可以作为一种Linux内核空间和用户空间的通信接口。与普通文件不同，这里的虚拟文件的内容都是动态创建的，因为proc文件系统并不存在于外存，只在内存中存在。

   使用/proc文件系统的方式很简单。调用create_proc_entry，返回一个proc_dir_entry指针，然后去填充这个指针指向的结构。实际上我我都是直接访问 目录的。

3. 使用sysfs文件系统+kobject

   复习了下内核中对这二者的解释，sysfs也是一个虚拟文件系统，专门用来描述kobject的，kobject是设备驱动中的最重要的结构体。sysfs提供了kobject对象层次结构的视图，便于用户观察系统中各种设备的拓扑结构。

   每个在内核中注册的kobjcet都对应着sysfs系统中的一个目录，可以通过读取根目录下的sys目录中的文件来获得相应的信息。除了sysfs文件系统和proc文件系统外，其他的虚拟文件系统也可以达到这个效果。sysfs是在proc基础上实现的，所以要优于proc，但是proc已经根深蒂固了，所以保留下来了。

   ---

   介绍下，虚拟文件系统。

   虚拟文件系统并不是真正的文件系统，因为不同存储介质需要不同的访问方式，所以针对他们设计了文件系统，这些文件系统保存在外存中，内核为了可以统一接口访问不同的文件系统，设计了虚拟文件系统，这些虚拟文件系统处于文件系统和用户空间之间。提供给用户空间统一的访问接口。并且提供给用户空间观察内核属性的接口。

   虚拟文件系统是文件系统的抽象层。

   ---

4. netlink

   内核提到了一嘴，但是我没学，netlink是一个传送网络信息的多点传送套接字。

   ----

   netlink socket提供了一组类似于BSD风格的API，用于用户态和内核态的IPC。原来套接字是用来实现内核态与用户态之间通讯的。相比于其他的用户态和内核态IPC机制，netlink有几个好处：

   1. 使用自定义的一种协议完成数据交换。不需要添加一个文件。

   2. 可以支持多点传送

   3. 支持内核先发起会话

   4. 异步通信，支持缓存机制。

5. 文件

   应该说这是一种比较笨拙的做法，不过确实可以这样用。当处于内核空间的时候，直接操作文件，将想要传递的信息写入文件，然后用户空间可以读取这个文件便得到想要的数据。比如设备节点
   
6. 使用mmap系统调用
   
   可以将内核空间的地址映射到用户空间。一方面可以在driver中修改struct file_operations结构中的mmap函数指针（这个确实存在，和read并列的，但是我一直没有使用过。）来重新实现一个文件对应的映射操作。指的是在驱动模块中定义mmap函数，，
   
   另一方面，也可以直接打开/dev/mem文件，把物理内存中的某一页映射到进程空间中的地址上。
   
   还可以重写ioctl等实现内核空间和用户空间通信的方式，其实指的就是vfs提供的通用接口。ioctl被称为对文件操作的百宝箱。
   
7. 信号
   
   从内核空间向进程发送信号。这个经常遇到，ARM工作模式有一个是ABT模式，终止模式，就是当进程非法访问地址的时候，由内核向该进程发出SYSEGV信号结束进程的。

mmap/信号/sysfs+kibject/proc/netlink/API/文件。

##### 内核链表为什么具有通用性？

这题我会！，因为list_node链表里面只有上下节点的指针，没有数据域，数据域被挪到包含链表节点的父结构中了，通过container_of宏来找到链表节点的父结构，这样就不需要要求包含链表的父结构的类型一致了。

内核中由于要管理大量的设备，但是各种设备各不相同，必须将他们统一起来管理，于是内核设计者就想到了使用通用链表来处理，通用链表看似神秘，**实际上就是双向循环链表**，**这个链表的每个节点都是只有指针域，没有任何数据域。**

![1675945375789](C:\Users\MACHENIKE\AppData\Roaming\Typora\typora-user-images\1675945375789.png)

使用通用链表的好处：

1. 通用链表中每个节点中**没有数据域**，无论数据结构有多复杂在链表中**只有前后级指针**。
2. 如果一个数据结构（即是描述设备的设备结构体）想要用通用链表管理比如驱动与设备，**只需要在结构体中包含节点的字段即可。**
3. 双向链表可以从任意一个节点的前后遍历整个链表，遍历非常方便。
4. 使用循环链表使得可以不断的循环遍历管理节点，比如操作系统就把就绪的进程放到一个管理进程的就绪队列的通用链表中管理。使用的是CFS完全平均分配调度。

##### 应用程序中open()在Linux中执行过程中是如何从用户空间到内核空间？

这题我也会！open()这是系统调用，但实际上只是应用层的系统调用，此函数实际作用是触发软中断(SWI指令触发的，通过计算出SWI号从而执行对应的SWI处理程序，这里的SWI处理程序就是系统调用处理程序，在x86上软中断号是128，也就执行128号对应的中断服务程序)，以及把系统调用号存储在寄存器中，当陷入内核空间之后，执行系统调用处理程序，根据传递的系统调用号查找系统调用表，找到实际对应的系统调用，然后执行该系统调用。

read系统调用引发一个异常来促使系统切换到内核态去执行异常处理函数，这个就是系统调用处理程序system_call()。系统调用号通过eax寄存器传递给内核的。通过这个系统调用号去查找系统调用表找到相应的系统调用，sys_read()函数。

![1670238142904](C:\Users\MACHENIKE\AppData\Roaming\Typora\typora-user-images\1670238142904.png)

1. 应用层调用open函数，在VFS层中找到**struct inode结构体**，这是索引节点结构体，存储文件的物理信息和控制信息。判断是字符设备还是块设备，**根据设备号找到对应的驱动程序**。

2. 在驱动层中，每个字符设备都有一个**struct cdev结构体。**这个结构体通过struct inode结构体中的i_cdev把VFS层和驱动层连接起来，struct cdev结构体描述了字符设备所有信息，**最重要的是字符设备的操作函数接口**，file_operations就是注册到cdev结构体中从而最终实现注册到内核的。

3. struct cdev结构体中的**struct file结构体**记录了操作字符设备的一些函数，

   struct file结构体是在VFS层的，通过struct file结构体指针指向驱动层的struct file结构体将驱动层函数与VFS层连接起来。

4. 任务完成，VFS层会给应用返回一个文件描述符fd，这个fd是和struct file结构体对应的。

这个问题非常好，之所以这里面没有提到系统调用sys_open就是因为被驱动模块中定义的open替换了。

总结：应用层open->内核层sys_open

应用层open->VFS层inode->VFS层i_cdev->驱动层cdev->驱动层file_operations

##### 怎样申请大段内核内存？

如果允许物理地址不连续，虚拟地址连续的话，可以使用vmalloc，不过访问内存的时间比较长，会引起TLB抖动。因为页表项需要一个一个映射。

#### 设备驱动

##### 请简述主设备号和次设备号的用途

主设备号表示设备类型，比如输入子系统的核心层替我们申请的字符设备的主设备号都是13，表示输入设备，次设备号就是同种类型设备的不同编号了。

**主设备号：主设备号表示设备对应的特定的驱动程序。**虽然现代的Linux内核允许多个驱动程序共享主设备号，但我们看待的大多数设备仍然按照“一个主设备对应一个驱动程序”的原则组织。

**次设备号：次设备号由内核使用，用于确定主设备号对应驱动程序中的各个设备。**依赖于驱动程序的编写方式，我们可以通过次设备号获得一个指向内核设备的直接指针，也可将次设备号当做设备本地数组的索引。

##### 字符型驱动设备怎么创建设备文件？

这里指的是设备节点吧，我记得是申请设备号、注册cdev、注册class之后就会出现设备节点，，，具体的流程确实不知道，，

1. 手动创建

   mknod /dev/led c 250 0，其中dev/led为设备节点，c表示字符设备，250是主设备号，0代表次设备号。

2. 自动创建

   UDEV/MDEV是运行在用户态的程序，可以动态管理设备文件，包括创建和删除设备文件，运行在用户态意味着系统要运行之后，在/et/init.d/rcS脚本文件中会执行mdev -s自动创建设备节点。这里的rcS属于初始化脚本，系统引导程序在加载根文件系统之后，会执行初始化脚本。

   ----

   看了下驱动笔记才知道这部分讲过，这里我记得是在驱动模块中有两个API实现的创建设备节点。

   udev是一个用户程序，通过udev实现设备文件的创建和删除，可以检测系统中硬件设备状态。根据硬件设备状态来创建和删除设备文件，比如modprobe命令成功加载驱动模块之后就会自动在/dev目录下创建设备节点。

   **mdev是udev的简化版本**，构建根文件系统的时候就会在/etc/init.d/rcS文件中写下语句：

   ```c
   echo /sbin/mdev > /proc/sys/kernel/hotplug//这里用的是>这是覆盖。
   ```

   ---

##### 设备驱动程序中如何注册一个字符设备？分别解释下他的几个参数的含义

注册cdev结构体的流程，需要初始化cdev结构体中的一些成员，比如设备号dev、模块所有者owner、设备数量count。

注册一个字符设备驱动有两种方法：

1. ```c
   void cdev_init(struct cdev *cdev,struct file_operations *fops)//这里的fops就是自定义的操作函数结构体。该注册函数将cdev结构体嵌入到自己的设备特定的结构中，对象层次化结构。
   ```

2. ```c
   int register_chrdev(unsigned int major,const char *name,struct file_operations *fops)//这是旧版字符设备驱动使用的函数，新版字符设备使用的是上面的函数，新旧字符设备区别在于新版的字符设备驱动可以自动创建/自动删除设备节点，并且在注册字符设备的时候更加细化了，用多个API代替register_chrdev函数，并且把cdev结构体暴露出来了。该注册函数是早期的注册函数，major是设备的主设备号，name是驱动程序的名称，而fops是默认的file_operations结构。对于register_chrdev的调用将为给定的主设备号注册0-255作为次设备号，并为每个设备建立一个对应的默认的cdev结构。
   ```

##### /dev/下面的设备文件是怎么创建出来的？

这个之前提到过，不过指南里这个问题好像是换了个大哥写的。有必要重新写一遍。

普遍说法有三种方式，devfs机制、udev机制、再有一个就是手动创建设备节点。

1. devfs机制，学的2.6内核并没有提到这个。
2. udev，其实就是现在常用的device_create()、class_create()这套接口。这两个API也正是新版字符设备驱动增加的，并且增加后就不需要手动创建设备节点了。**所谓udev是上层用户空间程序，基于驱动中创建使用了这两个接口而起作用的**，但是udev在日常开发中几乎接触不到，只需在驱动中调用这两个API即可。剩下的工作交给udev去做。
3. mknod，手动创建设备节点。

##### Linux设备中字符设备和块设备有什么主要区别？分别举例

Linux中IO设备分为两类：块设备和字符设备。两种设备本身没有严格限制，但是基于不同的功能进行了分类。

字符设备：提供**连续**的数据流，应用程序可以顺序读取，通常不支持随机存取。。这类设备**支持字节/字符**来读写数据。字符终端、串口、鼠标、键盘等等都是典型的字符设备。

块设备：应用程序可以**随机访问**设备数据，程序可自行确定读取数据的位置。硬盘是典型的块设备，应用程序可以**寻址磁盘上的任何位置**，读取数据只能以块进行通常是512B的倍数进行。不支持基于字符的寻址。由u盘、SD卡、磁盘。

##### 驱动中操作物理绝对地址为什么要先ioremap?

将IO地址空间映射到虚拟地址空间上去，便于操作。因为保护模式下的CPU只认虚拟地址，不认物理地址。所以要**操作外设上的寄存器必须先映射到虚拟内存空间拿着虚拟地址去跟CPU对接从而操作寄存器**。

##### insmod，rmmod一个驱动模块，会执行模块中的哪个函数？在设计上要注意哪些问题？

这两个分别表示加载和卸载驱动模块，分别对应的是驱动模块的入口函数和出口函数。

分别会执行module_init()和module_exit()指定的init函数和exit函数。要注意的是尽量使在init函数中出现的资源申请以及使用，都要有对应的释放操作在exit中，即init申请和exit释放。

##### NAND驱动的probe流程

这里问的是块设备的驱动入口函数，也就是块设备的注册流程。我没有学过。这里就把答案看一看吧。

probe函数就会与NAND芯片进行，主要做的事情包括这几个方面：

1. **读取NAND芯片的ID**，查表找到这片NAND芯片的厂商、page size/erase size/chip size等信息，
2. 接着，根据struct nand_chip中options的值不同，或者在NAND芯片中的特定位置**查找bad block table**，或者scan整个NAND芯片，并在内存中建立bad block table，
3. 这些动作都可以在MTD提供的一个叫做nand_scan函数中完成。

##### Linux驱动开发中，常用的调试方法有哪些？

GDB调试，网络调试（指的是通过网络将内核、根文件系统烧录到板子上）、printk调试（但是需要设置打印权限，有时候驱动模块的printk会被吞）。

利用printk查看OOP信息，但是如果驱动模块中的打印被吞了，就看dmesg中的打印信息。利用strace，利用内核内置的hacking选项，利用ioctl方法（这个函数被称为对文件操作的工具箱）。利用/proc文件系统（比如查看中断是否被成功申请，中断是否被成功触发了，在调试iio框架的时候就会出现缓冲区无可读数据，这时候就可以看下是外部中断的问题还是虚拟中断的问题。大概率是这两个地方没有打通）。

使用kgdb，这个感觉像是内核中的GDB调试。内核中并没有介绍。搜了一下果然是内核的代码级gdb调试。这个我有印象，当初在内核源码中有相应的文件，为了调试。

面试的时候就说使用printk和/proc文件系统调试吧，其实还可以加上/sys文件系统调试。因为设备树节点是可以显示出来，并且对象层次结构也可以通过sys看出来。

遇到的问题就是ad7606官网驱动代码有问题，让我深入学习了下iio框架，后期的时候也用内核驱动进行了对比。

#### Linux驱动开发常用函数

##### ioremap

这个就是实现虚实地址转换的，将寄存器的物理地址输入进去，转换成主存上的虚拟地址，与内存申请函数不同。这里的物理地址是我们给出的。

###### 简介

```c
void *__ioremap(unsigned long phys_addr,unsigned long size,unsigned long flags);//物理起始地址，需要申请的内存大小，flags是啥来着
void *ioremap(unsigned long phys_addr,unsigned long size)//常用的是这个
```

- 入口：phys_addr，要映射的起始的IO地址。
- size：要映射的空间的大小。
- flags：要映射的IO空间的和权限有关的标志；
- 头文件：io.h

###### 主要功能

将一个IO地址空间映射到内核的虚拟地址空间上，便于访问。比如我们要映射的寄存器有100个寄存器，连在一起，位置是固定的，每个寄存器需要占四个字节，那么400字节的空间被映射到内存成功后，ioaddr也就是返回值的指针就是这段地址的开头，此时ioaddr就是虚拟地址了。ioaddr+0就可以对第一个寄存器操作了，+4就是对第二个寄存器操作。

##### open

###### 函数定义

```c
int open(const char *pathname,int flags);
int open(const char *pathname,int flags,mode_t mode);
```

###### 参数说明

- pathname：文件的名称，可以包含(绝对和相对)路径；
- flags：文件打开模式，这个熟悉，有非常多种，比如可读、可写、非阻塞、同步缓冲区之类的。
- mode：用来规定对该文件的所有者，文件的用户组及系统中其他用户的访问权限，则文件权限：mode&(~umask)。这个是权限掩码，open函数、chmod函数都会用来设置文件的权限，属于进程中的文件属性之一。

##### read

###### 函数定义

```c
ssize_t read(int fd,void *buf,size_t count);
```

###### 函数说明

read()会把参数fd所指的文件传送count个字节到buf指针所指的内存中。其实是驱动层的read调用copy_to_user实现的。

###### 返回值

返回值为**实际读取到的字节数**，如果返回0表示已到达文件尾或是无可读取的数据，如果参数count为0，则read()不会有作用并返回0.

###### 注意

read时fd中的数据如果小于要读取的数据，这里需要结合阻塞式IO还是非阻塞式IO两种方法。

##### write

###### 函数定义

```c
ssize_t write(int fd,const void* buf,size_t count);
```

###### 函数说明

write()会把参数buf所指的内存写入count个字节到参数fd所指的文件内。

###### 返回值

如果顺利write()会**返回实际写入的字节数**。当有错误发生则返回-1，错无代码存入errno中，这里的errno是全局变量，本身文件自带的变量。perrno可以直接打印出来相应的错误信息。

###### 说明

这里对文件操作函数的解释太肤浅了。

##### copy_to_user

###### 函数定义

```c
unsigned long copy_to_user(void *to,const void *from,unsigned long n)
```

###### 参数说明

这个函数是驱动层的函数，内核空间与用户空间通信的手段之一。

1. to：目标地址(用户空间)
2. from：源地址(内核空间)
3. n：将要拷贝数据的字节数

###### 返回值

成功返回0，失败返回没有拷贝成功的数据字节数。

##### copy_from_user

###### 函数定义

```c
unsigned long copy_from_user(void *to,const void *from,unsigned long n)
```

### 操作系统

#### 进程和线程

###### 什么是进程？什么是线程?

如果从用户态的角度而言，线程是进程的一部分，线程是获得资源不可再分的最小单位。但是从内核态的角度来说，对于内核而言，两者并没有区别，都是使用同一种函数创建出来的，在存储方式上没有区别，都是相同的进程描述符来表示结构。

---

**进程是资源分配的基本单位**，他是程序执行时的一个实例，在程序运行时创建。

**线程是程序执行的最小单位**，是进程的一个执行流，一个进程由多个线程组成的。

进程是处于执行期的程序，而线程是进程中的活动的对象，如果进程中只有一个线程就是单线程进程，这个线程就是主线程。具体的定义复习内核笔记的时候看。

##### 进程和线程有什么区别？

1. 进程是**资源分配**的基本单位
2. 线程是**程序执行**的最小单位，也是**处理器调度的基本单位**。
3. 进程有自己的**独立地址空间**（这句话说到点子上了，进程地址空间），每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段。（可执行映射文件的内存分配是一或多个代码段以及零或多个初始化的数据段和零或多个未初始化的数据段，可写可读）。这种操作非常昂贵，一个进程中的多个**线程共享进程中的数据**，使用相同的地址空间。换句话说就是多个线程共享一个进程栈，每个线程又拥有自己的线程栈。**CPU切换一个线程的花费远比进程小很多，创建一个线程的花费也比进程小很多**。
4. 线程之间的通信更方便，同一个进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式(IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。多进程程序更健壮（因为每个进程的地址空间不重合）。**多线程程序只要有一个线程死掉，整个进程也跟着死掉，而进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。**
5. 进程切换时，消耗的资源大、效率低。所以涉及到频繁的切换时，**使用线程要好于进程**。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程。
6. 执行过程：**每个独立的进程有一个程序运行的入口、顺序执行序列**。（顺序执行序列指的是进程的就绪队列）。**线程不能独立执行**（如果独立执行了，就说明这是一个单线程进程），必须依存在应用程序中，由应用程序提供多个线程执行控制。
7. **线程执行开销小**，但是不利于资源的管理和保护。线程适合在SMP机器上运行。**进程执行开销大**，但是能够很好的进行**资源管理和保护**，可以跨机器迁移。

总的来说，进程健壮性强，资源分配的基本单位，独立地址空间。切换、创建开销大，进程间通信麻烦.

对于内核而言，线程只是与其他一些进程共享某些资源的进程。

##### 何时使用多进程,何时使用多线程。

当资源的管理和保护要求高，不限制开销和效率时，使用多进程。

要求效率高、频繁切换时，资源的保护管理要求不是很高的时候，使用多线程。（线程会共享进程的资源，每个线程之间只有各自的线程栈独立）

##### 进程有几种状态？画一下进程状态转换图？

操作系统、Linux内核、指南都指出了进程共有五种状态，但是他们对于状态的划分并不一样。内核将进程创建分成了两个函数实现，这里主要提到了fork，这是创建进程的，exec族函数是给新创建的进程注入执行内容的。

###### 创建状态

一个应该有程序从系统上启动，首先就是进入创建状态，需要获取系统资源创建进程管理块PCB，完成资源分配。

###### 就绪状态

创建状态完成之后，进程已经准备好，但是还未获得处理器资源，无法运行。此时的内核会给进程描述符中的state赋值TASK_RUNNING。

###### 运行状态

获取处理器资源，被系统调用，开始进入运行状态。如果进程的时间片用完了就进入就绪状态。

2.6.31版本的内核采用CFS调度方式分配时间片。调度程序将任务投入运行schedule()函数调用context_switch()函数。此时进程描述符的state依旧是TASK_RUNNING。

###### 阻塞状态

运行状态期间，如果进行了阻塞的操作，比如耗时的IO操作，此时进程暂时无法操作就进入了阻塞状态。等操作结束完成后进入就绪状态。

为了等待特定事件，任务在等待队列上睡眠，但是此时进程存在两种状态TASK_INTERRUPTIBLE或TASK_UNINTERRUPTIBLE。分别是可中断和不可中断两种，如果是可中断的话，出于此状态的进程也会因为接收到信号而提前被唤醒并随时准备投入运行。

如果是不可中断状态的话，即使接收到信号也不会被唤醒或者投入运行。这个状态通常存在于“**必须在等待时不受干扰**”或者“**等待事件很快就会发生**”。由于处于此状态的任务对信号不做响应，所以用的很少。

###### 终止状态

进程结束或者被系统终止，进入终止状态。进程没有投入运行也不能投入运行。通常这种状态发生在接收到信号的时候。此时的进程描述符中的state为TASK_STOPPED。处于运行态的进程通过do_exit()函数退出

除了上面五种之外，内核还提供了一种state状态。TASK_TRACED被其他进程跟踪的进程。被跟踪的话死掉的的时候内核会把SIGCHID发送给跟踪你的进程。你相当于是跟踪者的孩子。孤儿进程和僵尸进程应该是也算是进程的状态。

![](F:\嵌入式学习\复习与刷题\复习资料\进程状态.png)

上图算是集大成者了。

##### 创建进程有哪几种方式？

对于通用系统，需要有系统运行过程中创建或撤销进程的能力，主要分为四种形式创建新的进程：

1. 系统初始化。比如init进程就是由uboot中的bootargs指定在根文件系统中找到的。
2. 一个进程在运行过程中开启了子进程。
3. 用户的交互式请求，而创建了一个新进程。
4. 一个批处理作业的初始化。

##### 进程间通信方式有哪些？有什么优缺点？

内核中提了下在内核源码目录下有IPC目录专门讲解进程间通信的。主要还是学Linux应用的时候学到的。管道FIFO分为普通管道，流管道，有名管道。共享地址用mmap函数实现地址映射，特点是可以交换大量数据，常用于显存。信号量，这属于同步操作、信号，这属于异步通知、套接字、消息队列。

###### 管道pipe

1. 普通管道

   这种通讯方式有两种限制，**一是半双工的通信，数据只能单向流动** ，**二是只能在具有亲缘关系的进程间使用**，进程的亲缘关系是指父子兄弟进程关系。

2. 流管道s_pipe：祛除了第一种限制，**可以实现全双工**

3. 命名管道name_pipe：克服了第二种限制，**不仅仅可以实现全双工，还允许无亲缘关系进程间通信**，也称为FIFO。

###### 信号量semophore

**信号量是计数器**，防止某进程正在访问共享资源时，其他进程也访问该资源，**作为进程间以及同一进程内不同线程之间的同步手段。**

###### 消息队列message queue

消息队列是由消息组成的链表，存放在内核中并由消息队列标识符标识。

**消息队列是消息的链表**，包括Posix消息队列和system V消息队列。有写权限的进程可以向队列中添加消息，被赋予读权限的进程可以读走队列中的消息。**消息队列克服了信号承载信息量少**，**管道只能承载无格式字节流以及缓冲区大小受限等缺点**。

###### 信号signal

信号是一种比较复杂的通信方式，**用于通知接收进程某个事件已经发生**，这是一种异步通知的手段。

###### 共享内存shared memory

共享内存就是映射一段能被其他进程访问的内存。**这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式**，他是针对其他进程间通信方式运行效率低而专门设计的。往往与其他的通信机制配合使用，实现进程间的同步和通信。

###### 套接字socket

套接字是一种进程间的通信机制，**可用于不同机器间的进程通信**。

之前学习内核空间与用户空间通信方式的时候，提到过netlink套接字/sysfs+kobject(显示对象层次化)/proc/文件/信号/mmap(共享内存)/API(四个函数)，这里面提到过netlink套接字具有多点传输、内核先发起会话、异步通信、不需要文件自定义的传输协议。不知道这两者有什么关系，之前应用学习的时候认为套接字属于网络编程，这个网络是计算机网络，还是多点组成的网络？

##### 各通信方式的比较和优缺点：

###### 管道

速度慢、容量有限、只能父子兄弟间通信。半双工。只能无格式字节流传输。

###### FIFO

这是有名管道，全双工，任何进程都能通信，速度慢。

###### 消息队列

容量收到系统限制（因为是链表管理的，内核对链表上限是不是有说法），要注意第一次读的时候要考虑上一次没有读完数据的问题，消息队列可以任意进程通过消息队列实现进程间通信，由**系统调用实现消息发送和接收**。但信息的复制需要额外消耗CPU的时间，**不适宜信息量大或者操作频繁的场合**，不太常用。每一次读写都**通过系统调用**。

###### 信号量

不能用来传递复杂信息，**只能用来同步。**这也符合我对信号量的理解。

###### 共享内存

利用内存缓冲区直接交换信息，无须复制，快捷，信息量大是优点，共享内存块提供了在**任意数量的进程**之间进行高效双向通信的机制。但要**防止竞争关系**。

##### 进程间通信方式的选择

PIPE和FIFO用来实现进程间相互发送**非常短小**、**频率很高**的信息，适用于**两个进程间通信**。

共享内存用来实现进程间共享的**非常庞大**、**读写操作频率很高**的数据，这种方法适用于**多进程间的通信**。

其他考虑用socket，应用于分布式开发。

##### 线程间同步方法有哪些？

刚学完进程间通信，就会发现线程间通信的好处，因为同一进程下的多个线程共享了进程地址空间，他们各自有着线程栈。

线程间同步我记不清了，临界区是当线程获取临界区资源之后，其他线程无法获得临界区资源而等待。信号量也算一个这属于锁机制。complete函数这是内核中的一种同步方式。互斥量其实属于信号量的一种，事件这个好耳熟，是信号不。原子操作、自旋锁、信号量、互斥体、完成变量(complete)、BLK大内核锁、顺序锁、禁止抢占、顺序与屏障。内核必须得复习了，这些我都没记住。

Linux应用介绍的是原子操作、信号量、互斥体、自旋锁。临界区其实是原子操作的一种表现。

1. 原子操作：原子操作保证指令以原子的方式执行，不被打断。通过内嵌汇编指令实现的。atomic_read()函数。

2. 自旋锁：spinlock自旋锁只能被一个可执行线程持有。如果执行线程试图获得一个已经被持有的自旋锁，该线程就会进入忙循环，这也是和信号量的区别，自旋锁不应该长期被持有。中断中可以使用，因为中断不可以被休眠。

3. 信号量semaphore是一种睡眠锁，如果一个线程试图获得一个不可用信号量时，信号量会将其推进到一个等待队列，让其睡眠。所以不可以在中断中使用。

4. 互斥锁：mutex这是一种更简单的睡眠锁。简化版的信号量，不再需要管理任何使用 计数，还可以让线程睡眠。

   ----

   以上四种在应用层也可以应用，下面只适合于内核态。

5. 完成变量，完成变量提供了代替信号量 一个简单解决方案。常用于内核和驱动模块中。

6. BLK大内核锁，这是一个全局自旋锁，实现从Linux最初的SMP过渡到细粒度加锁机制。

7. 顺序锁，简称为seq锁。主要依靠一个序列计数器。有疑义的数据写入时就记录，如果读取的时候记录没有改变说明没有被写操作过。

8. 临界区：通过对多线程的串行化来访问公共资源或一段代码，临界区在被释放后其他线程才可以抢占，否则会被挂起。其实这和信号量很像，只不过临界区保护一段代码，信号量保护信号量自身不可被获得。

##### 什么是内核线程和用户线程？

这个之前讲过概念，运行在内核空间下的线程就是内核线程，用户线程就是运行在用户空间下的。他们的指令级别不同，内核线程的是Ring0，而用户线程是Ring3。

---

这次是解释更好一些

用户线程是指**不需要内核支持**而在用户程序中实现的线程，**不依赖操作系统核心**，应用进程利**用线程库提供**创建、同步、调度和管理线程的函数。

内核线程：由操作系统内核**创建和撤销**。**内核维护**进程以及线程的上下文信息以及线程切换。内核线程并没有独立的地址空间，当一个内核线程死掉并不会影响其他的内核线程。内核线程可以被睡眠，乐鑫笔试考过。

##### 内核线程和用户线程的区别？

1. 内核级线程是OS**内核可感知的**，用户级线程OS内核是**不可感知**的。
2. 用户级线程的创建、撤销和调度**不需要OS内核的支持**，在语言这一级处理的。应该是语言的标准库支持的；而内核级线程的创建、撤销和调度都**需要OS内核提供支持**。而且与进程的创建、撤销和调度大体是相同的。
3. 用户级线程执行系统调用指令时，触发软中断，导致**所属进程被中断**，而内核级线程执行系统调用指令时只导致**该线程被中断**。
4. 在只有用户级线程的系统内，**CPU调度以进程为单位**，处于运行状态的进程中的多个线程由**用户程序**控制线程的轮换运行；在有内核级线程的系统中，**CPU调度以线程为单位**，有OS的**线程调度程序**负责线程的调度。进程中的线程数量增加，线程执行时间减少，内核线程数量增加，整体执行时间增加。
5. 用户级线程的程序实体是运行在**用户态下的程序**，内核支持线程的程序实体是可以**运行在任何状态下的程序**。

##### 内核线程和用户线程有什么优缺点？

###### 内核线程的优点

如果是多处理器SMP时，多个线程可以**并行**执行。

###### 缺点

需要内核进行调度。

###### 用户线程的优点

1. 线程**不需要内核直接参与**
2. 可以在**不支持线程的操作系统**上实现。
3. 创建和销毁、切换线程的**代价比内核线程少的多**。（内核线程需要内核控制，占用系统资源）
4. 允许每个进程**定制自己的调度算法**，线程管理比较灵活。
5. 线程能够利用的**堆栈空间比内核级线程多**，内核线程只有很少的内核栈。堆栈空间使用STMFA/LDMED等汇编指令实现堆栈指针sp的操作。

###### 缺点

即使是在多处理器下，因为以进程为资源分配的基本单位，所以同一个进程下的线程只能是分时复用，也就是并发。

##### 什么是僵尸进程、孤儿进程、守护进程？

僵尸进程是子进程死掉了，但是父进程并没有为其收尸，这就导致子进程还占有一点系统资源无法释放。父进程用fork创建子进程，等待子进程退出，但是父进程并没有调用wait或者waitpid获取子进程的状态信息，子进程的进程描述符仍然保存在系统中。

孤儿进程是父进程死掉了，被init进程收养的子进程。

守护进程的运行时间长，从系统启动到系统结束。脱离终端控制，周期性的执行某种任务。

##### 僵尸进程有什么危害？

进程退出的时候，内核释放该进程所有资源，包括打开的文件、占用的内存等。但是进程描述符会保留下来，这是为了让父进程收尸(wait)的时候知道子进程是怎么死的(也就是查看进程描述符中的退出代码)。

如果进程不调用wait/waitpid的话，保留的信息不会被释放，进程号会一直被占用，而系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。

##### 如何清理僵尸进程

僵尸进程的产生是因为父进程没有wait()子进程。所以如果自己写程序的话，一定要在父进程中通过wait()避免僵尸进程的产生。

如果系统中出现了僵尸进程时，无法通过kill命令把他清除掉（只剩下一个进程描述符怎么接收信号），可以通过**杀死他的父进程**让他变成孤儿进程，进一步被系统中管理孤儿进程的进程(init)收养并清理。

##### 如何唤醒被阻塞的socket线程？

###### 同步阻塞

等待锁的释放。如果被阻塞的线程是TASK_INTERRUPTIBLE状态的，还可以用信号提前唤醒。

##### 如何确定当前线程是繁忙还是阻塞？

使用ps命令查看

##### 空闲的进程和阻塞的进程状态会不会在唤醒的时候误判？

不会，每个进程都有进程控制块PCB，两种状态的进程分别处于两种队列。唤醒应该是去找等待队列的进程。

##### 请问就绪状态的进程在等待什么？

等待使用cpu的运行权。

##### 如何实现线程池？

这种题属于Linux应用的吧，，，

##### 请你回答一下fork和vfork的区别

简单的说就是vfork并不会复制父进程的页表项。

---

复习一下内核中对fork和vfork的讲解

当没有写时拷贝的时候，调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。**两个进程都会继续运行**。

但是当我们不想让子进程执行父进程的内容而是通过exec载入二进制映像替换当前映像。这就导致了地址空间的浪费。为此引入了vfork()

使用vfork创建的子进程必须要立刻执行一次对exec的系统调用，会**挂起父进程**直到子进程终止或者运行了一个新的可执行文件。此时的子进程**共享父进程相同的地址空间和页表项。**这就避免了地址空间的按页复制。vfork只完成了复制内部的内核数据结构。

写时拷贝Copy-On-Write：Linux采用了写时拷贝的方法，减少fork对父进程空间进程整体复制带来的开销。以只读的方式共享父进程地址空间，除非进程需要写入的时候，数据才会被复制，从而使得进程拥有了各自的拷贝。如果fork之后立刻调用exec的话就无须复制了。

---

1. fork()的子进程**拷贝父进程的数据段和代码段**；vfork()的**子进程与父进程共享数据段**
2. fork的父子进程执**行次序不确定**；vfork保证**子进程先运行**，在调用exec或者exit之前与父进程数据是共享的，调用之后父进程才被调度运行。
3. 当**需要改变共享** 数据段中变量的值的时候才会**拷贝父进程**。

简单的说，vfork是个不孝子，父进程调用vfork之后，让子进程先执行，此时子进程在父进程的进程地址空间执行，等待子进程执行完了之后父进程才继续在其进程地址空间执行。

而fork被调用了之后，父子进程同时共享父进程的进程地址空间，直到子进程想要修改资源，才会让子进程拷贝一份从此父子进程在各自的进程地址空间运行。

##### server端监听端口，但还没有客户端连接近来，此时进程处于什么状态？

#### 堆和栈

这算是正式的提到了，一直不知道这个堆栈应该在哪里讲，因为我没系统的学过C所以一直不知道这部分属于哪里的，但是C确实提到的最多。

##### 什么是代码段，数据段，bss段，堆，栈？

内存由代码段，数据段，堆，栈，文件映射区、bss段组成。

- 代码段：存放**字符串常量**和**程序代码**，**这是一个只读存储区**
- 数据段：**已初始化的非零静态变量和全局变量**。静态分配
- bss段：存放**未初始化的静态变量和全局变量**（这种情况默认是零）以及**初始化为0的静态变量**。本质上属于数据段，是被初始化为0的数据段，静态分配
- 堆：由程序员手动分配/手动释放内存，不连续的内存，由链表管理，容易造成内存碎片，**动态分配**，**大小不固定**，当大于128B时采用malloc，小于采用内存池技术，就是链表管理。
- 栈：**存储局部变量、函数参数（这里指的是函数参数，并不是程序参数，前者是局部变量）、函数返回值、函数地址，保存寄存器数值**。可以看成是寄存、交换临时数据的内存区。
- 文本映射区：动态链接库和mmap共享内存的时候放这里。

```c
#include <stdio.h>
int a =0;//bss
char *p1;//bss
int d = 1;//数据段
int main(void)
{
    int b;//栈，之前学栈帧结构的时候，在栈上看到过main函数，main函数自然在栈上
    char s = "a";//栈
    static int c = 1;//数据段
    static int e = 0;//bss
    class c1 = new class();//堆
    const int a = 0;//代码段，只读存储区
}
```

##### 为什么堆的空间是不连续的？

这个看面经的时候遇到过，堆是由链表管理的，链表可以管理不连续的内存地址，而堆是**动态分配**可变化的。手动执行malloc就变大，free就变小。可能造成内存碎片，**堆分配的空间在逻辑上连续，在物理地址上不连续，因为采用了页式内存管理。**（页式内存管理就是把逻辑上连续的内存分配成物理上不连续的多个物理块，通过页表来将页与物理块一一对应，vmalloc分配的内存就是逻辑上连续，物理上不连续，需要创建专属的页表，将页和物理块一一对应形成页表项，所以才导致访问内存时间过长，在加载驱动模块的时候用到，平时很少用）。如果逻辑地址上没有一段连续且足够大的空间，就会导致内存分配失败，这也是内存泄漏的后果之一。

堆是由malloc/new函数动态分配内存的（虽然kmalloc函数可以分配连续虚拟地址并且物理地址也连续的内存），采用了页式内存管理，这是一种不连续内存的管理方式。所以分配的是连续的虚拟地址，不连续的物理地址，堆需要用链表维护。如果分配的内存小于128B的话，会采用内存池技术分配内存，同样是空闲链表维护。

##### 什么是用户栈和内核栈？

内核栈是内核分配1GB的内核空间给内核/用户线程的，用于保存线程的参数，返回值以及局部变量。内核栈很小，2.6版本之后中断服务程序也有了属于自己的内核栈。正常32位机是4KB

用户栈是用户空间分配给用户线程的，用于保存用户空间子程序间调用的参数，返回值以及局部变量。

##### 用户栈和内核栈，为什么不能共用一个栈？

1. 如果只用系统栈，**系统栈一般大小有限**，而用户程序调用次数可能很多，可能会导致程序的参数、局部变量、返回值无法保存，用户程序无法执行。
2. 如果只用用户栈，内核线程需要在某种**保护下运行** ，而用户栈在用户空间下无法提供相应的保护。

##### 线程是否具有相同的堆栈？

不，即使是同一进程下的多个线程也是拥有各自的线程栈，他们共用一个进程地址空间。

#### 并发与互斥

##### 驱动里面为什么要有并发、互斥的控制？如何实现？讲个例子？

并发指的是宏观上多个线程并行执行。而并发的执行单元对共享资源的访问很容易导致竞态，驱动中的共享资源比如某个寄存器，某个IO口，对同一个总线的控制权。

解决竞态问题的途径是保证对共享资源的互斥访问，所谓的互斥访问就是同一个时间 只能有一个线程获得资源，其他线程无法获得而进入自旋或者阻塞。

其实这是一个同步的问题，可以使用原子操作、自旋锁、互斥锁、信号量、如果是驱动模块中的话还可以使用完全变量、顺序锁、如果内核的版本过低的话还可以使用大内核锁。还有临界区，共享访问资源的代码段被称为临界区，加以保护就可以了。

##### 自旋锁是什么？信号量是什么？二者有何异同？

自旋锁是一种锁机制，确保自旋锁同一时间只能有一个线程获得，其他线程试图获得会导致自身自旋。可以应用在中断上半部中。自旋锁不允许长时间的持有，会浪费CPU资源。

信号量是一种睡眠锁，分为计数型信号量、二值信号量，同一时间只允许规定数量的线程获得信号量，其他线程试图获得信号量会导致自身睡眠。完全变量和互斥体都是信号量的简单替换。

信号量不禁止内核抢占，当持有信号量的代码被强占也没关系，而持有自旋锁的代码被抢占的话，会导致死锁的出现。

##### 自旋锁和信号量可以睡眠么，为什么？

自旋锁并不会导致试图获得他的线程睡眠，持有自旋锁的线程也不可以睡眠，否则当试图获得自旋锁的线程获得CPU资源之后会导致死锁的发生。自旋锁会**禁止内核抢占**，所谓的内核抢占指的是**内核线程并不会被打断**，直到执行结束。如果此时有一个**试图获得自旋锁的线程执行**，将导致**系统死机。**

信号量本身是可以导致那些试图获得信号量而不得的线程睡眠，持有信号量的线程也可以睡眠。因为当那些试图获得信号量的线程得不到就睡眠了，并不会导致死锁的发生。信号量是**不禁止内核抢占**的，这就导致持有信号量的进程睡眠之后，其他进程依旧可以继续抢占执行。

----

并且内核抢占的时候会判断下当前被抢占的进程是否安全，preempt_count这个成员变量为零的时候表示被强占的进程没有持有锁资源，抢占他是安全的。

顺便复习下用户抢占，指的是当内核线程返回用户空间的时候被强占。

----

##### 自旋锁和信号量可以用于中断中么？

自旋锁是为数不多的可以用于中断上下文的，因为中断不可以睡眠（中断是由硬件触发或者指令执行中断号触发的，并不是调度器调度的，所以没有就绪队列，如果中断睡眠了没有替换的进程可以执行。），试图获得自旋锁的中断陷入自旋这种现象不会发生的，因为持有自旋锁之后会禁止内核抢占、禁止本地中断。

信号量不可以用于中断中，因为中断不可睡眠。

##### 读写锁是什么？

锁的用途可以明确分为读取和写入，对一个链表既要更新又要检索，当更新链表时不可以有其他线程访问，检索链表的时候可以多个线程一起检索。读写锁就是允许线程对临界区仅需并发读操作，但是不允许多个线程并发写操作。**可以同时读取不可以同时写和读**。

##### 产生死锁的原因是什么？

多个进程相互持有彼此争抢的资源而导致相互等待。

##### 产生死锁的本质原因

1. 系统资源有限
2. 进程推进顺序不合理

有道理，绝对有道理。

##### 死锁的四个必要条件是什么？

这里就是属于操作系统的内容了。

1. 互斥条件：资源同一时间只能被一个线程访问。
2. 请求与保持条件：进程本身占有资源还需要资源，并且等待其他资源释放资源。
3. 不可剥夺条件：资源不可抢占
4. 环路等待条件：每个进程占有下一个进程所需的资源。

##### 死锁的处理方式有哪些？

预防、避免、检查、解除四种方式。

###### 预防死锁

所谓的预防条件是指破坏死锁的四个必要条件。

- 允许多个进程同时访问资源。破坏互斥
- 进程申请资源得不到就释放已占有的资源。破坏不可剥夺条件
- 采用预先静态分配条件，进程运行前一次性申请所需要的全部资源，申请不到就不执行。破坏请求与保持条件
- 给每类资源编号，进程按编号递增的顺序请求资源。

###### 避免死锁

预防死锁对系统的限制性太强，严重损害了系统性能。避免死锁是施加较弱的限制，获得较好的系统性能 。采用了算法实现的。

系统进行资源分配前计算资源分配的安全性 ，此次分配导致系统进入不安全状态就不会分配。比如银行家算法。

###### 检测死锁

为每个进程和资源指定一个唯一的号码；建立资源分配表和进程等待表。

###### 解除死锁

发现有进程死锁后，应立即从死锁状态中解脱出来。

1. 剥夺资源：从其他进程剥夺资源给死锁进程，让进程脱离死锁
2. 撤销进程：直接撤销死锁进程或者代价最小的进程。

其实还有一种鸵鸟算法，认为死锁的可能性不存在。

##### 如何避免死锁

四种破坏死锁的方法

- 进程得不到资源，全释放，破坏不可剥夺条件
- 资源可共享，破坏互斥条件
- 静态分配资源，进程申请不到不执行，请求并等待条件 
- 给资源排序，从小到大执行进程，破坏

##### 请问单核机器上写多线程程序，是否考虑加锁，为什么？

也是需要的，即使是单核机器只能说明无法执行并行操作，但是可以执行宏观上并行的并发操作。所以此时依旧需要加锁来避免竞态的发生。 

#### 内存

##### 在1G内存的计算机中能否malloc(1.2G)?为什么？

从内存角度讲，malloc分配的是堆区，但是从操作系统角度讲malloc分配的是**虚拟内存**，是进程线性地址空间，而一个进程最大可以获得2^32=4GB的地址空间，虽然实际情况下只能分配1.9GB左右的空间，但malloc分配的并不是实际的物理内存，所以虽然1G的内存但不影响malloc1.2GB的空间。c++的空间配置器分为两级，当分配大于128B空间时用malloc，当小于128B时采用内存池技术，用空闲链表维护内存，防止内存碎片的产生。

接下来需要计算下1.2GB是否超过了malloc分配的上限。

计算没看懂。

1.2 * 1024 * 1024 * 1024 Byte = 0x4ccc cccc个字节。而一个存储单元代表一个字节，所以需要地址空间0x4ccc cccc，而int是四个字节最大是0xffff，在32位机器上malloc最大的内存分配是1.9GB。

上面

##### 内存管理有哪几种方式？

常见的内存管理有页式内存管理、段式内存管理、段页式内存管理、指南中 还提到了 块式内存管理。 其实在操作系统中指的是连续分配管理方式中的固定分区分配。

###### 固定分区分配

将内存空间划分为若干个固定大小的存储区，每个分区中装入一道程序。即使所需的程序片段只有几个字节，也只能分配给他，这就导致了**很大的浪费**，但是**易于管理**。

###### 页式管理

这种最常用，**不连续内存管理方式**，将整个**地址空间按照页的固定大小进行分页**，**内存空间也被划分为若干个物理块**，**页和块的大小相等**。可将用户程序的任意页放到任意的物理块上，每个页的物理地址记录在页表的页表项中，从而实现**页与物理块一一对应关系**，可以让不连续的物理地址变成连续的虚拟地址。**页的大小固定，便于管理，页长与程序的逻辑大小没有关系**，不利于程序的独立性。

###### 段式管理

不连续内存管理方式，段按照**程序的自然分界划分**的并且长度可以动态改变的区域。这种方式将**地址空间分成若干个大小不相等的段**，每段定义一组相对**完整的逻辑信息**。

分页对于程序员而言是不可见的，内核完成的，而分段对于程序员是可见的。

优点：

1. 段的逻辑独立性不仅使其易于编译、管理、修改和保护，也便于多道程序的共享。
2. 段长可以根据需要动态修改
3. 方便分段共享和保护、动态链接和增长。

缺点：

1. 段的大小不固定，管理起来麻烦
2. 产生段内碎片，存储空间利用率低。

###### 段页式管理

段页式存储组织是分段式和分页式结合的存储组织方式。充分利用分段管理和分页管理的好处。

1. **用分段方法来分配和管理虚拟存储器**。地址空间按照逻辑单位分成段，每个段都有段名，再把每个段分成固定大小的若干个页。
2. **用分页方法来分配和管理内存**。整个主存分成页大小相等的存储块。
程序对内存的调用或调出是按页进行的。按段实现共享和保护。

其实就是逻辑地址是基本单位是段，最小单位是页。物理地址是按照页划分的。保证了程序的独立性的同时还保证了管理上的方便 。

##### 什么是虚拟内存？

虚拟内存是**逻辑上**的结构，允许程序员编写并运行**比实际系统拥有的内存大得多的程序**。实际上有**一部分存储在外存中** 。

虚存的好处：

1. **扩大了地址空间**。毫无疑问的
2. **内存保护**。想要对物理内存的数据修改，需要经过虚实转换。
3. **公平分配内存**。每个进程的地址空间都是3GB。

缺点：

1. 虚存的管理需要建立数据结构，**占用额外内存**。
2. 虚实转换，**增加指令执行时间**
3. 页面换入换出，**增加时间**
4. 如果一页只有一部分数据，**浪费内存**

##### 解释下内存碎片、内部碎片、外部碎片？

自己理解的。

- 内存碎片是经过多次分配之后剩下的碎片过小无法使用的内存。分为内部碎片和外部碎片。
- 内部碎片指的是将内存分配给进程使用，但是进程没有使用完的碎片，页式内存管理中出现
- 外部碎片指的是不属于任何进程，由于太小了无法分配出去的碎片。段式内存管理中出现
- 段页式内存管理是没有外部碎片的，因为内存还是按照页式内存管理划分成一个个页，而内部碎片比页式内存管理的要大。

---

- 内存碎片是**多次内存分配造成的**，空白段很小无法提供给用户足够的空间
- 内碎片：**分配给程序的存储空间没用完**，处于页面内部的存储块无法被使用
- 外碎片：空间太小，**小到无法给任何程序分配的存储空间**（这里如果采用了页式内存管理就不会出现外部碎片了，段式内存管理是按程序的自然边界划分的内存）。**不属于任何进程**。

##### 解释下虚拟地址、逻辑地址、线性地址、物理地址？

----

虚拟地址等于逻辑地址等于线性地址这三者说的是一个东西，指的是逻辑上的结构对地址空间进行的划分，通常是以数字划分的。由虚拟存储器进行分配和管理，数字可以修改

物理地址是实际存在的，是内存中每个存储单元的地址，是可以找到的。通常是指寄存器地址或者内存的存储单元地址。是硬件决定的，不可以修改。

---

和指南对比了下，发现错的有点离谱。这部分操作系统并没有讲过。

- 虚拟地址：由**程序产生**的**段标识符+段内偏移地址**组成，并没**有直接访问存储单元**。
- 逻辑地址：和虚拟地址没有明确的区分。
- 线性地址：这个称呼之前从来没接触过，是看指南之后看到一处提到了线性地址空间的概念。线性地址指的是由**段基地址**+**段内偏移地址**组成的地址，是虚拟地址到物理地址的**中间过渡**，是mmu内存管理单元通过**查找段表获得的地址**。（根据段标识符查找段表获得段基地址）。如果没有使用页式内存管理，此时的线性地址就是物理地址，如果使用了，还需要继续**查页表进而获得物理地址**。
- 物理地址：这个是**CPU外部地址总线上的寻址物理内存的地址信号**。

逻辑地址->(通过查找段表找到的)->线性地址->(进一步查找页表找到的)->物理地址。不同的逻辑地址可以映射到同一个线性地址，不同的线性地址可以映射到同一个物理地址。

##### 虚拟内存置换方式是怎么样的？

一共有六种，最佳置换算法OPT、先进先出算法FIFO、最近最少使用算法LRU、时钟置换算法CLOCKNRU、改进型时钟CLOCK算法、其他页面置换算法。

1. 最佳置换算法OPT：这是在**预知页面号引用串**的情况下才能实现的算法，每次从内存中淘汰的页面是**引用串中最后出现甚至不出现的页面号**。但实际上无法预知引用串，这种算法只能用来评价其他算法的优劣。
2. 先进先出算法FIFO：顾名思义，**最先进入内存的页面最先被淘汰**，这种算法效果不好，因为最先进入内存的页面往往调用最频繁，这就导致了抖动现象。抖动指的是频繁的对内存换入换出。
3. 最近最少使用算法LRU：顾名思义，最近最少使用的页面优先被淘汰。**上次使用距离自己最远**的页被淘汰。
4. 时钟置换算法NRU：这种算法也称为最近未使用算法，名字看上去和最近最少使用有点像，但是实现方式不一样，给每个页面添加一个访问位，用一个循环链表来维护内存中的所有页面，如果页面访问了，访问位置1，让指针从上次被淘汰的页面开始遍历，如果访问位是1就置0，如果访问位是0就淘汰。
5. 改进版时钟置换算法：改进的地方在于又增加了一个修改位，如果页面被修改过就置1，优先淘汰那些修改位0且访问位是0的页面，因为被修改的页面淘汰之后还需要返回到外存中写一遍。

##### 给你一个类，里面有static、virtual之类的，说一下这个类的内存分布？

看重点，是这个类！C++的部分。

###### 1.static修饰符

1. static修饰成员变量

   static静态成员变量具有一个特点，就是同一个类下的多个实例化的对象是共享同一个静态成员变量。这是因为**静态成员变量是在数据段（全局数据区）中存储**，链接阶段属于外部链接。而那些非静态成员变量是在同一个类下的多个实例化对象中都有拷贝，并且非静态成员变量是只有在实例化对象，也就是为对象分配内存空间之后才可以访问的，**静态成员变量**在对象**实例化之前就可以访问**。这是因为**非静态成员变量**是跟随类一起存储在**栈中或者堆中**。

2. static修饰成员函数

   **静态成员函数**可以在**对象实例化之前被调用**，不与类一起存储，也正是因为被同一个类下的多个对象共享，静态成员函数内部是无法使用过this指针来指向成员变量的。自然**静态成员函数也就无法访问属于类对象的非静态成员变量**了。**类内的非静态成员函数和静态成员函数都存放在代码区（代码段）**。非静态成员函数也正是因为函数**内部有this指针**，所以只能被类对象调用，而**不能直接被类调用**。

   虽然函数存放在代码区，但是**函数参数、函数返回值、函数返回地址、局部变量等都存放在栈区**

###### 2.C++继承与虚函数

C++的多态分为**静态多态**和**动态多态**。**静态多态**是**重载**和**模板技术**实现，在编译的时候确定（函数重载和运算符重载，原来这个也属于多态）。动态多态通过**虚函数**和**继承关系**来实现，执行动态绑定，**运行的时候才确定**。

动态多态的条件：

1. 父子的垂直关系，让父类的指针或引用指向子类对象
2. 类内有虚函数

动态多态的过程：

当父类指针调用成员虚函数的时候，就会去查找该对象的虚函数表，**虚函数表的地址**在每个**对象的首地址**。查找该虚函数表中的指针进行调用。注意，**虚函数表并不在对象中**，每个对象保存的只是一个虚函数表的地址！

C++内部为每一个类维持一个虚函数表，**该类的对象都指向同一个虚函数表**。

虚函数表直接从父类继承过来，子类对象中覆盖了其中某个虚函数并且父类指针或者引用指向子类对象的时候，虚函数表中保存的函数指针就会被替换，所以根据指针就能准确找到该调用哪个函数。

###### 3.virtual修饰符

如果一个**类是局部变量则该类数据存储在栈区**。该类是通过new/malloc动态申请的，**该类数据存储在堆区**。函数的局部变量应该是存放在栈区的。

如果该类是virtual继承(指的是父类带有虚函数)而来的子类，该类的**虚函数表指针和该类其他成员一起存储**。虚函数表指针存放在对象的首地址，指向**只读数据段中的类虚函数表**（之前提过，C++为每个类维护一个虚函数表，这里的只读数据段是也属于数据段，数据段分为数据段+bss+只读数据段，前两者是可读写的，后者是只读的）。虚函数表中存放着一个个函数指针，函数指针指向代码段中重写虚函数的函数，（所有的函数都存放在代码段中）。

总结下：类和类内非静态成员、虚函数表指针存放在栈或者堆，由创建方式决定。静态成员变量存放在全局数据段，静态成员函数、非静态成员函数、类外函数，也就是说所有的函数存放在代码段中。类的虚函数表存放在只读数据段中，函数的局部变量存放在栈中。

##### 假设临界区资源释放，如何保证只让一个线程获得临界区资源而不是都获得？

这其实是一个互斥问题，可以增加一个互斥锁、也可以使用二值信号量，增加一个自旋锁也可以，如果是内核空间下还可以使用完成变量，具体用哪种根据上下文决定。

##### 操作系统中的缺页中断是什么？

缺页中断本质上属于软中断，这是一个异常，内存管理的时候发现内存中没有相应的页面，就需要触发软中断，执行缺页中断服务程序从外存中将需要的页面调入到内存中。这里会用到页面换入换出的算法，包括最佳置换算法、先入先出、时钟、改良版时钟、最近最少使用算法来决定将哪个页面换出。

---

没想到这里我又错了。

malloc和mmap等内存分配函数，在分配的时候只是**建立了进程虚拟地址空间**，并没有分配虚拟内存**对应的物理内存**。（这句话说的很有深度，其实就是建立了让进程以为自己拥有了一段连续足够的内存，但实际上很多东西并没有调入物理内存中）当进程**访问这些没有建立映射关系**的虚拟内存时（进程访问这些没有对应页的段时候），处理器自动触发一个缺页异常通过执行SWI指令实现的

缺页中断：在请求分页系统中，通过**查询页表中的状态位**（时钟算法就是增加了访问位，改良版时钟还增加了修改位）**确定**所要访问的**页面是否存在于内存**中。每当所要访问的页面不在内存中时，**产生一次缺页中断**，此时操作系统**根据页表中存放的外存地址在外存中找到所缺的页**，调入内存。写时拷贝就是缺页中断实现的，通过调用vm_area_struct->vm_ops实现对某一内存段的拷贝

缺页中断需要经过四个处理步骤：

1. 保护CPU现场
2. 分析中断原因
3. 执行缺页中断
4. 恢复现场

缺页中断是由于原本要访问的页面不在内存中时，由MMU**硬件产生的一种特殊的中断**，与一般的中断存在区别：

1. 在指令执行期间产生和处理缺页中断信号。(ARM体系架构中提到汇编指令执行期间是不会处理中断信号的，也正是因为这个原因，多寄存器载入和保存的时候会导致中断响应延迟，编译器限制了多寄存器同时装载的上限，保证中断延迟不大)
2. 指令执行期间可能产生多次缺页中断
3. 缺页中断返回执行产生中断的指令 ，一般的中断返回的是执行下一条指令。

##### OS缺页置换算法如何实现？

缺页置换算法由五种，而缺页置换是因为访问了一个内存中 不存在的页，并且内存已满，此时就需要从内存中调出一页送到磁盘对换区，替换一个页。这就是缺页置换。

FIFO算法的实现：按照进入内存的先后次序排成队列，队尾进入，队头删除。

LRU算法的实现：采用循环链表进行管理，被访问过的页面访问位置一，遍历到置零，如果访问位为0直接替换。Linux内核中采用的是LRU/2，非活跃链表和活跃链表实现的，刚调入的页面去活跃链表，而活跃链表去非活跃链表。非活跃链表直接被置换。

##### 系统调用是什么，用过那些系统调用，和库函数什么区别？

这题一看就是熟悉，系统调用分为应用层和内核层，应用层的系统调用就是把系统调用号传入内核层，并且触发软中断陷入内核层，从而执行内核层的系统调用函数。用过open/read/write/malloc/close等等，系统调用是库函数的底层实现，标准库函数的功能会比系统调用更丰富些。库函数的可移植性更强，系统调用是与硬件相关的。系统调用运行在内核态下，而库函数运行在用户态下。

---

系统调用是通向操作系统本身的接口，是面向底层硬件的。

库函数是面向应用开发的。不同的系统，调用库函数的话，库函数会调用不同的底层函数实现，因此可移植性好。库函数不能用于对底层驱动设备的操作。

###### 区别

1. 库函数是语言或者应用程序的一部分，而系统调用是内核提供给应用程序的接口，属于系统的一部分。
2. 库函数是在用户地址空间执行，系统调用是在内核地址空间执行，库函数运行在用户态下，系统调用运行在内核态下，库函数开销比较小，系统调用开销比较大。（这里的开销就是因为有**缓冲区所以开销小**）
3. 库函数是有缓冲的（会建立用户缓冲区），系统调用是无缓冲的（其实也会建立内核缓冲区，但确实比库函数少了一个缓冲区）。
4. 系统调用依赖于平台，库函数并不依赖，所以库函数移植性好。

##### 为什么要用page cache，操作系统怎么设计的page cache?

---

快表的话，作用很明显，把一部分页表项保存在快表中，与它相对应的是慢表，慢表保存在内存中，两者都是存储的页表项，快表是存放在CPU的寄存器中，当需要用到的页面的时候优先去快表中查找，如果找到了就从内存中寻找页面对应的物理块，设计这个快表是防止抖动现象的产生，减少cpu访问外存的次数，提高cpu的工作效率。

快表和缓存虽然都在CPU中，但是缓存保存的是数据与指令，分为数据cache和指令cache，快表保存的是页表项。

内核中有单独的一章专门讲页缓存的，我居然忘了，但是我看完之后发现页缓存是Linux内核实现磁盘缓存的方法。就是把磁盘中的页面保存在物理内存中，应该是把物理内存的一部分作为一个缓存，用来保存那些最近被访问的文件数据块。这和快表不是一回事，快表是把页表项保存在CPU的寄存器中。快表是通过把一部分页表项保存在寄存器中从而提高cpu访问页表的速度，而页缓是通过把一部分页面保存在内存中，从而提高cpu访问页面的速度。快表是一种特殊的缓存

---

加快内核访问磁盘的速度。**page cache是一部分磁盘的页面保存在内存中**。读取文件先访问page cache，如果命中了就直接访问，不需要去磁盘中读取了。

Linux内核中，通过**两个数据结构**管理这些cache项，一个是**radix tree**，另一个是**双链表**。前者是**二叉搜索树**。Linux内核利用搜索树（左子树小于根小于右子树）。通过文件内偏移快速定位cache项。后者指的是**活跃链表和非活跃链表**，非活跃链表上的页面被用来换出，然后把换入的页面从尾部加入到活跃链表。当活跃链表节点超过非活跃链表的时候，就把头部给非活跃。这种方法被称为LRU/2，LRU是最近未使用策略，维护的是一个链表。这里管理的是页缓存的，并不是整个主存中的页面的。

#### 上下文

##### 上下文有哪些？怎么理解？

---

说说我自己的理解，当初学内核频繁接触，上下文理解为一种环境，包括进程上下文和中断上下文。保存上下文/现场，实际上就是把当前cpu的寄存器保存到栈上，所以上下文指的是当前执行进程的种类，以及cpu的环境，种类不同，上下文也不一样，比如如果是快速中断的话，人家是有自己专属的寄存器R8-R14，每种工作模式都会映射不同的寄存器。具体来说，R0-R7属于未分组寄存器，所有的工作模式都可以访问的，而R8-R14是分组寄存器，五种异常工作模式对应五种寄存器。系统模式和用户模式没有R8-R14.

---

**上下文就是环境**

所谓的进程上下文，就是**当发生切换空间的时候，用户进程传递给内核**的这些**参数**以及内核要**保存的那一整套的变量**和**寄存器值**和**当前环境**。比如用户进程通过系统调用进入内核空间就要把系统调用号保存到eax寄存器中从而传递给内核。另外如果此时进程被其他进程抢占了，还要保存当前进程的变量、寄存器值和当前环境。

进程的上下文可以分为三个部分：**用户级上下文**、**寄存器上下文**、**系统级上下文**。

1. 用户级上下文：**正文**、**数据**、**用户堆栈**以及**共享存储区**这里指的是数据段吧；
2. 寄存器上下文：**通用寄存器**(31个寄存器)、**程序计数器**PC、**当前程序状态寄存器**CPSR。这个要保存到SPSR中、**栈指针**SP。（学栈帧结构的时候指向栈顶的指针，还有一个帧指针是指向栈帧结构的头）。
3. 系统级上下文：**进程控制块**PCB，**内存管理信息**(**mm_struct**(进程地址空间，内核线程的这个指针指向NULL，当进程被调用，进程的mm域指向的地址空间被装载到内存，所以这里的mm_struct指向的是进程地址空间也就是虚拟地址4GB)，内核线程没有用户空间下的物理内存/**vm_area_struct**（这里指向的是进程虚拟地址空间中的一部分内存）/**pgd**(这个是多级页表中的顶级页表-页全局目录)/**pmd**（这里有点问题，pgd是Linux下的页全局目录，而pte是windows下的二级页表，Linux下的**三级页表**），应该是pmd)、**内核栈**。

其实用户上下文就是进程在用户空间下留下的信息，寄存器上下文就是进程在cpu的寄存器中留下的信息，系统上下文就是进程在内核空间中留下的信息。

发生进程调度的时候，需要进行进程切换也就是上下文切换(context switch)。操作系统必须对上面三种上下文都进行切换，新调度的进程才能运行。而**系统调用**进行的切换是**模式切换**（mode switch其实这里的模式切换就是ARM工作模式的切换）这种切换**只需要保存寄存器上下文**即可。这是因为ARM工作模式的改变会导致，模式切换可以是直接操作cpsr中的[4:0]，也可以通过指令进行模式切换。

banked寄存器映射，每种模式都拥有自己的寄存器。模式切换容易很多，而且节省时间。

硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。应该是工作模式也切换成IRQ模式了，这个过程中硬件的一些**变量和参数**也传递给内核了，内核通过这些参数进行中断处理。

所谓的中断上下文，其实就是**当用户空间坠入内核空间时，硬件传递给内核的参数以及内核需要保存的其他环境（当前被打断的进程的环境。）**。运行中断处理程序时，内核不代表任何进程运行，只访问系统空间，不访问进程空间（也就是进程地址空间，进程运行的虚拟空间）。内核在中断上下文中执行的时候不会被阻塞。中断中不要嵌套中断，因为中断即使有着自己专属的内核栈，也有可能因为嵌套过多的中断导致栈溢出。

这里的中断上下文应该不包括用户级上下文。

##### 为什么会有上下文这种概念？

之前一直不理解，其实就是当切换空间时的当前环境。因为每次进程切换、模式切换、中断切换，最后还是要切换回来的，所以必须保存被打断进程、模式的执行环境，而为了更容易理解的保存这些环境。提出上下文的概念。

---

因为**因为处理器具有多种工作模式，每次切换工作模式都需要保存信息**。

处理器总是处于以下状态中的一种：

- 内核态，运行于进程上下文，内核代表进程运行于内核空间。（使用进程内核栈运行在内核空间）
- 内核态，运行于中断上下文，内核代表硬件运行于内核空间。
- 用户态，运行于用户空间。

**操作系统的两种不同运行状态，才有了上下文的概念。**

举个例子，用户空间的**应用程序**想要**操作某个物理设备**，需要通过**系统调用**让应用程序进入内核空间，由**内核代表本进程运行在内核空间**，这里发生了两种运行状态的切换，涉及到**上下文的切换**了。而用户空间和内核空间具有**不同的地址映射**以及**通用或者专用的寄存器组**，而**用户空间的进程要传递很多变量、参数给内核**，**内核 也要保存用户进程的一些寄存器、变量**等以便系统调用结束后返回到用户空间能**继续执行。**

虽然两种运行状态有了上下文的概念，但是进程上下文切换始终是在用户空间执行，虽然会需要保存系统上下文，但没有发生运行状态的切换。系统调用也属于进程上下文，所以还是因为两种运行模式导致的上下文概念。

##### 什么情况下进行用户态到内核态的切换？

比如系统调用的时候，发生中断的时候，异常的时候

---

- 进程上下文中的**系统调用**会导致模式切换，**异常**也会导致模式切换，内核之所以进入进程上下文是因为进程自身的一些工作需要在内核中做。
- 中断上下文是由于硬件发生**中断**时会触发中断信号请求，请求系统处理中断，执行中断服务程序。

##### 中断上下文代码中有哪些注意事项？

不能睡眠，尽量避免中断嵌套中断，快进快出，**不能访问用户空间的虚拟地址**（这个没有想到）。因为中断运行在内核空间。外部中断实际上是走的驱动模块中的中断服务函数，所以确实没访问用户空间的虚拟地址。

##### 请问线程需要保存哪些上下文、sp、pc、eax、lr、sl这些寄存器是干嘛用的？

因为系统资源分配的基本单位是进程，而从内核的角度看，线程是属于共享进程资源的进程。所以线程需要保存哪些上下文，需要保存寄存器上下文（31个通用寄存器、CSPR、PC、因为线程也有函数调用，所以栈帧结构也要保存--esp栈指针）、系统上下文（线程也有自己的进程控制块PCB、内核栈、内存管理信息这个应该不需要吧，毕竟是共享进程的）、用户上下文（正文、数据、共享存储区、用户堆栈）。

sp是存储内存指针的。堆栈指针，指向当前栈的栈顶地址，esp与sp共用相同的寄存器，sp是esp的低16位。堆栈指针是用来操作堆栈的LDMFA和STMED

pc是程序计数器，保存的是正在运行的指令的下一个，

指令。

eax是系统调用的时候需要把系统调用号保存到eax中从而传递给内核空间。累加寄存器，用于加法乘法的缺省寄存器。两个功能都有。pc是r15，lr是r14，sl是r10堆栈限制。

---

二刷八股结束，学到很多，面试要先用一句话概括答案，然后按照面试节奏细说，打乱面试官的节奏可能会导致对方问不出好问题或者问太难了。

并且学过的那些书籍是不会单独出问题的，都是依据八股扩展回答。不要死记硬背，也不要把学过没用过的东西写到简历上。

三刷八股，其实没啥用，就是复习，确实忘记好多了。

------







#### Linux内核扩展

##### 什么是微内核、单内核？

- 微内核**功能被分为多个独立的过程**，所有的过程都保持**独立并运行在各自的地址空间上**。需要通过**进程间通信**来实现**微内核的通信**。IPC的开销**多于函数调用**

- 单内核是静态二进制文件存放在磁盘中，整体上**作为一个单独的大过程实现**，运行**在单独的地址空间上**。可以**直接调用函数**，高效。

  Linux属于采用了单内核的体系设计，以及微内核的设计思想，提供了动态加载的功能。

##### Linux与Unix的区别

- Linux支持SMP处理器
- Linux不区分进程和线程
- Linux支持**内核抢占**
- Linux开源
- Linux可以动态加载和卸载内核模块
- Linux提供设备类的面向对象的设备模型

##### 为什么2.6内核前的进程描述符task_struct存放在内核栈的尾部，现在又不用 了？

栈的尾部就是栈顶位置，这是esp指向的地方，这么做是为了让x86这种寄存器较少的架构不需要**额外浪费寄存器**资源来专门记录，用栈指针就可以计算出他们的位置了。（具体的计算实际上就是current_thread_info函数中进行的，返回thread_info结构体）

现在是由**slab分配器生成task_struct**会创建指向进程描述符的指针，**只需要在栈的最下方创建一个结构体thread_info**，将指针保存到结构体thread_info中即可。并且该指针必须是结构体的第一个成员（这里涉及到结构体成员的地址分配问题，按照声明顺序从小到大分配地址，所以结构体第一个成员就是在内核栈中最下方）。

##### current_thread_info()函数有什么用

这是内联函数，返回值指向thread_info指针，通过这个函数找到thread_info结构体，进而找到task_struct结构体。

##### 为什么PID最大值是32768？

为了与老版本的Unix和Linux**兼容**，short int是15位二进制的最大值。进程标识符的最大值限制了当前系统的进程上限，不处理僵尸进程的后果就是PID被占用，最后系统无法申请PID了。

##### 栈指针的结构，以及如何计算出thread_info偏移的？

esp是栈指针的寄存器，与sp共用寄存器，sp是esp的低十六位，把esp的高13位屏蔽掉从而计算出偏移的。对于寄存器丰富的体系架构是专门用一个寄存器存储task_struct指针的。

##### 内核中进程状态分为多少种？

- TASK_INTERRUPTIBLE，进程正在睡眠可中断
- TASK_UNINTERRUPTIBLE，进程正在睡眠，不可中断
- TASK_STOPPED，进程被终止
- TASK_RUNNING，进程是可执行的或者正在执行
- TASK_TRACED，被跟踪的进程，死掉的时候会给跟踪你的进程发送SIGCHID。

之前介绍进程状态的时候详细介绍过。

进程终止之后会被打上僵尸状态:EXIT_ZOMBIE，不过这种状态针对的是exit_state。

##### 内核如何设置进程状态？

通过函数set_task_state(task,state)，task->state = state。注意这里是state并不是exit_state。这个函数与set_current_state(state)等同。

##### 内核将current_thread_info如何进行宏定义的？

```c
#define get_current() (current_thread_info()->task)
#define current get_current()
```

所以最后就是current宏直接找到了进程描述符。

##### 进程如何找到其父进程和若干个子进程的？

进程的进程描述符中有个成员current->parent这是指向父进程的指针，并且有current->children的子进程链表。

##### 如何从当前进程遍历到init进程？

1. 通过继承体系查找
   ```c
   for(task = current;task !=&init_task;task = task->parent)
   ```

   这里的init_task就是**init进程的进程描述符**了，这里并不是slab分配器分配的，而是**静态分配**的。这种方式并不是通过任务队列找到的，而是通过进程的父子关系找到的。
   
2. 因为任务队列是一个双向循环链表，对于给定的进程，获取链表中的下一个进程也可以。

   ```c
list_entry(task->tasks.next,struct task_struct,tasks);
   ```
   
   还可以通过宏for_each_process来找到
   
   ```c
   for_each_process(task){
   //输入进程描述符，每次循环自动变成下一次进程描述符
       printk("%s%d",task->comm,task->pid);//comm是可执行文件的名字
   }
   ```
   
   轻易不要遍历任务队列。

##### fork函数的具体执行流程

1. fork根据自己需要的**参数去调用clone**()，然后由**clone去调用do_fork**()。
2. **do_fork**()函数调用**copy_process**()函数，此函数再调用**dup_task_struct**()函数，为**新进程创建一个内核栈**，此时thread_info和task_struct与父进程**一模一样**。
3. **检查**斌确保新创建这个子进程后，当前用户所拥有的进程数目没有超出上限**pid_max**。
4. 子进程着手于自己与父进程区分开。此时**进程描述符**内的许多成员**被清零**或者设为初始值。
5. 子进程的状态**被设置为不可中断状态**，确保不会投入运行、不会接收信号提前唤醒。
6. copy_process()函数调用copy_flags()更新task_struct的flags成员，**清除进程权限**。
7. 调用alloc_pid()为**新进程分配一个有效的PID**
8. 根据传递给**clone的参数标志**，copy_process()拷贝或**共享**打开的**文件**、文件系统**信息**、**信号处理函数**、**进程地址空间和命名空间**。这里是因为写时拷贝才共享的。这里的四个分别对应线程的FILES/FS/HAND/VM
9. copy_process()做扫尾工作，**返回**指向**子进程的指针**。

简单地说就是

1. 创建新的内核栈
2. 检查进程数量
3. 子进程的进程描述符清零
4. 子进程进阻塞，防止被调用，之前提到过uninterruptible适用于必须等待事件和事件很快到来的场景，比如创建子进程的时候就需要。
5. 清除进程权限
6. 分配PID，这就是返回给父进程的返回值。
7. 共享父进程的资源，这是在不执行exec的情况下
8. 返回子进程的指针，fork大于零的返回值是子进程的PID返回给父进程的 

##### vfork函数的具体执行流程

1. task_struct的vfork_done成员设置NULL
2. 根据标志设置vfork_done
3. 子进程先开始执行，子进程通过vfork_done指针向父进程发送信号，子进程执行**complete**函数**唤醒父进程**执行
4. 执行exec函数后父进程醒来并返回vfork。

##### 内核中线程与进程的区别

对于内核而言，线程是一个与其他进程共享某些资源的进程。每个线程都拥有自己的task_struct。

##### 内核中创建线程、子进程时传递给clone函数的标志有什么区别？

```C
clone(CLONE_SIGCHLD,0);//fork，SIGCHLD表示创建的是子进程，因为写时拷贝，其实子进程拥有线程的四个标志符
clone(CLONE_VFORK|CLONE_VM|CLONE_SIGCHLD,0);//vfork，表示共享地址、父进程阻塞等待子进程唤醒，创建子进程
clone(CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND,0)//创建线程，共享信号处理函数、共享文件系统信息，共享地址、共享已打开的文件
```

从这里一看出来，fork就是创建子进程，共享父进程好处。vfork会阻塞父进程，共享进程地址空间这个操作和线程很像。线程本身就是共享进程资源的进程。

##### 内核线程与普通进程的区别

- 内核线程**没有独立的地址空间**。task_struct进程描述符中的mm_struct指针是指向NULL的。这里的mm_struct结构体属于系统上下文中的内存管理信息。
- 内核线程只在内核空间运行，**不切换去用户空间**
- 内核线程与进程一样可以**被调度、被抢占**
- 内核线程**只能由内核线程创建**
- 内核线程启动之后就**一直运行**直到退出。

##### 进程终结的具体流程

1. 将task_struct中的flags设置为PF_EXITING，之前子进程创建的时候清空过，防止变成某进程的养父。
2. 调用del_timer_sync()**删除内核定时器**。确保没有定时器在排队
3. 输出BSD的进程**记账信息**
4. 调用exit_mm()函数**释放**进程占用的mm_struct，这里指的是**进程地址空间**
5. 调用sem_exit()函数，如果进程在排队等待IPC信号，**离队**。
6. 调用exit_files()和exit_fs()递减文件描述符、文件系统数据的引用次数。如果引用次数为零，代表没有进程在使用相应的资源，**释放资源**。
7. 把task_struct->**exit_code**中的任务**退出代码**设置为由exit()提供的退出代码。为了在wait函数给子进程收尸的时候查看退出原因。
8. 调用exit_notify()向**父进程发送信号**，给结束进程的子进程**找养父**，养父为进程组中的其他进程或者init进程，并把进程状态task_struct->**exit_state**设置为**EXIT_ZOMBIE**
9. do_exit()调用schedule()**切换到新进程**。

简单的总结下：

1. 将自身设置死亡flag，防止其他子进程找本进程做养父
2. 输出进程的记账信息
3. 释放进程地址空间
4. 释放进程资源
5. 设置收尸信息-**退出代码**
6. **告知父进程，给子进程找养父，自身变成僵尸状态**
7. 调度器执**行新的进程**

##### 父进程为子进程收尸的具体流程

1. wait()调用wait_task_zombie()函数，然后调用release_task()函数
2. 调用_exit_signal()函数，该函数调用__unhash_process()，调用detach_pid()从pidhash上删除该进程，从**任务列表中删除该进程描述符**
3. _exit_signal()**释放僵尸进程的所有剩余资源**，进行最终记录和统计
4. release_task()通知进程组中僵尸领头进程的父进程
5. release_task()调用put_task_struct()**释放进程内核栈和thread_info结构所占的页**，释放task_struct所占的**slab高速缓存**。

简单的说就是

1. 删除任务队列中的进程描述符
2. 释放剩余资源
3. 释放内核栈和slab高速缓存。fork创建进程的第一步就是分配内核栈。fork创建子进程八步，vfork是四步主要是vfork_done指针，进程终结是七步先设置flag，最后执行调度器。收尸是三步，不断的释放资源。获取退出代码最后释放内核栈。

##### 在内核中父进程与真实父进程的区别

task->parent此指针指向的就是父进程的进程描述符，但是这里的父进程指的是跟踪当前进程的父进程，本进程死掉的时候会发送SIGCHLD给跟踪父进程。

task->real_parent此指针指向的就是真实父进程，这是当初用fork创建本进程的父进程。

##### 子进程什么时候找养父以及找谁作为养父？

在父进程执行do_exit()函数退出时，会帮子进程以及跟踪的子进程寻找养父。

有可能返回三种进程作为父进程

1. 原结束进程**所在线程组**中的符合要求的进程（没有死亡flag）
2. 元结束进程**所在进程命名空间**中的托管进程
3. **init进程**

##### 找到养父之后还有什么操作

- 找到养父之后需要**遍历所有的子进程链表**，为他们设置养父进程实际上是把task->real_parent = 养父
- 并且还要为被跟踪的子进程找到养父。**遍历跟踪子进程的链表**

##### 子进程链表和ptrace子进程链表存在的意义

以前内核中需要遍历系统所有进程来找到这些子进程，现在通过两个较小的链表减轻遍历的消耗。

##### IO消耗型进程和处理器消耗型进程

- 进程的大部分时间用来提交IO请求或者等待IO请求，进程更多时间在阻塞，GUI属于IO消耗型，具有良好的响应速度
- 进程大多数时间在执行代码，除非被抢占否则一直运行。

##### Linux采用的两种优先级

1. nice值，范围从-20~19，数值越大优先级越低，在Linux中nice值表示该进程在整体进程时间片的占比。默认值是0
2. 实时优先级，范围是从0~99，数值越大优先级越高，实时优先级的进程比普通进程的优先级高。

##### 在Linux系统中使用ps指令能看到什么？

- state，进程状态，这里包括了task->state和task->exit_state两种都体现了
- uid，用户ID
- pid，进程号
- ppid，父进程号
- rtprio，实时优先级
- time，
- comm，这是task->comm，不涵盖路径名的可执行文件名。

##### Linux内核采用的进程调度算法是什么，能否举个实例

采用的CFS算法（完全公平算法），这算法并**没有直接分配绝对值的时间片给进程**，而是将**处理器的使用比划分给了进程**，这个使用比会**受到进程nice值的影响**，**优先级越高使用比越高**。抢占时机取决于**新的可运行程序已经消耗了多少处理器使用比**，如果**已经消耗量比当前值少，抢占当前进程**。

完全公平调度是针对**普通进程的调度类**，在Linux中被称为SCHED_NORMAL。

比如当前有文本编辑器和视频解码程序两个进程，假设这两个进程的nice值相同，那么此时处理器占比是各分50%。文本编辑器因为时间都用来等待用户操作也就是阻塞了，所以处理器占比消耗不多，小于视频解码程序，这也导致了文本编辑器的优先级是高于后者的，所以每次用户输入的时候文本编辑器会直接抢占处理器。然后文本编辑器就会陷入阻塞，视频解码器接管。CFS考虑到了交互进程这种花费时间少，还需要快速相应的进程。

##### 调度器类的作用是什么？调度器优先级是什么？

作用是允许**不同类型的进程**可以有针对性地**选择调度算法**。调度器优先级就是**调度器的**就绪队列中**可执行状态**的**最高的进程优先级**。

##### Unix系统中的进程调度存在什么问题？

unix系统中的进程调度里，**高nice值可以分配到更多的绝对长度的时间片。并且抢占优先级也是nice值决定的。**而高优先级的往往都是交互进程，但这些交互进程不需要长的时间片，那些后台进程多是计算密集型需要更多的时间片。

##### CFS调度器中无限小调度周期是什么？目标延迟又是什么？

无限小调度周期：CFS调度器希望每个进程只运行非常短的周期，这样可以带来更好的交互性，**所有进程都调度一次的时间**。

目标延迟：当执行了当前进程之后，下一次执行就是一个调度周期之后了，所以目标延迟了一个调度周期。所以**目标延迟就是一个调度周期**。

##### 如果可执行的任务数量趋近于无穷，CFS调度器怎么办？

CFS调度器给**每个进程引入了时间片底线**，这个底线称为最小粒度。默认情况下是1ms。

##### CFS调度器中nice值是如何影响处理器时间片占比的？

**绝对的nice值**不再影响调度决策，只有**相对值**才影响处理器的时间片分配比例。比如nice=0和nice=5两个进程之间的时间片占比是3:1，那么nice=10和nice=15两个进程之间的时间片占比依旧是3:1。

##### CFS调度器为什么称为完全公平调度器？

因为它确保每个进程公平的处理器使用比，不会出现**优先级差相同**，而占比不同的**结果**。

##### CFS调度器的四个组成部分

1. 时间记账，进程终结的时候第二条就是输出BSD进程记账，记录进程的时间片使用情况。
2. 进程选择
3. 调度器入口
4. 睡眠和唤醒

##### 为什么CFS调度器需要维护时间记账功能？

系统时钟节拍发生时，进程的时间片就会减少一个节拍周期，**CFS调度器需要确保每个进程只在公平分配给他的处理器时间内运行。**之前提到过进程终止的时候会输出进程的记账信息，指的就是CFS调度器维护的记账。task_struct->se就是调度器实体。struct sched_entity se

##### 进程的虚拟运行时间是什么？有什么用？

vruntime变量存放进程的虚拟运行时间。表示**进程花在运行上的时间和**。update_curr()实现该记账功能。

**CFS调度算法的核心就是选择具有最小的vruntime任务。**

##### CFS调度算法如何找到具有最小的vruntime任务？

CFS调度器**使用红黑树来维护就绪队列**，vruntime就是红黑树节点的键值利用其搜索树的特性迅速找到最小vruntime值的进程。**该算法可以总结为运行rbtree树最左边的叶子结点所代表的进程。**

##### 找到最左叶子结点的函数以及挑选下一个任务函数是什么？

```c
static struct sched_entity *__pick_next_entity(struct cfs_rq *cfs_rq)//函数名称是挑选下一个实体
struct rb_node*left = cfs_rq->rb_leftmost;//这是红黑树的节点结构体类型。
struct task_struct* rb_entry(left,struct sched_entity,run_node)；//此函数返回值就是具体的运行进程了。
```

返回值是调度器的实体，实参是cfs调度器的就绪队列cfs_rq，实际上最左叶子结点已经保存在**就绪队列结构体中了cfs_rq->rb_leftmost**。当rb_entry返回值为NULL的时候，说明没有进程是可运行状态的。

##### 向树中加入进程的函数

```c
static void enqueue_entity(struct cfs_rq *cfs_rq,struct sched_entity *se,int flags)
    static void __enqueue_entity(struct cfs_rq*cfs_rq,struct sched_entity *se)//这是最终调用的函数
```

每个进程中都保存一个调度器实体 ，用来记录进程运行的信息。红黑树中插入进程发生在进程状态变成**运行时或者进程刚创建时**。（创建内核栈、检查pid_max、进程描述符初始化为0、清除进程描述符的flags、设置阻塞状态、申请PID、共享父进程资源、返回子进程指针）

##### 向树中删除进程

```c
static void dequeue_entity(struct cfs_rq*cfs_rq,struct sched_entity *se int sleep)
```

红黑树中删除进程发生在**进程阻塞或者终止**时。

##### 调度器入口函数的执行流程

schedule()是调度器的入口函数，重点是调用了**pick_next_task**()函数，该函数以优先级为序从高到低依次检查每一个调度类，并且从最高优先级的调度类中选择最高优先级的进程。

##### 睡眠与唤醒的执行流程

- 睡眠：进程把自己标记成休眠状态（这里有不可中断和可中断两种阻塞色状态），从可执行红黑树中移除，放入等待队列（两种状态放入同一个等待队列中），然后调用schedule()选择和执行一个其他进程。
- 唤醒：进程被设置为可执行状态，然后从等待队列中移到可执行红黑树中。

##### 上下文切换具体流程

schedule()最终调用context_switch()函数。完成两个工作。

- 函数负责把虚拟内存从上一个进程映射切换到新进程中。指的是切换进程地址空间吧
- 函数负责从上一个进程的处理器状态切换到新进程的处理器状态。这里指的是修改ARM工作状态。

##### 调用schedule函数有哪些途径？

不仅仅是用户程序中显式的调用schedule()函数。内核还会检查进程描述符中的成员，task->need_resched。表明是否需要执行一次调度。当**某个进程应该被抢占**、**优先级高的进程进入就绪队列**时都会设置标志，内核检查该标志。

##### 什么是用户抢占？

进程从内核态切换到用户态时，如果need_resched标志被设置了会导致调度，发生用户抢占。

##### 内核抢占与用户抢占的区别

内核抢占需要保证抢占是安全的才可以发生。thread_info->preempty_count成员表示当前进程持有锁数量，只有当其为0的时候内核抢占才是安全的。当**隐式need_resched=1且preempty_count=0或者显式的调用了schedule()函数**才会导致内核抢占。

##### 什么是实时调度策略？

CFS调度属于普通进程的调度策略，SCHED_NORMAL，是属于非实时调度策略的，动态优先级。SCHED_FIFO和SCHED_RR这两种属于**静态优先级**。

##### 软实时工作与硬实时工作的区别？

软实时的含义是内核调度进程的时候尽力使进程在他的限定时间到来前运行，硬实时的含义是在一定条件下，可以**满足任何调度的要求**。

#####  放弃处理器时间

进程调用**sched_yield**()函数时，会导致从活动队列移到过期队列中，确保一段时间内不会被执行了。实时进程不会过期，只会放到优先级队列的最后面。

#####  什么是POSIX标准

POSIX是由IEEE的一组标准组成，目的是提供一套大体上基于Unix的可移植操作系统标准。

#####  Unix只提供机制而不提供策略是什么意思？

机制指的是需要什么样的函数，策略指的是这个函数如何调用，操作系统只提供系统调用，具体如何操作是用户的事情。

##### asmlinkage限定词什么意思？

这是一个编译指令，**通知编译器仅从栈中提取该函数的参数**。所有的系统调用都需要这个限定词。在内核中的系统调用需要遵守命令：命名时加上前缀sys_

#####  系统调用号有什么用？

当用户空间的进程执行一个系统调用的时候，这个系统调用号就用来指明到底是要执行内核中的哪个系统调用。通过查看系统调用表，借助系统调用号找到每一个系统调用。

##### 系统调用的具体流程是什么？

通过引发一个异常陷入内核空间去执行异常处理函数，首先在用户模式下执行SWI指令，该指令会切换工作模式位SVC，然后计算SWI指令对应的SWI号从而调用对应的处理函数，这个异常处理函数就是软中断号为128的系统调用处理程序system_call()。在用户层的时候讲过相应的系统调用号存入eax中，system_call()函数通过将给定的系统调用号与**NR_syscalls**比较如果大于或者等于则系统调用号有效。然后查找系统调用表最终找到sys_系统调用函数。系统调用执行完毕（这里具体执行其实是去VFS层找到inode结构体，进而找到驱动层中的cdev->file_operations从而执行操作函数）后，依旧是返回到system_call()函数，由此函数赋值切换到用户空间。

##### 注册系统调用的步骤有哪些？

1. 在系统调用表的最后加入一个表项。每种支持该系统调用的硬件体系都必须做这样的工作。
2. 对于所支持的各种体系结构，系统调用号必须**定义**在<asm/unistd.h>
3. 系统调用必须被**编译进内核映像**而不是编译成模块。

##### 系统调用如何获得C库的支持？

Linux本身提供给了一组宏，用于直接对系统调用进行访问，会设置好寄存器并调用陷入指令（SWI指令会触发软中断并通过寄存器传递参数）。实际上C库的底层是用户层的系统调用函数，这里所谓的系统调用函数实际上就是由这组宏实现的。

##### 如何找到包含链表节点的父结构？

通过宏container_of()可以从链表指针找到父结构中包含的任何变量。一个给定结构中的变量偏移在编译时地址就被ABI固定下来。

##### 映射的在内核以及STL中的应用

映射指的就是<key,val>这种键值对组成的数据结构。映射可以由散列表实现也可以由红黑树组成。

##### 内核数据结构的选择

- 遍历数据、存储较少的数据、需要与其他链表交互时，使用链表
- 如果符合生产者/消费者模式、先入先出、定长缓冲时，使用队列kfifo
- 如果需要映射一个UID到一个对象，就是用映射。

##### 注册中断处理程序的具体流程

1. 驱动程序通过request_irq函数注册。传入中断号、中断处理函数的函数指针，中断标志，名称，设备
2. 其中函数指针类型有两个形参，分别是int中断号和一个设备用于传递有用的环境 信息，方便内核创造执行环境。参数dev必须与注册函数中的一致，用于区分共享中断号上的不同设备。
3. 中断标志可以为NULL、IRQF_DISABLED禁止其他中断、IRQF_SAMPLE_RANDOM中断间隔作为熵填充到熵池中、IRQF_TIMER系统定时器中断、IRQF_SHARED多个处理共享中断线。
4. 名称表示字符形式，名字被/proc/irq和/proc/interrupts文件使用。
5. 设备dev用于共享中断线，提供唯一的cookie从诸多中断处理程序中删除指定的那一个。
6. request_irq()成功执行返回0，非零值表示错误-EBUSY，表示中断线被占用，需要指定IRQF_SHARED。

##### request_irq()能否用于睡眠不安全的上下文中？

不可以，request_irq函数本身会导致进程睡眠，内核需要在/proc/irq文件中创建一个与中断对应的项，这用到了proc_mkdir()调用了proc_create()函数调用了**kmalloc()函数**，此函数负责请求分配内存，分配在虚拟地址、物理地址上都连续的内存，正是这个函数**导致睡眠**的。

##### 释放中断线的具体流程

使用free_irq()函数释放中断线，如果指定的中断线不是共享的，那么该函数删除处理程序的同时将禁用这条中断线，如果是共享中断线，**仅删除dev所对应的处理程序。**

##### 编写中断处理函数需要注意什么？

中断处理函数中的形参有中断号和设备，**设备必须和注册函数中的设备一致**，中断号没有什么用了，注册函数中已经提到了处理函数，设备有用，这个用来区分共享中断号中的设备。

返回值是irqreturn_t类型。如果触发中断的并不是当前处理函数的中断号，返回IRQ_NONE，被正确调用就返回IRQ_HANDLED。

##### 中断处理程序是否需要考虑可重入性？

Linux的中断处理程序不需要考虑可重入性，当一个中断处理程序正在执行时，相应的中断线在所有处理器上都会**被屏蔽掉**。

##### 共享的中断处理程序与不共享的中断差异

1. request_irq()函数的参数flags必须设置IRQF_SHARED
2. 不共享的话dev没有用，共享中断线的话dev必须是唯一的
3. 中断处理程序必须区分是否真的产生了中断，因为共享中断线，需要判断。

##### 中断处理程序栈有多大？

2.6版本内核中，让中断处理程序拥有了自己的栈，每个处理器一个4KB。

##### 中断处理机制的具体流程

1. 设备产生中断，通过APB-AHB总线把电信号发送给中断控制器。
2. 如果中断线是激活的就把中断信号发送给处理器
3. 处理器切换工作模式进入IRQ模式(修改cpsr[4:0])，将do_IRQ()函数地址发送给PC
4. 计算出中断号后，do_IRQ()对所接收的中断进行应答
5. do_IRQ()确保这条中断线上有一个有效的处理程序，调用handle_IRQ_event()来运行此中断线上所有的中断处理程序 
6. handle_IRQ_event()函数对于那些dev不符合的就返回IRQ_NONE，然后执行dev符合的中断处理程序
7. 执行完中断处理程序之后，do_IRQ()函数做清理工作然后跳转到re_from_intr()函数检查是否需要重新调度

##### 中断上半部和下半部执行的任务区别

- 时间敏感，放入上半部
- 硬件相关，放入上半部
- 不可被打断，放入上半部
- 其他任务，放入下半部

##### 什么是BH机制？

早期的Linux提供的下半部机制bottom half，这是由32个bottom halves组成的链表，上半部通过一个32位整数中的一位来表示哪个bottom half执行。

##### 什么是任务队列？

内核定义一组队列，每个队列包含一个等待调用的函数链表。

##### 2.6版本之后内核提供了什么下半部实现机制

软中断、tasklets、工作队列，BH和任务队列被弃置了。

##### 软中断的特点

- **编译期间静态分配**
- 有softirq_action**结构体表示**，每个结构体中包含一个函数指针，形参是该结构体指针，类似于this指针。
- 定义一个包含**32个结构体的数组**，因为是定值注册的软中断数目最大值无法改变，只能用数组。
- 软中断**不会抢占另一个软中断**，支持多处理器并行执行。

##### 把整个结构体传递给软中断处理程序的好处

保证以后在结构体中加入新的成员时，**无须对所有的软中断处理程序进行改动**。可以直接提取成员。

##### SWI指令引发的软中断和中断下半部的实现方式之一的软中断区别

指令引发的软中断实际上是软件模拟硬件中断，通过指令引发保存上下文，包括中断服务程序也是指令把地址送入pc中。并且软中断期间会屏蔽一般中断。32位SWI指令屏蔽高八位的数字就是软件中断号

中断下半部的软中断是软中断是存放在结构体数组中，当中断上半部标记软中断或者内核线程ksoftirq唤醒软中断的时候才会执行。至于软中断的准备操作是由c语言设计的，并不是指令直接实现。软中断具有索引号，但是没有软件中断号。

##### 软中断执行的具体流程

1. 中断处理程序在返回前**标记**他的软中断
2. 硬件中断返回后/在**ksoftirqd**内核线程中/显式检查并执行软中断的代码中会执行软中断
3. 从do_softirq()函数开始执行，**循环遍历32位的位图**，哪一位被置1就执行结构体数组中的函数指针，和iio框架中iiotrigger申请虚拟中断后执行中断很像，遍历触发器池，看看哪个中断被响应了。

##### 什么时候使用软中断？

软中断留给**对时间要求最严格**以及最重要的下半部使用。

tasklet是**利用软中断实现**的一种下半部机制，和软中断并不是所谓的优先级比较高的普通进程。

##### tasklet和软中断的区别

tasklet**不允许**多个处理器上执行同一个tasklet。tasklet存放在两个单处理器数据结构分别表示普通tasklet和高优先级的tasklet。

##### tasklet_schedule()执行的具体流程

1. **检查tasklet状态**，如果已经被调度了直接返回
2. 调用_tasklet_schedule()
3. 保存中断上下文、**禁止中断**，保证执行调度程序的时候处理器上的数据不会被弄乱。
4. 把需要调度的tasklet**加到**每个处理器的**链表**中。
5. **唤醒软中断**，do_softirq()执行时执行该tasklet。
6. 恢复中断上下文并返回。

##### ksoftirqd内核线程存在的意义？

当大量软中断被唤醒去处理负载的时候会导致其他普通进程饥饿，为此，内核唤醒一组内核线程来处理这些负载，这组内核线程在**最低的优先级上运行**。所谓的处理负载实际上就是由这些内核线程来执行软中断。

##### 工作队列与软中断的区别

工作队列是把工作交给一个内核线程执行，这个下半部是在**进程上下文**中执行的，通过工作队列执行的代码能占尽**进程上下文的所有优势**，甚至可以重新**调度和睡眠**。

##### 工作队列的实现流程

工作队列子系统**创建工作者线程**，这是一个专门的工作者线程，从多个地方**得到被推后的工作**。每种工作者线程在处理器结构体中都有一个，都要执行worker_thread()函数，此函数**执行死循环并休眠**，当有任务插入到工作队列中，线程被唤醒。

##### 软中断、tasklet、工作队列三种比较

软中断**运行在中断上下文**中，没有顺序执行保障（不一定什么时候ksoftirq就唤醒软中断了，没有就绪队列）。tasklet也是运行在**中断上下文**中，同类型的tasklet**不可以同时执行**。工作队列运行在进程上下文中，和进程上下文一样被调度。后两者有tasklet链表和工作队列所以可以保障顺序执行。

##### 原子操作的实质是什么？

有体系结构提供的SWP交换汇编指令实现的。通过SWP交换指令实现Rm寄存器内容1存入[Rn]主存中，主存中的内容存入Rd中，判断Rd值，如果为0表示信号量未被使用，为1表示信号量已被占用则直接循环。**交换指令执行期间阻止其他指令访问该存储单元**，并占据总线，除了缺页中断外不可发生中断。

##### 原子操作为什么使用atomic_t而不是int类型？

1. 确保原子函数只接收atomic_t类型的操作数。atomic_t类型不会传递给任何非原子函数。
2. 确保编译器**不对**相应的值进行**访问优化**，使得原子操作最终接收到正确的内存地址。（volatile关键字就是这个作用，因为多线程访问共享变量+访问优化，会导致有时候读取数据是从寄存器中读取到错误数据）

```c
typedef struct{
    volatile int counter;//果然内部是volatile+int类型
}atomic_t;
```

##### 在SPARC体系结构上的atomic_t类型有什么区别？

SPARC体系结构对原子操作**缺乏指令级的支持**（没有SWP交换指令），需要**对32位中的低八位嵌入锁**，借此避免对原子类型数据的并发访问。

##### 锁机制中保护数据还是保护代码？

针对代码加锁会使得程序难以理解，容易引起竞争条件，对数据而不是代码加锁。

##### 读写自旋锁同时在一个线程中使用会导致什么？

当线程持有读自旋锁之后，在获得写自旋锁时需要等待读者释放所有的锁，而其本身就是一个持有读自旋锁的读者，所以会导致死锁。

##### 读写信号量有什么特点？

他们的引用计数为1，虽然只对写者互斥，不对读者。只要没有写者，并发持有读锁的读者数量不限。只有唯一的写者在没有读者时，可以获得写锁。

##### 读写信号量比读写自旋锁多的操作是什么？

downgrade_write()函数，此函数可以动态的将获取的**写锁转换为读锁**。

##### 信号量和互斥体优先用哪个？

只有在很底层的代码上才需要使用信号量，只要能满足约束条件就是用mutex。

##### 自旋锁和互斥体优先使用哪个？

要求低开销加锁、短期锁定、中断上下文中加锁使用自旋锁。长期加锁、持有锁睡眠使用互斥体。

##### 完成变量有什么用、用途？

内核中利用完成变量使得两个线程得以同步，完成变量仅仅提供了代替信号量的一个简单的解决方法。

因为定义在<linux/competion.h>中，所以只适用于内核，比如vfork唤醒父进程就是使用了完成变量，以及驱动模块中也常用。

##### 什么是顺序锁

用于读写共享数据，**依靠一个序列计数器**，当有疑义的数据被写入时，会得到一个锁，序列值会增加，读取数据之前和之后，序列号会被读取，读取的序列号相同说明没有被写操作打断。

系统节拍数jiffies使用到了顺序锁。

##### 屏障有什么用途？

编译器和处理器为了提供效率，可能对读和写重新排序，这些**确保顺序的指令称为屏障**。

##### 高节拍的优势与劣势

- 内核定时器能够以**更高的频率**和更高的准确性
- 中断处理程序占**用的时间越多**，打乱处理器工作。

#####  什么是jiffies？

全局变量jiffies用来记录自系统启动以来产生的节拍的总数。jiffies/HZ等于系统运行的时间s

#####  在64位和32位机器上的jiffies有什么区别？

在64位体系结构上，jiffies_64和jiffies指的是同一个变量，在32位体系结构上，访问jiffies仅能读取jiffies_64的**低32位**。

#####  实时时钟和系统定时器功能上有什么区别？

实时时钟是用来**持久存放系统时间的设备**，即使系统关闭后也可以保持计时。

系统定时器提供一种**周期性触发中断机制**。

#####  时钟中断处理程序分为几部分？

时钟中断处理程序划分为两部分：体系结构相关部分和体系结构无关部分。

- 与体系结构相关的部分作为**定时器的中断处理程序**而注册到内核中。
- 与体系结构无关的部分**被中断服务程序调用**。

#####  struct page表示物理页，其中包括了哪些成员？

- flags表示存放**页面的状态**，包括修改位。每一位表示一种状态。能同时表示出32种不同的状态。
- _count表示计数页被**引用次数**。进程终结的时候会减少引用次数。
- virtual是页的**虚拟地址**。映射。

#####  Linux将内存分为了四种区域

- ZONE_DMA，用来执行DMA操作
- ZONE_DMA32，让32位设备执行DMA操作
- ZONE_NORMAL，正常映射的页
- ZONE_HIGHEM，高端内存，不能永久映射到内核地址空间。

##### GFP_KERNEL和GFP_ATOMIC什么作用？

这两个是类型标志，前者是分配内存中可能会睡眠，后者是不能睡眠的内存分配。所以后者分配成功的机会较小。

##### slab分配器有什么作用？

为了避免频繁的分配和释放内存设计了空闲链表，空闲链表就是一个对象高速缓存。但是内核无法全局控制，slab分配器就是用来管理多个对象高速缓存。

##### slab分配器的具体流程

1. 内核用一个变量存放指向task_struct高速缓存的指针。
2. 内核初始化期间，fork_init()函数创建高速缓存
3. 如果分配失败，slab调用panic()函数。

##### 使用每个CPU数据的原因

1. **减少了锁保护，只有本处理器能访问本数据**。但这只是一个编程约定。
2. 使用每个CPU数据可以大大**减少缓存失效**。

##### 想要从高端内存进行分配，需要使用什么分配函数？

需要使用alloc_pages()函数，因为高端内存无法永久映射，所以无法获得虚拟地址，此函数返回一个指向page结构体的指针。

#####  虚拟文件系统VFS有什么作用？

VFS使得程序可以利用标准的系统调用对不同的文件系统甚至不同介质上的文件系统进行读取操作。

##### 页缓存机制的作用

大多数文件系统通过缓冲区缓互相通信。

##### 进程命名空间的作用

namespace是Linux内核用来隔离内核资源的方式。通过namespace让进程只能看到与自己相关的一部分资源。child_reaper托管进程会帮助子进程寻找父进程就会在父进程的命名空间中寻找PID=1的进程。

#####  为什么VFS可以衔接各种各样的文件系统？

- VFS定义了所有文件系统都支持的基本的概念上的**接口和数据结构**。
- 实际文件系统的代码在统一的接口和数据结构下**隐藏了具体的实现细节**。

#####  VFS提供的接口在系统调用的流程中体现在哪里？

标准C库函数->linux提供用于传递系统调用号和引发异常的一组宏->VFS提供的系统调用接口->文件系统的方法->物理介质。

这里具体一点说就是系统调用处理程序是软件中断处理程序，根据系统调用表中找到的就是VFS提供的系统调用，根据vfs层的inode找到驱动层的i_cdev->cdev->file_operations

#####  Unix文件系统使用的四种传统抽象概念

文件、目录项、索引节点和安装点

#####  什么是目录项

文件系统**路径中的每一部分**称为目录项

#####  什么是索引节点

**文件的相关数据**比如访问控制权限、大小、拥有者、创建时间等信息。存放在数据结构中，该数据结构称为索引节点inode。

#####  什么是超级块

超级块是一种**包含文件系统信息的数据结构**。

#####  VFS中四个主要的对象类型

- 超级块对象，代表一个具体的已安装文件系统
- 索引节点对象，代表一个具体的文件 
- 目录项对象，代表一个目录项，文件路径的一个组成部分
- 文件对象，代表由进程打开的文件。

#####  所包含的操作对象是什么

- super_operations对象
- inode_operations对象
- dentry_operations对象
- file_operations对象

#####  如何调用超级块中的操作函数，举例说明

sb->s_op->write_super(sb)，sb表示超级块指针，s_op指向super_operations，后边跟着的是具体的操作函数，因为C语言缺乏面向对象的支持，所以传入超级块作为形参。表示作用域

#####  索引节点结构体中重要的成员

- i_pipe，指向一个有名管道结构体
- i_bdev，指向一个块设备结构体
- i_cdev，指向一个字符设备结构体，就是这个成员找到的cdev结构体

三者存放在**联合体**中，每次只能表示三者之一

联合体的另一个应用就是uboot传入内核的第三个参数r2寄存器，这里如果不采用设备树的话传入的是ATAGS结构体，这个结构体其实就是tag结构体，tag_header+union组成，前者是描述后者的属性，后者是联合体每次只表示一种属性。

#####  调用索引节点对象中的操作函数

i->i_op->truncate(i)；

实际上是i->i_cdev->cdev->file_operations

#####  目录项与索引节点的关系

- 一个**被使用过**的目录项对应一个**有效**的索引节点。表示当前**正在被VFS**使用并且指向有效的数据
- 一个**未被使用**的目录项对应一个**有效**的索引节点。表示VFS当前**并未使用**目录项，但是目录项仍然指向一个**有效对象**，并且被保留在**缓存**中以便需要时使用它。
- 一个**负状态**的目录项没有对应的有效索引节点，因为索引节点**已被删除**，但目录项仍然保留，以便快速解析以后的**路径查询**。

#####  目录项缓存的三个主要部分

- **被使用的目录项链表**。一个给定的索引节点可能有多个链接的目录项对象。
- 最近被使用的双向链表。含有**未被使用**和**负状态**的目录项对象。
- 散列表和相应的散列函数，用来快速地将给定**路径解析**为相关目录项对象。

#####    目录项缓存与索引节点缓存的联系

和目录项对象相关的索引节点 对象不会被释放（但会被删除），因为目录项会让相关索引节点的**使用计数为正**，这样可以**确保索引节点留在内存中**。

##### 什么是文件对象

文件对象是**已打开的文件在内存中的表现**。该对象由相应的open()系统调用创建，由close()系统调用撤销。

##### 同一个文件存在多个文件对象

因为**多个进程**可以同时打开和**操作同一个文件**，所以可以存在多个对应的文件对象。

##### VFS与进程相关的数据结构

- file_struct，由进程描述符中的files目录项指针指向。**所有文件与单个进程相关的信息**都包含在其中。进程被终结的时候第四部就是释放进程的资源，包括打开的文件。
- fs_struct，由进程描述符的fs指针指向，**包含文件系统与进程相关的信息**。
- namespace，由进程描述符中的mmt_namespace指向。**每一个进程在系统中的命名空间**。

所有进程都继承其父进程的命名空间。

##### 块和扇区的关系

- 扇区：块设备中的最小寻址单元
- 块：文件系统中的最小寻址单元，大于等于扇区，小于等于页

#####  缓冲区头的作用

内核在处理数据时需要一些相关的控制信息，所以每个缓冲区有一个对应的描述符称为缓冲区头。

缓冲区头的目的在于**描述一个磁盘块和一个物理内存缓冲区之间的映射关系**。

##### bio结构体表示什么

bio结构体代表了活动的以片段链表形式组织的**块IO操作**。因为单个缓冲区不一定要连续。

#####  bio结构体代替缓冲区头结构体的好处

- bio结构体很容易处理高端内存。处理的是物理页而不是虚拟地址
- bio结构体既可以代表普通页IO也可以代表直接IO，不通过页高速缓存page cache的IO操作。
- bio结构体便于执行分散-集中块IO操作。一个缓冲区可以取自多个物理页面。
- bio结构体属于轻量级结构体。只需要包含块IO操作所需的信息。

##### 什么是请求队列

块设备将他们挂起的块IO请求保存在请求队列中。由request_queue结构体表示。请求队列中的**每一项**都是一个单独的**请求**。每个请求可以包含**多个bio结构体**。

##### IO调度程序有什么用

IO调度程序将磁盘IO资源分配给系统中所有挂起的块IO请求。目的是**管理块设备的请求队列**。

##### IO调度程序减少磁盘寻址时间的方法

- 合并指的是将两个或多个请求结合成一个新请求。
- 排序指的是使得所有请求按硬盘上扇区的排列顺序有序排列。

##### 使用linus电梯IO调度程序时请求加入到队列会发生的操作

1. 队列中有相邻磁盘扇区操作的请求，就合并
2. 队列中存在驻留时间过长的请求，插入尾部
3. 队列中存在合适位置，插入该位置
4. 队列中不存在合适位置，插入尾部

##### linus电梯带来的问题

一个对磁盘同一位置操作的请求流会造成较远位置的其他请求永远得不到运行机会。虽然每次插入一个请求都会对请求队列按照扇区顺序进行排序并且有等待时间过长的请求，新请求会插入到尾部，但并不是给等待过长的请求提供实质性服务。

##### 块IO的读操作和写操作有何区别

写操作与提交写操作的应用程序异步执行，而读操作与提交读操作的应用程序同步执行，等到读操作被满足时才会唤醒应用程序。所以读操作的响应时间对系统的性能有影响

##### 最终期限IO调度程序

每个请求都有一个超时时间，读请求是500ms，写请求是5s，请求会存入排序队列，并以请求类型分别存入读请求队列、写请求队列，然后从排序队列头部取出请求送入派发队列中提交给磁盘驱动，如果读请求队列或者写请求队列的请求超时，从读写队列中提取请求进行服务。

##### 排序队列与读写请求队列排序有什么区别

虽然请求都会送入排序队列以及读/写请求队列。但是在排序队列中是按照磁盘扇区顺序进行排序，读/写请求队列是FIFO先进先出进行排序。

##### 最终期限IO调度程序使用超时时间的目的

试图保证不会发生有请求在明显超期的情况下仍无法得到服务的现象。

##### 预测IO调度程序与最终期限IO调度程序有什么区别

最终期限IO调度程序对于读请求是一件好事，但是损害了系统吞吐量。预测IO调度程序的目标就是在保持良好的读响应的同时也能提供良好的全局吞吐量。

区别在于请求提交后并不直接返回处理其他请求，而是有意**空闲片刻**。此时任何对**相邻磁盘位置操作的请求**都会立刻得到处理，然后继续执行以前剩下的请求。

##### 完全公正的排队IO调度程序

CFQIO调度程序的差异在于每一个提交IO的进程都有**自己的队列**。以时间片**轮询调度队列**。

##### 空操作的IO调度程序

空操作IO调度程序**不进行排序**，唯一做的就是**执行合并**，以近乎FIFO的顺序排列。

##### Linux内核中默认使用的是哪种块IO调度程序

默认使用的是**CFQ**调度程序。

##### 什么是进程地址空间

进程的虚拟地址。32位机上是4GB。

##### 从进程地址空间角度理解线程

一个进程的地址空间与另一个进程的地址空间即使有相同的虚拟内存地址，实际上也彼此互不相干，称这样的进程为线程。

##### 什么是内存区域

可被进程访问的合法地址空间称为内存区域。4GB中有1GB是属于内核空间的。

##### mm_struct是什么

mm_struct是内核描述符结构体，内核用来表示**进程的地址空间**。进程上下文包括寄存器上下文、系统上下文、用户级上下文，其中系统上下文包括内存管理信息（mm_struct/vm_area_struct/pdg顶级页表/pte二级页表/内核栈/进程控制块等）。mm_struct并不是物理内存，而是进程地址空间的描述符，所以是虚拟地址的。

##### struct vm_area_struct *mmap和mm_rb之间的关系

这两个不同的数据结构描述的对象是相同的-该**地址空间中的全部内存区域**。前者是链表，后者是红黑树。内核通常会避免使用两种数据结构组织同一种数据。

每一个vm_area_struct结构体通过自身的**vm_next**域被连接入链表，所有的区域按地址增长的方向排序，mmap指向链表中的第一个内存区域，链中最后一个结构体指针指向空。

mm_rb域使用红黑树连接所有的内存区域对象，mm_rb指向红黑树的根节点，每一个vm_area_struct结构体通过自身的**vm_rb**域连接到树中。

##### 每个进程地址空间是如何联系的

所有的mm_struct结构体是通过自身的**mmlist**域连接到一个双向链表中的。该链表的首元素是**init_mm内存描述符**，表示init进程的地址空间。

##### 子进程的内存描述符如何分配

首先是由allocate_mm()宏从mm_cachep slab缓存中**分配到空闲链表**，然后由fork()函数中的copy_mm()函数**复制父进程的内存描述符给子进程**。这是在创建新内核栈的时候就实现了。

##### 线程的内存描述符如何分配

在调用clone()时，设置CLONE_VM标志，此时内核**不再需要**调用allocate_mm()宏，仅仅在调用copy_mm()函数将**mm指针指向其父进程的内存描述符**即可。

##### 撤销内存描述符的具体流程

减少 mm_struct中的mm_users用户计数，减少count_count使用计数，不再有任何使用者，将mm_struct结构体归还slab缓存。

##### 内核线程没有内存描述符

内核线程没有物理地址空间，也没有相关的内存描述符，task_struct->mm = NULL，但是访问内核内存也是需要使用一些数据的，所以当新内核线程运行时，避免浪费处理器周期向新地址空间进行切换，**内核线程将直接使用前一个进程的内存描述符**。此时更新task_struct->**active_mm** = 前一个进程的mm_struct。

##### mm_struct与vm_area_struct之间的关系

mm_struct表示进程的地址空间。4GB

vm_area_struct表示进程的内存区域（代码段、数据段、.bss、文件映射区、堆、栈，每个内存区域都有一个vm_area_struct结构体对应），也就是进程可以访问的合法区域。3GB中的一部分，描述了指定地址空间内连续区间上的一个独立内存范围。

##### 如何计算内存空间的大小

vm_start是内存区间的开始地址，本身在区间内，vm_end是内存区间的结束地址，本身在区间外。**[vm_start,vm_end)**就是内存区域的位置。

##### VMA标志有什么用

包含在vm_flags域内，标志了内存区域所包含的**页面的行为和信息**，同时也包含了内存区域中每个页面的信息，或者**内存区域的整体信息**。但不是具体的单独页面。

##### 举例VMA标志的实际应用

- 进程的对象代码映射区域标志位VMA_READ和VM_EXEC
- 可执行对象数据段的映射区域标志为VM_READ和VM_WRITE
- 只读文件数据段的映射区域被标志为VM_READ

##### 内存区域与进程的关系

每个和进程相关的内存区域都对应于一个vm_area_struct结构体，task_struct中包含唯一的mm_struct结构体。但是有多个vm_area_struct结构体。

##### 创建地址空间和删除地址空间 

**mmap**()和**do_mmap**()创建地址空间

**mummap**()和**do_mummap**()删除地址空间，从特定的进程地址空间中删除指定地址区间。具体的地址空间是文件映射区的。

##### Linux中采用的页式内存分配还是段式

Linux本身采用的是段式和页式都有，但是不叫段页式，段和页是两个过程，只不过段式啥也没干只是为了保证兼容性，具体操作就是把Linux所有段的基地址设为0，导致线性地址等于虚拟地址，内存管理实际上只有页式管理，但需要经过一层段式查询将虚拟地址转换成线性地址。

采用三级页表完成地址转换。顶级页表是页全局目录PGD，PGD中的表项指向二级页目录中的表项PMD，页表项PTE。PGD和PMD都属于系统级上下文中内存管理信息的一部分。

##### Linux为什么支持加载驱动模块

Linux虽然是单内核的操作系统，但也是模块化组成的，允许内核在运行时动态地向其中插入或删除代码，这些代码被一并组合在可装载内核模块中，好处是**内核镜像可以尽可能地小**。

##### 模块在内核内与内核外构建的区别

最大区别在于构建过程，当模块在内核源代码树**外围时，需要告诉make如何找到内核源代码文件和基础Makefile文件**。

##### modprobe/insmod/depmod命令之间的区别

depmod表示为模块**生成依赖信息**。

insmod表示载入模块，**不执行任何依赖性分析或进一步的错误检查**

modprobe表示**加载指定模块**并且**加载任何它所依赖的有关模块**。

##### kobject结构体的含义

设备模型的核心部分就是kobject，可以创建对象的层次结构，**嵌入kobject的结构体可以称为对象层次架构中的一部分**。

##### kobject与ktype、kset之间的关系

ktype定义了一些kobject**相关的默认特性**

kobject归入了称为**kset的集合**。

##### sysfs与kobject的关系

sysfs文件系统是一个处于内存中的虚拟文件系统，**提供了kobject对象层次结构的视图**。

##### sysfs约定是什么

1. sysfs属性保证每个文件**只导出一个值**。
2. sysfs中要以一个**清晰的层次**组织数据。
3. sysfs提供内核到**用户空间的服务**。







### Linux驱动扩展

#### uboot启动流程

##### makefile有什么作用

顶层Makefile可以调用子目录中的Makefile文件，每个Makefile只处理本模块的**编译链接工作**。

##### makefile中的特殊变量

**SHELL**和**MAKEFLAGS**这两个变量除非使用unexport声明，否则在整个make执行过程中，他们的值始终自动的传递给子makefile。

##### $(origin V)、$@、$<分别表示什么意思？

origin表示V的来源，$()表示执行括号内的函数、$@表示所有目标的集合、$<表示所有的依赖目标集。

##### =、:=、?=、+=都是什么含义

=是最基本的集合，:=是覆盖之前的值、？=如果没有被赋值就赋值、+=添加等号后边的值。

##### filter函数有什么作用？

$(filter 4.%,$(MAKE_VERSION))表示的是过滤逗号后边的数，只保留4.%类型的。

##### @有什么作用？

@echo的话就只会输出echo后边的信息，而不会打印echo了。

##### makefile如何实现将源文件与编译产生的文件分开

make O=out表示编译产生的文件打印到out目录下

##### make C=1和make C=2有什么区别？

前者表示**检查**那些**需要重新编译的文件**、后者**表示检查所有的源码文件**。

##### 如何单独编译某个模块

make M=dir

##### makefile如何获取主机架构和系统

HOSTARCH := $(**shell uname -m** | ....)这里的shell函数用来查询主机架构，返回给HOSTARCH。结果是x86_64

HOSTOS :=$(**shell uname -s** | ....)查询系统，结果是Linux

##### 如何设置目标架构、交叉编译器

make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabihf-

##### 配置文件config和xxx_defconfig之间的关系

不仅仅是uboot，还有kernel也是同样的道理，xxx_defconfig只是初始配置这是厂家决定的，最终使用的是.config文件，如果有什么修改是要添加到config中的。

##### ARCH/CPU/BOARD/SOC/CPUDIR/BOARDDIR七个变量的值是什么？

这个是根据具体情况具体分析的，以项目中使用的板子为例

- ARCH=arm
- CPU=armv7
- BOARD=stm32mp1
- SOC=stm32mp
- CPUDIR=arch/arm/cpu/armv7
- BOARDDIR=st/stm32mp1

##### defconfig文件配置config的具体流程

1. make xxx_defconfig
2. 顶层Makefile中的%config
3. 依赖包括scripts_basic脚本文件、FORCE、outputmakefile
4. 生成.config文件

##### make的具体过程

1. 执行make命令
2. 默认目标是__all
3. 依赖是all->ALL-y
4. 生成u-boot.bin等一系列文件
5. 这些文件的依赖是u-boot-dtb.bin等多个文件

##### uboot的第一行程序在哪里？

编译一次uboot之后，在根目录下生成**u-boot.lds文件**，此文件是链接脚本。第一行程序由连接脚本决定。入口点是arch/arm/lib/vector.S文件中的_start。

##### reset函数的具体工作

- 保存现场
- 设置中断向量表的起始地址（有两种中断控制器，标准的中断控制器和VIC中断向量表，后者可以提供中断优先级）
- 设置处理器工作模式，屏蔽IRQ和FIQ。（因为需要保证启动期间处理器工作模式是管理模式SVC，这是上电后默认的模式）

##### lowlevel_init函数的具体工作

- 保存现场
- 进行八字节对齐
- 启动s_init函数，此函数没啥用只能做到**最低底线的启动**

##### _main函数的具体工作

此函数中调用了四个函数

- board_init_f函数
- relocate_code函数
- relocate_vectors函数
- board_init_r函数

##### board_init_f函数的具体工作

主要有两个工作：

- **初始化一系列外设**：串口、定时器或者打印一些信息。
- 初始化全局变量global_data的各个成员变量。**获取每个内存段重定位之后的地址。**其实内存段就是内存区域，.bss、数据段、代码段、堆、栈、文件映射区。vm_area_struct，操作系统内存分段的体现。

##### relocate_code函数的具体工作

解决重定位引起的链接地址和运行地址的不同以及**执行代码的重定位动作**。

##### relocate_vector函数的具体工作

重定位中断向量表。（应该重定位到最开头，因为最开头是SRAM，这样就可以修改中断向量表了）vectors+0x8送入pc是SWI指令要执行的一步，vectors地址是0x0

##### board_init_r函数的具体工作

之前的board_init_f函数初始化了定时器、串口并打印的一些信息，以及初始化gd的成员变量，但并没有初始化所有的外设，后续工作由本函数执行。

- **标志重定位完成**
- 初始化cache
- **初始化重定位后的gd的成员变量**，也就是更新此时重定位之后每个内存段的地址
- 初始化malloc
- 初始化控制台相关内容
- **初始化设备树**
- 板级初始化，包括**时钟、电压。**
- 初始化串口
- 初始化看门狗
- **初始化NAND Flash**
- **初始化中断**，这里确实初始化并使能中断了毕竟uboot可以使用外设，必然需要中断，比如点亮屏幕，但是后续应该还会禁止中断

##### run_main_loop函数的具体工作

该函数的主要工作是：uboot启动以后会进入**倒计时读秒**，如果在N秒倒计时结束之前按下回车键，就会进入uboot的**命令模式**，如果倒计时结束之后就会**启动Linux内核**。

##### cli_loop函数的具体工作

如果倒计时结束之前按下回车，将会进入命令模式，cli_loop函数就是uboot的**命令行处理函数**。

##### cmd_process函数的具体工作

cli_loop函数就是通过cmd_process函数进行**命令处理**的。

此函数是uboot启动的最后一个函数。

##### do_bootm函数的具体工作

uboot通过执行bootm命令启动内核，实际上执行的是do_bootm函数。**负责解析bootm的命令参数**和**检查有没有子命令**。

##### do_bootm_states函数的具体工作

do_bootm函数**最后调用**的就是函数do_bootm_states，此函数根据不同的BOOT状态**执行不同的代码段**。共有八个阶段。

##### 第一阶段BOOTM_STATE_START

清空images系统镜像的结构体，记录阶段名字。

##### 第二阶段BOOTM_STATE_FINDOS

解析image系统镜像，获取一些基本参数信息赋值给images全局结构体中。

##### 第三阶段BOOTM_STATE_FINDOTHER

获取设备树信息然后赋值给images结构体

##### 第四阶段BOOTM_STATE_LOADOS

**解压内核**，获取内核的启动地址也就是解压后内核所在的地址。

##### 第五阶段BOOTM_STATE_RAMDISK

通过执行bootm_os_get_boot_func函数进而找到**系统启动函数**。

##### 第六阶段BOOTM_STATE_PREP

**解析bootargs环境变量**和设置内核的启动参数r0r1r2。

##### 第七阶段BOOTM_STATE_FAKE_GO

不执行

##### 第八阶段BOOTM_STATE_OS_GO

执行do_bootm_linux函数。这是最终启动Linux内核的函数，调用kernel_entry函数结束uboot。

##### 八个阶段有什么作用

专门来给images全局结构体成员变量赋值的。

start/findos/findother/loados/ramdisk/prep/fakego/osgo

##### uboot中定义的bootcmd和bootargs环境变量与内核启动参数r0r1r2

bootcmd存放的是内核、设备树的启动地址，以及启动命令。

bootargs存放的是根文件系统的地址，控制台信息。

内核启动参数是0，机器ID或者设备树的兼容值，tag结构体或者设备树的起始地址。在第六阶段BOOTM_STATE_PREP中解析bootargs和设置内核启动参数。

#### kernel启动流程

##### zImage和uImage的生成流程

zImage是压缩Image之后生成的压缩文件，但是有的uboot不识别，需要通过**mkimage**工具将zImage转换成uImage才可以，其实就是在zImage镜像的前面**添加0x40个字节的头部信息**就得到了。

##### Linux内核的第一行程序在哪里

链接脚本vmlinux.lds

##### Linux内核启动之前的要求

- 关闭MMU
- 关闭Dcache、Icache无所谓
- uboot传入r0r1r2，BOOTM_STATE_PREP设置了
- 确保CPU处于SVC模式、并且关闭了所有的中断，reset函数实现了

##### __mmap _switched函数的具体工作

此函数先打开MMU，然后启动内核。通过调用start_kernel启动。

##### start_kernel函数的具体工作

start_kernel函数里面调用了大量的函数，每一个函数都是一个庞大的知识点。最终调用了rest_init函数。

##### rest_init函数的具体工作

- 启动RCU锁调度器。
- 创建init内核进程，后来会在根文件系统中查找同名进程，通过运行同名进程实现内核态到用户态的转变，PID1
- 创建kthreadd内核进程，此进程负责所有内核进程的调度和管理，PID2
- 调用函数cpu_startup_entry进入idel进程也就是空闲进程，PID0

##### init进程的具体工作

kernel_init函数就是init进程具体做的工作。

- 调用kernel_init_freeable函数完成初始化工作
- 检查**ramdisk_execute_command**指针，存在就执行指向的变量值所代表的进程，也就是**根目录下的/init进程**。
- 如果ramdisk_execute_command为空，检查**execute_command**，通过uboot传递，在**bootargs中使用init=xxx**即可
- 如果ramdisk_execute_command和execute_command都为空，依次查找**/sbin/init、/etc/init、/bin/init、/bin/sh**，这四个都是备用init程序。
- 如果这四个也不存在，Linux启动失败。

如果删除了这四个备用的init文件，可以在bootargs中指定init=/bin/bash，这个文件其实是/bin/sh的具体 实现，通过软链接共享的bash文件。如果还不好使可以使用Linux的救援模式，这是以光盘形式载入计算机的小型操作系统，针对于删除了系统文件后找回的方式。

##### kernel_init_freeable函数的具体工作

- 完成Linux下设备驱动初始化工作
- 确定标准输入、输出、错误，由bootargs中设置对应的文件。
- 挂载根文件系统，由bootargs环境变量指定。

##### uboot中的bootargs环境变量的作用

- 指定根目录下的init进程，不一定在bootargs中init=xxx，先在ramdisk_execute_command指针指向init进程、execute_command指针、/sbin/init、/etc/init、/bin/init、/bin/sh中寻找。
- 指定挂载的根文件系统，虽然是在BOOTM_STATE_PREP解析的，但是在内核中的kernel_init_freeable函数中实现的。
- 指定使用的控制台，将作为标准输入、标准输出、标准错误的窗口

#### Linux驱动框架

##### 旧版字符设备驱动框架

```c
//查找需要使用的寄存器地址，定义指向寄存器的物理指针
//定义映射后的虚拟指针
//定义取消映射函数
//创建读
//写
//打开
//释放函数
//定义操作函数结构体file_operation
//创建驱动入口函数，函数中初始化硬件、注册字符设备register_chrdev(主设备号、设备名称、操作函数结构体)
//创建驱动出口函数，取消映射，注销字符设备unregister_chrdev(主设备号、设备名称)
module_init(入口函数);
module_exit(出口函数);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("ALIENTEK");
MODULE_INFO(intree,"Y");
```

###### 编写应用层的APP

```c
//创建main函数
//打开设备节点open
//往设备节点中写入数据write
//关闭文件
```

最后需要手动加载、卸载设备节点

##### 新版字符设备驱动框架

```c
//定义寄存器的物理地址
//定义映射后的寄存器虚拟地址指针
//创建newchrled设备结构体包括设备号、cdev、类、设备、主设备号、次设备号
//创建打开函数
//创建读函数
//创建写函数
//创建释放函数
//创建设备操作函数结构体
//创建入口函数
//先进行地址映射
//申请设备号alloc_chrdev_region函数，注册字符设备驱动，
//register_chrdev_region(设备号、设备数量、设备名称)，
//初始化cdev,cdev_init(cdev,设备操作函数结构体)
//添加cdev，cdev_add(cdev,设备号,设备数量)
//创建类，class_create(本模块,设备名称)，自动加载设备节点
//创建设备，device_create(class,设备号,设备名称)，自动加载设备节点
//创建出口函数，注销字符设备驱动
//删除cdev,cdev_del(cdev)
//删除设备device_destroy(class,设备号)
//删除类，class_destroy(class)
module_init(入口函数)
module_exit()
MODULE_LICENSE("GPL")
MODULE_AUTHOR("ALIENTEK");
MODULE_INFO(intree,"Y");//树内模块
```

##### 设备树下的字符设备驱动框架

```c
//映射后的寄存器虚拟地址指针
//创建设备结构体，设备号、cdev、类、设备、主设备号、次设备号、设备节点struct device_node。
//取消映射iounmap(物理地址)
//定义打开、读、写、关闭文件
//创建设备操作函数结构体。
//定义驱动入口函数
//获取设备树中的属性数据of_find_node_by_path("节点名称")
//获取compatible属性内容of_find_property(设备节点，"compatible"，NULL);
//获取status属性内容，of_property_read_string(设备节点，"status"，接收字符串)
//获取reg内容of_property_read_u32_array(设备节点，"reg"，接收数组，数量);
//寄存器地址映射of_iomap(设备节点，序号)
//创建设备号alloc_chrdev_region(设备号，设备数量，设备名称)
//初始化cdev，cdev_init(cdev,fops)
//添加一个cdev，cdev_add(cdev,设备号，设备数量)
//创建类，class_create(本模块，设备名称)
//创建设备，device_create(类，设备号，设备名称)
//创建出口函数
//取消映射
//注销cdev，cdev_del(cdev)
//注销字符设备unregister_chrdev_region(设备号，设备数量)
//删除设备，device_destroy(class,设备号)
//删除类，class_destroy(class)
module_init(入口函数);
module_exit(出口函数);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("ALIENTEK");
MODULE_INFO(intree,"Y");
```

##### 设备树下的platform总线驱动框架

```c
//创建设备结构体，设备号、cdev、类、设备、设备节点、GPIO标号
//创建初始化引脚函数
//从设备树中获取GPIO标号，of_get_named_gpio(设备节点，"节点名称"，0);
//申请使用GPIO，gpio_request(GPIO标号，"引脚名称")
//设置GPIO，gpio_direction_output(GPIO标号，初始电平)
//创建打开、关闭、读、写函数
//初始化操作函数结构体
//创建总线的入口函数probe
//初始化引脚
//设置设备号，alloc_chrdev_region(设备号，设备数量，设备名称)
//初始化cdev,cdev_init
//添加cdev，cdev_add
//创建类，class_create
//创建设备，device_create
//创建总线的remove函数
//卸载驱动前，先关闭GPIO
//注销GPIO，gpio_free(gpio标号)
//注销字符设备，unregister_chrdev_region
//注销设备，device_destroy
//注销类，class_destroy
//初始化匹配列表of_device_id match[]=.{.compatible = "对应的设备节点名称"}
//初始化platform驱动结构体
//platform_driver = {.driver = {.namme = "stm32mp1-beep"//设备名称，如果不使用设备树，就是这个name匹配.of_match_table = match,//设备树匹配表}.probe = probe,.remove = remove,};//最后注册probe和remove两个函数
//定义入口函数，
//platform_driver_register(platform驱动结构体)
//定义出口函数
//platform_driver_unregister(驱动结构体)
module_init(入口);
module_exit(出口函数);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("ALIENTEK");
MODULE_INFO(intree,"Y");
```

##### MISC驱动框架

```c
//创建设备结构体，包括设备号、cdev、类、设备、GPIO标号
//初始化gpio
//从设备树中获取GPIO，of_get_named_gpio(设备节点，"节点名称"，0)
//申请使用GPIO，gpio_request(gpio编号，"GPIO名称")
//设置gpio电平，gpio_direction_output(gpio编号，电平)
//定义打开、关闭、读、写函数
//初始化设备操作函数结构体
//初始化MISC设备结构体，名称，MISC设备号
//创建probe函数
//初始化GPIO
//注册MISC设备，misc_register(misc结构体)
//创建remove函数
//关灯
//释放gpio，gpio_free(gpio编号)
//注销misc设备，misc_deregister(misc设备结构体)
//匹配列表of_device_id match[]={{.compatible = "alientek,beep"},{}}
//初始化platform驱动结构体
//platform_driver ={.driver = {.name="",.of_match_table=match,},.probe=probe,.remove = remove,};
//定义入口函数platform_driver_register(驱动结构体)
//定义出口函数，platform_driver_unregister(驱动结构体)
module...
```

##### input子系统驱动框架

```c
//定义一个设备结构体，包括输入设备指针、GPIO编号、中断号
//定义外部中断函数
//定义定时器中断函数
//input_report_key(输入设备，事件码，事件值)
//上报同步事件，input_sync(输入设备);
//定义probe函数
//初始化引脚
//初始化定时器，timer_setup()
//申请input_dev，input_allocate_device();
//初始化输入设备名称，name = 
//设置产生哪些事件
//__set_bit(EV_KEY,key.idev->evbit);设置产生按键事件
//__set_bit(EV_REP,key.idev->evbit);设置产生重复事件
//__set_bit(KEY_0,key.idev->keybit);设置产生信号的按键
//注册输入设备，input_register_device(输入设备)
//创建remove函数
//释放中断号、释放GPIO、删除timer、释放input_dev
//初始化平台驱动结构体
//注册驱动结构体
```

##### SPI驱动框架

1. 具体芯片的设备结构体创建
2. icm20608的spi_driver注册和注销
3. probe&remove函数
4. icm20608寄存器读写与初始化
5. 字符设备驱动框架

#### FreeRTOS

##### RTOS的实时性是如何实现的

一个处理器核心在某一时刻只能运行一个任务，操作系统中任务调度器的责任就是决定在某一时刻究竟运行哪个任务。

实时操作系统中都要包含一个**实时任务调度器**，这个任务调度器与其他操作系统的最大不同是强调：**严格按照优先级来分配CPU时间，并且时间片轮询不是实时调度器的一个必选项**

##### FreeRTOS的几种调度方式

FreeRTOS是一款支持多任务运行的实时操作系统，具有时间片、抢占式和合作式三种调度方式。

- 合作式调度，主要用在资源有限的设备上，现在很少使用了
- 抢占式调度，每个任务都有不同的优先级，任务会一直运行直到被高优先级任务抢占或者遇到阻塞式API函数。
- 时间片调度，每个任务都有相同的优先级，任务会运行固定的时间片个数或者遇到阻塞式API才会执行同优先级任务之间的任务切换。

##### 任务之间是如何通信的

在FreeRTOS中所有的通信和同步机制都是基于队列FIFO实现的。队列不是属于某个特别指定的任务的，任何任务都可以向队列中发送消息，或者从队列中提取消息。

##### 二值信号量和互斥量的区别

信号量一般用来进行资源管理和任务同步，FreeRTOS中信号量又分为了二值信号量、计数型信号量、互斥信号量和递归互斥信号量，不同的信号量其应用场景不同。

二值信号量没有优先级继承、互斥信号量拥有优先级继承机制。二值信号量更适合用于同步，而互斥信号量适合用于简单的互斥访问。

二值信号量其实就是一个只有一个队列项的队列。

##### 优先级继承有什么作用？

优先级继承尽可能降低了高优先级任务处于阻塞态的时间，并且将已经出现的优先级反转影响降到的最低。

##### 任务通知是怎么实现的

FreeRTOS的每个任务都有一个32位的通知值，任务通知是一个时间，如果某个任务通知的接受任务因为等待任务通知而阻塞的话，向这个接收任务发送任务通知以后就会解除这个任务的阻塞状态。也可以更新接收任务的任务通知值。有四种方法。

- 不覆盖接收任务的通知值
- 覆盖接受任务的通知值
- 更新接受任务通知值的一个或多个bit
- 增加接收任务的通知值

##### FreeRTOS的四种任务状态

1. 运行态Running，当任务处于实际运行状态。
2. 就绪态Ready，处于就绪态的任务指能够运行但没有运行的任务。
3. Blocked阻塞态，由于等待信号量、消息队列、事件标志组等而处于状态称为阻塞态，任务调用延迟函数也是阻塞态
4. Suspended挂起态，通过调用函数vTaskSuspend()对指定任务进行挂起，挂起后任务将不被执行，只有调用函数xTaskResume()才能从挂起态恢复。

##### 解释下优先级反转

当高优先级任务正等待信号量，而此时信号量被一个低优先级任务拥有，此时一个介于两个任务之间的中等优先级开始执行，导致一个高优先级任务在等待一个低优先级任务。

##### 什么是优先级继承

优先级继承是为了解决优先级反转问题而提出的一种优化机制。原理是让低优先级线程在获得同步资源的时候如果此时有高优先级的线程也需要使用该同步资源时，临时提升其优先级，以便其能更快的执行并释放同步资源，释放同步资源后恢复其原来的优先级。

原本的低优先级携带信号量，导致高优先级无法抢占，从而让中等优先级任务得以执行，而此时提高低优先级任务的优先级，那么就会变成低优先级任务先执行然后释放信号量，恢复优先级，高优先级任务获得信号量执行，最后执行中等优先级任务。

#### Makefile/Cmake复习

目前是c/c++、驱动、内核、操作系统、FreeRTOS、两段项目经历都复习完了，晚上原本没想好做什么，可能是将项目经历再细分下、或者开始第二轮复习。突然想到了Makefile和Cmake这两个东西我当初也学了半个月，而且之前的研究所老哥提到过经纬恒润的日常实习面试问过这里。并且Linux应用篇我本来就不打算复习了，那么这两个复习下就当应用完事了吧。

##### 什么是makefile

makefile定义了一系列的规则来指定文件编译流程，从而实现自动化编译。

##### 什么是make

make是一个命令工具，是一个解释makefile中指令的命令工具。

##### 程序编译、链接流程

源文件通过编译生成中间目标文件，由中间目标文件链接生成可执行文件。编译器只检测程序语法，和函数、变量是否声明。如果函数未被声明，编译器会给出一个警告但是可以生成目标文件。

链接程序时，链接器会在所有的目标文件中找寻函数的实现，如果找不到就链接错误。

---

之前学的是预处理、编译、链接、装载。其中预处理会将宏定义进行字符串替换、头文件复制到每个包含头文件的源文件中。然后编译就是检查程序语法、函数变量声明。链接分为外部链接和内部链接，常量默认是内部链接，因为头文件会被多个源文件包含，在头文件中定义全局变量会导致发生多个外部链接，从而报错多重定义。

---

##### makefile最核心的内容

target是一个或多个目标文件，prerequistites是目标文件所依赖的依赖文件，如果依赖文件被修改需要执行command从而生成新的目标文件。

---

举例常见的makefile内容

```makefile
edit:main.o
cc -o edit main.o//执行该指令链接出可执行文件edit
main.o:mian.c defs.h
cc -c main.c//编译出main.o文件
```

----

##### 如何生成、删除执行文件和所有中间文件

在makefile文件的目录下执行make指令生成执行文件以及中间文件，执行make clean删除。

##### make是如何工作的

1. make会在当前目录下找名字为makefile或Makefile的文件
2. 找文件中第一个目标文件并作为最终的目标文件
3. 根据规则生成中间目标文件和最终目标文件
4. 如果找不到文件，make直接退出并报错
5. make不关注规则的错误，只管文件的依赖性

##### 如何在makefile中使用变量

object=xx定义变量，其实类似于宏定义，然后$(object)调用变量。

##### makefile的自动推导

对于xx.o文件与xx.c文件也就是同名文件的依赖关系是可以自动推导出来的，并且执行规则也可以自动推导。

##### .PHONY什么意思

.PHONY：后面的文件是一个伪目标文件。

##### 清空目标文件的规则是什么

将clean设置为伪目标并放在文件的最后。

##### makefile中有什么

主要包含了五个东西：显式规则、隐式规则、变量定义、文件指示和注释。

###### 显式规则有什么作用

说明了如何生成一个或多个目标文件

###### 隐式规则有什么作用

make自动推导功能，同名文件的依赖、执行规则。

###### 变量的定义

变量都是字符串。会被扩展到相应的引用位置上。

###### 文件指示

包括了三个部分，引用另一个makefile、指定makefile中的有效部分、定义多行命令。

##### makefile的文件名

默认是makefile和Makefile，特别指定的话make -f 参数

##### makefile如何引用其他makefile

在makefile内部使用include关键字包含其他mk文件。

##### "-"符号有什么作用

加上此符号之后，无论出现什么错误，都不要报错继续执行。

##### 环境变量MAKEFILES

所有的makefile都会共享环境变量。

##### make工作时的执行步骤

1. 读入所有的makefile
2. 读入被include的其他makefile
3. 初始化文件中的变量
4. 推导隐晦规则，并分析所有规则
5. 为所有的目标文件创建依赖关系链
6. 根据依赖关系，决定哪些目标要重新生成
7. 执行生成命令

##### make支持的三种通配符

make支持三种通配符：“*”，“？”，“[...]”

##### 当大量的源文件存放在不同的目录中如何寻找文件

1. makefile文件中的特殊变量VPATH就是完成这个功能的，没有指明变量的话只会在当前目录中寻找依赖文件和目标文件。如果定义了该变量，会到所指定的目录中寻找。
2. 使用make的vpath关键字，可以指定不同的文件在不同的搜索目录中。

##### 伪目标与目标文件的区别

伪目标并不是一个文件，只是一个标签，所以make无法生成它的依赖关系和决定它是否要执行，只有显示地指明这个目标才能生效。伪目标的取名不能和文件名重名。

##### $<和$@是什么意思

$<表示的是所有的依赖目标集，$@表示的是目标机。

##### 静态模式是什么

更加容易地定义多目标的规则。

<targets>:<target-pattern>:<prereq-patterns>分别表示目标集、目标集的模式、依赖目标集的模式。目标集是基数，目标集的模式是筛选出符合要求的目标集，依赖目标集的模式是将已经筛选出的目标集转变成依赖目标集。

##### $(filter %.o,$(files))什么意思

表示调用makefile中的filter函数，过滤$(files)变量，只要其中模式为%.o的内容。

##### 如何让makefile中的依赖关系自动包含头文件

c/c++编译器有一个-M的选项可以自动寻找源文件中包含的头文件，并生成一个依赖关系。对于GNU的C/C++编译器，需要使用-MM参数，不然会把标准库的头文件包含进来。

##### .d文件与.c文件之间的关系

GNU组织建议的编译器为每个源文件的自动生成的依赖关系放到一个文件中，这个文件就是.d文件。

##### 如何保证命令不被make显示出来

- 在makefile的命令前面加上@
- make参数-s或者--slient

##### 如何让第二个命令在第一个命令基础上执行

两个命令不可以分行，要在一行用分号；

##### 如何让make忽略命令的出错

make会检测每个命令的退出码，（类似于应用层中的errno，也类似于进程中的task_struct->exit_code退出码）如果命令退出码非零表示执行错误。

- 在命令行前加一个减号"-"
- make -i，会忽略所有命令的错误
- make -k，哪个命令错误终止该命令，继续执行其他规则。

##### 如何将顶层makefile中定义的变量传入子makefile

- 通过export <variable>传递变量到下级Makefile中。
- 通过unexport <variable>禁止传递变量到下级Makefile中 。

##### 两个系统级的环境变量

- SHELL，
- MAKEFILES

这两个环境变量无论声明export与否都会传递到下层Makefile中。

##### 什么是命令包

在makefile中出现的一些多行的命令序列将这种命令序列定义一个变量。以define开始，以endef结束。与define同行的是命令包名称，在define和endef中间的是命令包内容。特点就是支持换行

##### 变量中可以定义变量的优缺点

- 优点：可以将变量的定义推后实现
- 缺点：容易发生递归变量，让make陷入无限的变量展开过程中。

##### 递归变量如何避免

将等号前面加上冒号:=这种方式会导致前面的变量不能使用后边的变量，只能使用前面已定义好了的变量。

##### 系统变量MAKELEVEL是什么意思

如果make有一个嵌套执行的动作，此变量记录当前makefile的调用层数。

##### ?=操作符什么作用

如果操作符左侧没有被定义过，那么就是右侧的值，相当于弱定义。

##### $(var:a=b)什么意思、$()

将变量var中的a替换成b字串。

var:%.o=%.c这是静态模式，var中的符合%.o的目标集现在修改为%.c

---

##### 为什么STM32的GPIO需要开启时钟才能控制引脚、而51单片机不需要

因为51的gpio模块是直接连接到CPU的，而STM32的GPIO模块是连接到APB总线通过AHB-APB桥连接到AHB总线进而连接到CPU的。而AHB总线需要时钟信号。51的gpio工作时钟与cpu工作时钟同步，

-----

##### +=操作符有什么作用

使用+=操作符给变量追加值。

##### override作用是什么

如果有变量是make的命令行参数设置的，makefile中对这个变量的赋值会被忽略，只有在赋值前面加上override才能设置。

##### 当makefile和环境变量中同时定义的变量哪个有效

默认情况下是makefile中定义的变量有效，类似于局部变量覆盖全局变量。如果make -e的话系统环境变量覆盖makefile中定义的变量。

##### 如何定义一个目标变量

所谓的目标变量指的是只在特定目标所引发的所有规则中生效的变量。

<target>:<variable-assignment>，目标：CFLAGS = -g，此时定义的变量只在target引发的规则中生效。

##### 如何定义模式目标变量

%.o : CFLAGS = -0，将目标模式化添加百分号。

##### 介绍下条件关键字

有四种条件关键字，他们下一行是如果为真，执行的规则，endif结尾、也可以使用else。

- ifeq(arg1,arg2)
- ifneq(arg1,arg2)
- ifdef <variable-name>
- ifndef<variable-name>

##### 使用条件表达式需要注意的事项

make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来决定语句，所以不要把自动化变量放入条件表达式中，因为自动化变量是在运行时才有的。并且不允许把整个条件语句分成两部分放在不同的文件中。

##### 在Makefile中字符串处理函数

1. subst

   $(subst <from>,<to>,<text>)返回替换后的字符串

2. patsubst

   $(patsubst <pattern>,<replacement>,<text>)返回替换后的字符串

3. strip

   $(strip <string>)返回被去掉空格的字符串值。

4. findstring

   $(findstring <find>,<in>)如果在in找到find字符串返回find，否则返回空字符串

5. filter

   $(filter <pattern>,<text>)返回符合模式<pattern>的字符串

6. filter-out

   $(filter-out <pattern>,<text>)返回不符合模式<pattern>的字符串

7. sort

   $(sort <list>)返回升序后的字符串

8. word

   $(word <n>,<text>)返回字符串text中第n个单词。如果n中的单词数更大就返回空字符串

9. wordlist

   $(wordlist <s>,<e>,<text>)返回字符串text中从s到e的单词字符串。

10. word

    $(words <text>)返回text中的单词数。

11. firstword

    $(firstword <text>)返回字符串text的第一个单词。

##### 介绍文件名操作函数

1. dir

   $(dir <names>)返回文件名序列<names>的目录部分。

2. notdir

   $(notdir <names>)返回文件名序列<names>的非目录部分

3. suffix

   $(suffix <names>)返回文件名序列<names>的后缀序列。

4. basename

   $(basename <names>)返回文件名序列<names>的前缀序列。

5. addsuffix

   $(addsuffix <suffix>,<names>)返回加过后缀的文件名序列

6. addprefix

   $(addprefix <prefix>,<names>)返回加过前缀的文件名序列

7. join

   $(join <list1>,<list2>)返回两个字符串数组连接过后的字符串数组。

8. foreach

   $(foreach <var>,<list>,<text>)将list中的单词依次放到参数var中，然后执行text包含的表达式。每次循环的text返回的字符串组成的字符串就是函数返回值。
   
9. if

   $(if <condition>,<then-part>,<else-part>)根据条件返回后两者之一

10. call

    $(call <expression>,<parm1>,<parm2>,<parm3>)<expression>中的变量依次被<parm1>/<parm2>/<parm3>取代，取代结果作为call的返回值。

11. origin

    $(origin <variable>)这里的variable是变量名称。返回值是变量初始化情况。

12. shell

    此函数把执行操作系统命令后的输出作为函数返回值。

    $(shell cat foo)

##### 介绍控制make的函数

1. error

   $(error <text>)，产生一个致命错误，<text>是错误信息。make退出

2. warning

   $(warning <rext>)，输出一段警告信息，make继续执行

##### make的退出码有哪些

- 0，表示成功执行
- 1，如果make运行出现任何错误，返回1
- 2，如果使用了make -q，并且一些目标不需要更新，返回2

##### 如何指定Makefile

GNU make默认的规则是当前目录下依次找GNUmakefile、makefile和Makefile文件。

如果指定特殊名字的Makefile，使用make -f 文件名称。

##### 如何指定终极目标

- makefile中的第一个目标就是终极目标

- 环境变量为MAKECMDGOALS，此变量会存放指定的终极目标列表，如果在命令行没有指定目标，则为空值。可以指定伪目标作为最终目标。

  1. all

     此伪目标是所有目标的目标，其功能一般是编译所有的目标。

  2. clean

     此伪目标是删除所有被make创建的文件。

  3. install

     此伪目标是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中。

  4. print

     此伪目标的功能是列出改变过的源目标。

  5. tar

     此伪目标功能是把源程序打包备份，创建一个tar文件

  6. dist

     此伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件或者gz文件。

  7. TAGS

     此伪目标功能是更新所有的目标，以备完整地重编译使用。

  8. check和test

     这两个伪目标用来测试makefile的流程。

##### 只检查命令 、执行序列而不执行，使用哪些make参数

- -n
- --just-print
- --dry-run
- --recon

##### 只更新目标文件的时间，而不更改目标文件

- -t
- --touch

##### 查找目标，如果目标不存在打印一条出错信息

- -q
- --question

##### 如何只运行依赖特定文件的规则

- -W <file>
- --what-if=<file>
- --assume-new=<file>
- --new-file=<file>

##### 忽略与其他版本make的兼容性

- -b
- -m

##### 所有的目标都需要更新，也就是重编译

- -B
- --always-make

##### 指定读取makefile的目录

- -C <dir>
- -directory=<dir>

##### 输出make的调试信息

- --debug [=<options>]
- -d等同于--debug=a

##### 指明环境变量的值覆盖makefile中定义的变量的值

- -e
- --environment-overrides

##### 指定需要执行的makefile

- -f=<file>
- --file=<file>
- --makefile=<file>

##### 显示帮助信息

- -h
- --help

##### 在执行时忽略所有的错误

- -i
- --ignore-errors

##### 指定一个被包含makefile的搜索目标。

- -I <dir>
- --include-dir=<dir>

##### 指定同时运行命令的个数

- -j [<jobsnum>]
- --jobs[=<jobsnum>]

##### 出错停止

- -k
- --keep-going

##### 指定make运行命令的负载

- -l <load>
- --load-average [=<load>]
- --max-load[=<load>]

##### 不重新生成的指定的<file>，即使目录的依赖文件新于它

- o<file>
- --old-file=<file>
- --assume-old=<file>

##### 输出makefile中的所有数据

- -p
- --print-data-base

##### 禁止make使用任何隐含规则

- -r
- --no-builtin-rules

##### 禁止make使用过任何作用于变量上的隐含规则

- -R
- --no-builtin-variables

##### 在命令执行时不输出命令的输出

- -s
- --silent
- --quiet

##### 让环境变量中的-k选项失效

- -S
- --no-keep-going
- --stop

##### 输出make程序的版本等关于make的信息

- -v
- --version

##### 输出运行makefile之前和之后信息

这里是因为make存在嵌套的现象。

- -w
- --print-directory

##### 禁止-w选项

- --no-print-directory

##### 只要make发现有未定义的变量，那么就输出警告信息

- --warn-undefined-variables

##### 隐含规则会导致某些规则没有意义

每一条隐含规则都在库中有其顺序，越靠前的越被经常使用。即使添加了依赖文件，隐含规则依旧会按照顺序执行，然后不再寻找下一条规则。

##### 编程C程序的隐含规则

<n>.o的目标的依赖目标会自动推导为<n>.c，并且其生成命令是$(CC) -c $(CPPFLAGS) $(CFLAGS)

##### 编译C++程序的隐含规则

<n>.o的目标的依赖目标会自动推导为<n>.cc或是<n>.C并且生成命令是$(CXX) -c $(CPPFLAGS) $(CFLAGS)。

##### 编译Pascal程序的隐含规则

<n>.o的目标的依赖目标会自动推导为<n>.p，并且生成命令是$(PC) -c $(PFLAGS)。

##### 汇编和汇编预处理的隐含规则

- <n>.o的目标的依赖目标会自动推导为<n>.s，默认使用过编译品as，并且其生成命令是：$(AS) $(ASFLAGS)。
- <n>.s的目标的依赖目标会自动推导为<n>.S，默认使用C预编译器cpp，并且其生成命令是：$(AS) $(ASFLAGS)。

##### 链接Object文件的隐含规则

<n>目标依赖于<n>.o，通过运行C的编译器来运行链接程序生成，生成命令是：$(CC) $(LDFLAGS) <n>.o $(LOADLIBES) $(LDLIBS)。

##### 隐含规则中使用的两种变量

- 关于命令的变量

  1. AS

     汇编语言编译程序。默认命令是as

  2. CC

     C语言编译程序，默认命令是cc

  3. CXX

     C++语言编译成宿，默认命令是g++

  4. CPP

     C程序的预处理器。默认命令是$(CC) -E

  5. RM

     删除文件命令。默认命令是rm -f
  
- 关于参数的变量

  1. ASFLAGS

     汇编语言编译器参数。

  2. CFLAGS

     C语言编译器参数

  3. CXXFLAGS

     C++语言编译器参数

  4. CPPFLAGS

     C预处理器参数

##### 隐含规则生成的中间目标与一般目标的区别

- 除非中间目标不存在，才会引发中间规则
- 只要目标成功产生，在产生最终目标过程中，中间目标文件会被rm -f删除。

##### 如何避免make自动推导时出现无限递归情况

在隐含规则链中，禁止同一个目标出现两次或两次以上。

##### 什么是makefile中的自动化变量

把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完的变量。

- S@

  表示规则中的目标文件集。如果有多个目标，就是匹配目标中模式定义的集合。

  $(@D)表示S@的目录部分。

  $(@F)表示$@的文件部分

- S%

  当目标是函数库文件时，表示规则中的目标成员名。

- $<

  依赖目标中的第一个目标名字。如果依赖目标是以模式定义的，那么$<是符合模式的一系列的文件集。

- $?

  所有比目标新的依赖目标的集合。

- $^

  所有依赖目标的集合

- $+

  所有依赖文件的集合，只是不去除重复的依赖目标。

- $*

  表示目标模式中%及其之前的部分。

  $(*F)和$( *D)同理。

#### CMAKE复习

##### Makefile的局限性

不同平台下的make工具遵循着不同的规范和标准，对应的makefile文件语法、格式都不同。如果软件向跨平台，必须保证能够在不同平台下编译，需要为每一种标准编写一次makefile。

##### cmake的作用是什么

cmake允许开发者编写一种与平台无关的CMakeLists.txt文件来制定整个工程的编译流程，再根据具体的编译平台升格成功本地化的Makefile和工程文件，最后执行make编译。

##### Cmake的优点

- 开放源代码
- 跨平台
- 语法规则简单。

##### CMakeLists.txt文件组成部分

- project(XXX)，project是一个命令用于设置工程文件，并不是必须的。
- add_executable(hello ./main.c)，用于生成一个可执行文件，第一个参数表示生成的可执行文件对应的文件名，第二个参数表示对应的源文件。
- out-of-source，将构建过程生成的文件和源文件分离开来。
- set(XXX main.c hello.c)，set命令用于设置变量，如果变量不存在则创建并设置。
- add_library(hello hello.c)，将hello.c编译成静态库函数libhello.a文件。
- add_library(hello STATIC hello.c)，将hello.c编译成动态库函数libhello.so文件。（动态链接库和静态链接库的区别在于前者是在目标编译时加入，后者是在目标运行时加入）
- target_link_libraries(hello,hello)为目标指定依赖库，将libhello.a链接进hello可执行文件中。
- set_target_properties(hello PROPERTIES OUTPUT_NAME "hello")，用于设置目标的属性，对libhello.a目标的输出名称进行设置。
- cmake_minimum_required(VERSION 3.5)，此命令用于设置当前工程的cmake最低版本号要求。

##### 当CMakeLists.txt分成一个顶层、源文件、库文件时分别如何编写

- 顶层CMakeLists.txt

  ```cmake
  cmake_minimum_required(VERSION 3.5)
  project(HELLO)
  add_subdirectory(libhello)#添加libhello子目录，并检索其中的CMakeLists.txt
  add_subdirectory(src)
  ```

- src目录下的CMakeLists.txt

  ```cmake
  include_directories(${PROJECT_SOURCE_DIR}/libhello)#指定库文件的路径
  add_executable(hello main.c)#生成可执行文件
  target_link_libraries(hello libhello)#将库文件加入可执行该文件
  ```

- libhello目录下的CMakeLists.txt

  ```cmake
  add_library(libhello hello.c)#生成库文件
  set_target_properties(libhello PROPERTIES OUTPUT_NAME "hello")#设置库文件名称
  ```

  实际上在顶层CMakeLists.txt文件中就是检索两个子目录中的CMakeLists.txt文件。源文件目录中生成可执行文件，库目录中生成库文件

##### 如何决定可执行文件和库文件的输出目录

通过对LIBRARY_OUTPUT_PATH和EXECUTABLE_OUTPUT_PATH变量进行设置即可完成，前者是控制库文件的输出路径，后者是控制可执行文件的输出路径。

##### CMakeLists.txt文件中的命令与函数区别

命令括号内的多个参数是空格间隔的，函数是逗号间隔的。

##### 定义和引用变量上makefile和Cmake有什么区别

- 在定义上，makefile中直接等号赋值了，Cmake中需要使用set命令
- 在引用上两者是相同的，$(XXX)

##### 介绍部分CMake中的命令

1. add_subdirectory

   该命令告诉cmake去指定的目录中寻找源码并执行它。如果指定目录，会在当前目录下创建与子目录同名的文件名。既可以是平级目录、也可以是子目录、父目录，不过如果是平级、父目录的话需要写相对路径，而不是目录名称

2. aux_source_directory

   该命令会查找目录中的所有源文件。aux_source_directory(<dir> <variable>)查找src目录下的所有源文件将路径信息存放在<variable>中。

3. get_target_property和set_target_properties

   分别用于获取/设置目标的属性。

4. include_directories

   用于设置头文件的搜索路径。

5. link_directories和link_libraries

   前者用于设置库文件的搜索路径，后者用于设置需要连接的库文件。

6. list

   此命令是关于列表操作的命令，比如获取列表的长度、从列表中返回由索引值指定的元素。

7. message

   message命令用于打印、输出信息。

8. project

   此命令用于设置工程名称，执行命令之后会引入两个变量分别是：工程名称+工程源码目录，工程名称+输出文件目录。不执行命令，这两个变量不存在。
   
9. set
   
   set(<variable> <value>)，不仅仅可以设置变量，还可以设置字符串列表，其实就是多个value之间空格分割。可以配合list操作字符串列表。
   
10. target_include_directories和target_link_libraries

    前者命令为指定目标设置头文件搜索路径，后者命令为指定目标设置链接库文件。这两个命令和include_directories和link_libraries命令是有区别的。可以携带三种关键字

    - 当使用PRIVATE关键字修饰时，意味着包含目录列表仅用于当前目标
    - 当使用INTERFACE关键字修饰时，意味着包含目录列表不用于当前目录、只能用于依赖该目标的其他目标，也就是cmake会将包含目录列表传递给当前目标的依赖目标。
    - 当使用PUBLIC关键字修饰时，就是以上两个的集合。

##### 介绍部分常用的变量

1. PROJECT_SOURCE_DIR和PROJECT_BINARY_DIR

   前者表示工程的顶级目录，后者表示顶层源码对应的输出文件目录。

   CMAKE_SOURCE_DIR和CMAKE_BINARY_DIR相同的含义。

2. CMAKE_CURRENT_SOURCE_DIR和CMAKE_CURRENT_BINARY_DIR

   当前源码的路径以及当前源码的输出文件路径。

3. CMAKE_VERSION/CMAKE_MAJOR_VERSION/CMAKE_MINOR_VERSION

   记录cmake的版本号，分别是主版本号和次版本号。

4. PROJECT_VERSION/PROJECT_VERSION_MAJOR和PROJECT_VERSION_MINOR

   记录工程的版本号。

   CMAKE_PROJECT_NAME和PROJECT_NAME

   这两个等价，记录了工程的名字

##### 介绍下可以改变命令行为的变量

1. BUILD_SHARED_LIB

   通过BUILD_SHARED_LIB变量来控制add_library()命令变量设置为on时表示使能动态库、否则是生成默认的静态库.

2. CMAKE_BUILD_TYPE

   设置编译类型Debug或者Release。前者会生成调试信息，可以使用GDB进行调试；后者不会生成调试信息。

3. CMAKE_SYSROOT

   cmake会将该变量传递给编译器sysroot选项，通常我们在设置交叉编译时使用到。

4. CMAKE_INCLUDE_PATH

   find_file()和find_path()命令指定搜索路径的目录列表。传入一个文件名，前者返回文件的全路径，后者将文件的所在目录返回给我们。通过CMAKE_INCLUDE_PATH变量来进行指定。该变量指定了一个目录列表。

5. CMAKE_LIBRARY_PATH

   指定find_library()命令的搜索路径的目录列表。

6. CMAKE_MODULE_PATH

   指定要有include()或find_package()命令加载的CMake模块的搜索路径的目录列表。

7. CMAKE_INCLUDE_DIRECTORIES_BEFORE

   可以改变include_directories()命令的行为，如果变量设置为on，会导致命令将目录添加到列表前面；否则是后面。命令是指定文件目录。

8. CMAKE_IGNORE_PATH

   变量指定的是会被命令忽略的目标列表，命令包括find_program()/find_library()/find_file()/find_path()。

##### 描述系统的变量

- CMAKE_HOST_SYSTEM_NAME/CMAKE_HOST_SYSTEM_PROCESSOR/CMAKE_HOST_SYSTEM/CMAKE_HOST_SYSTEM_VERSION

  系统名称、系统架构、系统、系统版本。描述的是运行cmake的主机信息也就是编译文件的主机信息

- CMAKE_SYSTEM_NAME/CMAKE_SYSTEM_PROCERSSOR/CMAKE_SYSTEM/CMAKE_SYSTEM_VERSION

  描述可执行文件运行的主机。和上面的区别在于这里可以是ARM开发板。

- ENV

  此变量用于访问环境变量，$ENV{VAR}

##### 在CMake中双引号有什么作用

如果在命令时，命令参数有多个，用空格分隔开，那么使用双引号将多个命令参数当成一个整体。

##### 介绍下在CMake中的条件判定表达式

- <constant>

  if(constant)中如果是1、ON、YES、TRUE/Y或者非零数字判定为true。

- <variable/string>

  if(<variable/string>)条件判定中，只要变量已经定义并且是一个非假常量，则if判定为真。

- NOT<expression>

  NOT其实就类似C语言中的取反，if(NOT<expression>)条件判定中，expression为真，则if为假。

- <expr1>AND<expr2>

  类似于C语言中的逻辑与，只有两者为真时，条件判断才为真。

- <expr1>OR<expr2>

  类似于逻辑或

- COMMAND command-name

  如果command-name是已经定义的命令、函数、宏，条件判断为真。

- TARGET target-name

  如果target-name这个目标在整个工程中必须是唯一的，不可出现两个名字相同的目标，则if条件判定为真。

- EXIST path

  如果path指定的文件或目录存在，则条件判断为真。这里的path必须是文件或者目录的全路径。绝对路径。

- IS_DIRECTORY path

  同上

- IS_ABSOLUTE path

  给定的路径是绝对路径，条件判断为真。

- <variable|string> MATCHES regex

  如果给定的字符串或者变量的值与给定的正则表达式匹配，则为真。

- <variable|string> IN_LIST <variable>

  如果左边给定的变量或字符串是右边列表中的某个元素相同，则条件判断为真。

- DEFINED<variable>

  如果给定的变量已经定义，则条件判断为真。变量值不重要。

- <variable|string> LESS <variable|string>

  如果左边给定的字符串或变量的值是有效数字并且小于右侧的值，则为真。

- <variable|string> GREATER <variable|string>

  如果左边大于右侧值为真。

- <variable|string> EQUAL <variable|string>

  如果左边的有效数字等于右边，为真。

- elseif分支

##### 介绍下CMake中的循环语句

###### foreach

- foreach

  ```c
  foreach(loop_var ${my_list})
      message("${loop_var}")
  endforeach()
  ```

- 介绍下foreach循环中的RANGE关键字

  ```cmake
  foreach(loop_var RANGE stop)#循环从0到指定的数字stop，stop非负
  foreach(loop_var RANGE start stop [step])#循环从指定的数字start开始到stop结束，步长为step
  ```

- foreach循环之循环IN关键字

  ```cmake
  foreach(loop_var IN [LISTS[list][...]]] [ITEMS[item1[...]]])
  ```

  这个关键字就是用来循环列表的。

###### while

- while循环用法

  ```cmake
  while(condition)
  	command1(args)
  	...
  endwhile()
  ```

###### break/continue

- break

  break()命令用于跳出所有循环

- continue

  continue命令用于结束本次循环，执行下一次循环。

##### CMake中如何使用数学运算

math(EXPR <output variable> <math expression>)第一个采纳数是固定的关键字，第二个参数是一个返回参数，结果存在此变量中，第三个参数是一个数学运算表达式。

##### 在CMake中如何定义函数

- 利用function命令定义一个函数。

  ```cmake
  function(<name> [arg1 arg2..])#name表示函数的名称，后边是传递的参数
  command1(args..)
  command2(args..)
  endfunction(<name>)
  ```

- 使用return()命令

  在function()函数中也可以使用return语句退出函数。

- 可变参函数

  在cmake中，调用函数时实际传入参数个数大于等于定义的参数个数。

- 函数的内部变量

  可以看函数内部定义局部变量。

- 函数的作用域

  通过function()定义的函数适用范围是全局的，可以在子CMakeLists.txt中或者父源码中使用。

##### 如何创建宏定义

```cmake
macro(<name> arg1 arg2)
COMMAND1(ARGS)
...
endmacro(<name>)
```

这里的局部变量并不是变量，而是字符串替换。并且没有作用域的概念。

##### 介绍下CMake中对文件的操作

- 写文件：写、追加内容

  file(WRITE <filename> <content>)文件不存在创建文件 ，如果存在覆盖它，APPEND模式是追加到末尾，类似于应用层中的>>符号

- 写文件：由内容生成文件

  file(GENERATE OUTPUT output-file <INPUT input-file|CONTENT content>[CONDITION expression])，output-file指定输出文件名、input-file指定输入文件，content指定文件，expression判断为真。

- 读文件：字节读取

  file(READ <filename> <variable>[OFFSET <offset>] [LIMIT <max-in>] [HEX])从filename文件中读取内容并存储在variable中。从offset开始，最多读取max-in个字节。
  
- 以字符串形式读取

  file(STRINGS <filename> <variable> [<options>])从filename文件中解析ASCII字符串列表 并存储在variable中。会将文件中 的二进制数据、回车符忽略。

- 计算文件中 的hash值

  file(<MD5|SHA1|SHA224|SHA256|SHA384|SHA512> <filename> <variable>)表示不同的算法，filename指定文件，计算结果存储在variable变量中。
  
- 文件重命名

  file(RENAME <oldname> <newname>)

- 删除文件

  file(REMOVE [<files>])只能删除文件、file(REMOVE_RECURSE[<files>])，可以删除文件或目录。

##### 如果没有设置交叉编译，cmake使用什么编译器编译工程

如果没有设置，会使用默认编译器也就是主机系统的编译器，运行cmake命令的操作系统的编译器来编译工程，得到的可执行文件或者库文件只能在Ubuntu系统上运行。

##### 如何配置交叉编译器

- 配置ARM交叉编译
- 指定编译器的sysroot路径 
- 指定交叉编译器arm-gcc和arm-g++
- 为编译器添加编译选项

#####   介绍下CMake中的函数作用域

- 函数内部可以引用函数外部定义的变量
- 函数内定义的变量不可以被外部引用
- 函数内定义与外部同名的变量，全局变量会被覆盖
- 函数内不可以修改外部变量

##### 介绍下CMake中函数的返回值如何实现

往function函数中传入参数，然后将这个参数作为变量名在函数内部被设置set(${out} ${temp} PARENT_SCOPE)，参数在函数外作为变量引用。

##### 介绍下CMake中目录作用域

子目录会将父目录的所有变量**拷贝**到当前CMakeLists.txt源码中。当前CMakeLists.txt中的变量的作用域仅在当前目录有效。向下有效，子目录只能拷贝不能修改父目录中的变量。

##### 介绍下CMake中的全局作用域

缓存变量在整个CMake工程的编译生命周期内都有效，工程内的其他任意目录都可以访问缓存变量。包括修改。缓存变量通过set命令来定义set(xxx xxx CACHE)定义缓存变量。

##### CMake中的属性分为几种

- 全局属性
- 目录属性，就是CMakeLists.txt源码的属性
- 目标属性，目标文件对应的属性

CMake复习完了，目前还剩下LittleVGL和Linux应用篇了。这两个估计是没缘分复习了。明天开始正是进入第二轮复习。 