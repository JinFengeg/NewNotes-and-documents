# 刷题心得

 因为自身对于刷题的陌生，这里采用跟随嵌入式软件开发笔试面试总结中的数据结构与算法部分学习，至于用哪个网站来刷题自然而然就知道了。

数据结构建议使用C++来刷题。

# 链表

### 删除单链表的重复节点

题目描述

编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。

示例一：

```c++
//输入：[1,2,3,3,2,1]
//输出：[1,2,3]
//遍历链表，将每个元素首次出现存入另一个链表中，遍历输入的一个元素会遍历输出的所有元素，如果没有该元素就依次存入输出链表中。
//提示：链表长度在[0,20000]范围内，链表元素也在这个区间。这个提示有啥帮助么
//进阶：如果不得使用临时缓冲区，该怎么解决？这里的临时缓冲区就是我们自定义的输出链表吧，如果不得使用的话就读取输入链表中每个元素的时候遍历其自身，如果在该元素前找到相同元素就删除，找不到就保留。
```

### 解题思路

思路一：定义两个指针current和p来逐个遍历链表，current元素依次和p比较，直到p为NULL，current向后移动一个。

----

这里的current指向当前值，p是遍历current之后的所有元素，当p为NULL的时候说明遍历完了，此时current向后移动一个来检查下一个元素。这里跟我的思路其实差不多，也是遍历对比，但是人家提出了指针这个概念，用指针指向链表的每个节点。我的数据结构知识只剩下概念了，但是细节都忘了。这种方式还不需要临时缓冲区了。会多次遍历current之后的部分，遇到相同的就p删除该节点。

----

思路二：利用标记数组，标记当前值是否出现过。

---

这里用到临时缓冲区了，将遍历的元素存入标记数组，只需要遍历链表一次，遍历标记数组n-1次，其实就相当于此时p指针不再是往后遍历，而是往前遍历，遇到前面有的就删除current的节点。其实所谓的删除链表节点就是，以单链表为例，只需要让当前链表的next指针指向下下个节点即可，这样中间的节点就被删除了。只不过内存上并没有删除而已。其实要说的话，数据结构真正的代码实践还是学内核的时候。

### 代码实现

#### 方法一

```c++
struct ListNode * removeDuplicateNodes(struct ListNode *head){
    //创建一个函数，返回值是链表指针，传入参数是链表头节点指针，在这个函数中会对该链表进行修改，从输入变成输出，最后将这个输出链表的头节点返回出来。
    if(head == NULL)return NULL;//如果头结点不存在就直接退出
    struct ListNode *current = head;//创建局部变量当前节点指向头节点
    //接下来需要做个循环嵌套循环，小循环中让p指针遍历链表并删除重复节点，当p为NULL的时候退出小循环，让current指向下一个节点，然后继续循环，直到current为NULL的时候彻底退出。
    while(current)//这里判断条件应该是current，因为最后一个节点也要判断下，虽然我认为已经没有必要了。
    {
        struct ListNode *p = current;
        while(p->next)//当p已经是最后一项的时候退出
        {
            if(current->val == p->next->val)//最后时刻，p->next是最后一个节点了，如果相同删除最后一个节点，此时p->next == NULL，否则让p等于最后一个节点，而此时p->next == NULL。
            {
                p->next = p->next->next;//此时删除相同的节点
            }else{
                p = p->next;//将p指向下一个节点进行判断
            }//循环到最后应该是p指向了最后一个节点了，此时p->next应该是NULL就退出，当最后一个节点被删除的话，此时p指向的节点存在而p->next不存在，当最后一个节点没有被删除的话，此时p存在，而p->next不存在，所以我们始终要判断的是p->next是否存在
        }
        current = current->next;//最后current位于最后一个节点的时候就可以停止循环了，因为最后一个节点已经被前面所有节点对比过了。此时current->next是最后一个节点了，赋值给current，所以此时current->next == NULL直接退出，如果判断条件是current也没关系，因为此时p->next也是NULL不会循环，直接结束。
    }
    return head;//最后将这个被改造好的链表头结点指针返回出去
}
```

**对于两个循环但条件一个是current一个是p->next的原因在于，我们关注的是p->next，当p->next == NULL的时候就没有循环的必要了，p本身在上一次循环中已经判断完毕了。如果将p的初始值变成current->next的话，循环条件可以是p，而current就是我们关注的，所以只有当current本身是NULL的时候没有循环必要了。**

#### 方法二

所谓的标记数组，其实就是利用数组的索引号来快速判断当前节点是否出现过

```c++
struct ListNode *removeDuplicateNodes(Struct ListNode *head)
{
    if((head == NULL)||(head->next == NULL))
        return head;//如果head是空或者当前链表只有一个节点的话直接返回头节点
    int index[20001] = {1};//初始化一个索引0-20000的数组全为1
    index[head->val] = 0;//利用头节点的数值作为索引找到标记数组对应的元素赋值为0，以后找到的元素如果为0说明当前索引出现过，也就是当前数值重复了。
    //接下来应该给一个循环，判断当前标记数组中的元素是什么，因为涉及到删除节点的问题，需要两个指针。
    struct ListNode *pre = head;
    struct ListNode *q = head->next;
    while(q)//关注的是q
    {
        if(index[q->val] == 1)//说明数值不重合,两个指针各自指向下一个节点
        {
            index[q->val] = 0;//登记
            pre = q;
            q = q->next;
        }else{
            pre->next = q->next;//让pre的下一项直接指向其下下项，将q指向的节点删除
            q = pre->next;//此时pre指针不动，q指向下一项，但其实本质上两者还是指向相邻节点的，因为原本q指向的节点被删除，所以无论发生什么两个指针始终指向相邻节点。直到q指向空，因为我们关注的是q所以只有当q指向空的时候才说明遍历完了整个链表
        }
    }
    return head;
}
```

这里提出的pre指针就是因为删除节点需要两个指针配合。

#### 总结

删除单链表的重复节点思路就是删除，重复，单链表，凡是删除单链表就要用到两个指针，这样才能将ABC中让A直接指向C，可以让这两个链表一个是current一个是p直接在当前链表上遍历。需要两个循环，p遍历和current遍历。

如果链表中节点的数值不超过20000，链表节点个数页不超过20000，可以创建一个临时缓冲区--标记数组，借助数组连续地址的特性可以让链表数值作为数组的索引，只要输入索引就能根据数组该元素值判断是否被初始化过。第二个指针pre就是配合删除重复节点的，第二个指针q是用来遍历链表的。pre和q之间要永远是相邻节点指针。

## 如何找出链表的倒数第K个元素？

输入一个链表，输出该链表中倒数第k个节点。本题从1开始计数，即链表的尾节点是倒数第一个节点。

例如，一个链表有六个节点，从头节点开始，他们的值依次是1/2/3/4/5/6。这个链表的倒数第三个节点是值为4的节点。

```
实例：
给定一个链表1->2->3->4->5和k = 2
返回链表4->5
```

要注意单链表只能给出头节点。而且无法从最后倒推到最开始。

### 解题思路

快慢指针：设置两个指针，快指针移动速度是慢指针速度的两倍，用来判断一个链表是否是循环链表，或者找到该链表的中位数。当快指针走完的时候，慢指针正好到中位数。

这里的快慢指针并没有速度上的区别，让快指针先走k步，然后快慢指针同时走，这样当快指针变成NULL的时候，慢指针正好是倒数第k个节点。这里要算好。

### 代码实现

```c++
struct ListNode *getKthFromEnd(struct ListNode *head,int k)
{
    //创建快慢指针，然后让快指针先走k-1步，然后让快慢指针同时循环直到快指针到头
    struct ListNode *former = head;
    struct ListNode *latter = head;
    for(i = 0;i<k;i++)
    {
        former = former->next;//移动了k个距离
    }
    while(former)//循环次数未知，所以不能使用for，直接循环到former到NULL此时，latter就是距离NULL的k个距离，也就是从倒数第一个开始的倒数第k个
    {
        former = former->next;
        latter = latter->next;
    }
    return latter;
}
```

这里用到了快慢指针，准确说是两个速度相同的指针差距为k。走到头

## 如何找出链表的中间节点 

### 题目描述

给定一个带有头节点head的非空单链表，返回链表的中间结点。

如果有两个中间结点，则返回第二个中间节点。

```c
实例：
输入：[1,2,3,4,5]
    输出：此链表中的节点3，也就是345
    返回的节点值为3.
    注意，返回了一个ListNode类型的对象ans，这样：
    ans.val = 3，ans.next.val=4,ans.next.next.val=5,ans.next.next.next.val=NULL.
    事例二
    输入：[1,2,3,4,5,6]
    输出：此链表中的节点4
    由于该链表中有两个中间节点，值分别为3和4，返回第二个节点
    提示：给定链表的节点数介于1和100之间。
```

### 解题思路

这是一个典型的双指针问题。定义一个快指针，一个慢指针，快指针一次走两步，慢指针一次走一步。

如果是链表有两个中间节点，返回第二个的话，快指针可以前进的条件是：当前快指针和当前快指针的下一个结点都非空。 因为返回第二个中间节点，而快指针一次走两步，所以要保证**快指针可以再走一次**，这样就走到NULL了，而慢指针也就到第二个中间节点了

如果是两个中间节点，返回第一个的话，快指针可以前进的条件是：当前快指针的下一个节点是非空并且下一个节点的下一个节点也是非空，这样就可以保证快指针不会走到链表的头，**不会多走一次**，这样慢指针就停留在第一个中间节点。

### 代码实现

```c++
struct ListNode *middleNode(struct ListNode *head)
{
    //创建快慢指针，循环判断结束
    struct ListNode *faster = head;
    struct ListNode *slower = head;
    while(faster!=NULL && faster->next!=NULL)
    {
        faster = faster->next->next;
        slower = slower->next;
    }
    return slower;
}
```

主要点就是循环的判定条件。

## 反转链表

### 题目描述

定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。

```
实例：
输入：1->2->3->4->5->NULL
输出：5->4->3->2->1->NULL
限制：0<=节点个数<=5000
```

我感觉就是设置两个指针，分别指向两个节点，然后修改两个节点的next指针，一直遍历整个链表。

### 解题思路

反转链表实际就是重新指向结构体中的next指针，我们需要修改下一个节点的next指针指向前一个节点。所以，在遍历链表时我们要逐个修改链表的指针指向。

也可以递归来做。

### 代码实现

#### 非递归

```c++
struct ListNode *reverseList(struct ListNode *head){
    //判断下链表长度
    if((head == NULL) ||(head->next == NULL))
    {
        return head;
    }else{
        //需要三个指针来记录节点，才能实现反转链表
        struct ListNode *former = NULL;
        struct ListNode *midder = head;
        struct ListNode *latter = NULL;
        while(midder !=NULL)//在循环中需要让三个节点位移，直到former指向NULL结束
        {
            former = midder->next;//移动顺序应该是former获得下一项节点，修改midder的next指针，移动latter和former到下一项。直到midder变成NULL，说明整个链表都被反向了，每次循环只修改midder项的next指针，所以需要让midder遍历整个链表。
            midder->next = latter;
            midder = former;
            latter = midder;
        }
        return latter;//重点在于每次循环midder移动一项并修改起始值的next，所以要让midder移动到NULL的时候才会修改最后一项的next，而此时latter正好指向最后一项。
    }
}
```

要搞清楚每次循环中各个指针的移动情况，以及修改next的情况。

使用三个指针原因是：

former是用来保存下一个节点的，并不是要修改这个指针指向的节点的next，

主要是靠midder来修改链表方向，

而ladder是用来保存上一个节点的信息，循环结束后ladder将是头结点。

因为每次循环需要保存下一个节点，修改当前节点方向，跳跃到下一个节点。

#### 递归

递归意味着我们编写的函数被自身调用。每次调用的函数只有在调用自身前的部分可以执行，等到最深处被调用的函数return了才能依次执行调用自身后的部分。可以获知每次递归环境内要包含前中后三个节点信息才能实现反转链表。

一直递归到链表的最后一个节点，该结点就是反转后的头结点，记作head。之后，每次函数在返回的过程中，让当前节点的下一个结点的next指针指向当前节点。同时让当前节点的next指针指向NULL，从而实现从链表尾部开始的局部反转。

```c++
struct ListNode *reverseList(struct ListNode *head)
{
    if(head == NULL || head->next == NULL)//这个判定是用于正向遍历链表找到最终的尾结点，也就是反转后的头结点，因为递归不能一直递归下去，要给一个终点，这里head == NULL是预防本身头结点就是一个空。head->next这个条件才是刹车条件
        return head;//这里返回的将是最后一个节点
    else{
        //这里将分为两部分，调用自身前和自身函数返回之后，也正是这两部分实现遍历链表和反转链表的。
        struct ListNode *midder = head;//让midder等于当前节点
        struct ListNode *ladder = midder->next;//保存下一个节点
        head = reverseList(ladder);//递归，第一次递归返回是if为真，返回的将是尾结点，这个尾结点赋值给head将是最终的头结点，所以需要留到最后
        //这部分是递归返回后执行的部分，此时ladder需要指向midder实现反转，考虑到midder最终将是尾结点，所以每次递归指向NULL
        ladder->next = midder;
        midder->next = NULL;
        return head;//保存反转后的头结点，这也将导致无论函数代入什么ladder返回的都是头结点
    }
}
```

使用递归方法的话，不需要三个指针，因为我们会让函数返回值变成头结点，这样就不需要最落后的指针了。

递归可以分为三个部分，遍历找到尾结点，遍历反转链表，返回头结点。

想要递归找到尾结点需要设置刹车条件。

每次遍历涉及到两个节点，让下一个节点成为下次递归的当前节点。

找到尾结点触发刹车条件将尾结点返回。

此时返回到上一层递归调用自身函数，将当前递归层的两个节点指向反转，

将尾结点作为本次递归的返回值，这样就能一直返回到最初的递归层。

递归难点在于具有多个递归层。

## 环形链表

### 题目描述

给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回NULL。为了表示给定链表的环，使用整数pos来表示链表尾连接到链表中的位置（索引从0开始）。如果pos是-1，则在该链表中没有环。

说明：不允许修改给定的链表。

环形链表，我第一个想到的就是快慢指针，只要让快慢指针重合就说明这是一个环形链表了。

### 示例一

<img src="C:\Users\MACHENIKE\AppData\Roaming\Typora\typora-user-images\1675564963416.png" alt="1675564963416" style="zoom:25%;" />

### 解题思路

针对这种链表上有一个环的题，需要查找环起点，

<img src="C:\Users\MACHENIKE\AppData\Roaming\Typora\typora-user-images\1675566886424.png" alt="1675566886424" style="zoom:25%;" />

设快慢指针，快指针是慢指针速度的两倍，同时从A点出发。相遇在C点

```
S1 = Y+X
S2 = Y+NR+X
2S1 = S2
//实际上要找到环起点其实就是求Y的大小
Y = NR-X
//此时知道了Y的等价公式，那么让快慢指针以相同的速度走完这两段相同的路程花费的时间是相同的，也就是说此时两个指针是可以相遇的。让快慢指针第一次相遇之后，调整快指针的速度，从头节点出发，则快慢指针再度相遇时，快指针正好走完Y的路程，此时正好处在环起点。重点来了，那么慢指针虽然速度不变，但是从哪里开始移动呢，NR-X这个路程正好是从C点出发经过若干圈后到达环起点B的路程。所以慢指针从第一次相遇点出发。
```

### 代码实现

```c++
struct ListNode *detectCycle(struct ListNode *head)
{
    struct ListNode *fast = head;
    struct ListNode *slow = head;
    while(fast !=NULL &&fast->next !=NULL)
    {
        fast = fast->next->next;
        slow = slow->next;
        if(fast == slow)//第一次相遇点
        {//通过数学推导可知，快慢指针以相同的速度移动，快指针从头节点出发，慢指针从相遇点出发，再次相遇时便是环起点。
            fast = head;
            while(fast != slow)
            {
                fast = fast->next;
                slow = slow->next;
            }
            //第二次相遇点
            return slow;
        }
    }
    return NULL;
}
```

环形链表求环起点，最终走到这个Y = Nr-x公式，此时让快慢指针分别从头节点，在环形链表中距离环起点有x偏移处，以相同的速度出发，因为路程相同，所以同时到达终点，而快指针的终点是环起点，慢指针走过N圈的周长再减去x的偏移，此时终点也是环起点，所以应该是重合的。

##  单链表相交，如何求交点？

### 题目描述

给定两个单向链表，判断他们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同，这里其实不太懂指的是地址完全相同吗）则这两个链表相交。

示例一

![1675648484072](C:\Users\MACHENIKE\AppData\Roaming\Typora\typora-user-images\1675648484072.png)
注意

如果两个链表没有交点，返回null，在返回结果后，两个链表仍需保持原有的结构。可假定整个链表结构中没有循环。程序尽量满足O(n)时间复杂度，且仅用O()
### 解题思路
这种题要什么思路，直接从头节点往下走，根据提供的skip数移动，然后对比下两个指针保存的地址是否相同不就好了。
两个链表相交的点是指：两个指针保存的地址完全相同，这说明该结点既在A链表上又在B链表上，进而说明A和B是相交的而对于相交的情况，两条链表一定是这种结构

 <img src="file:///C:\Users\MACHENIKE\AppData\Roaming\Tencent\Users\1056022510\QQ\WinTemp\RichOle\EX5@4VLX8TZW6LIETOR5`9Q.png" alt="img" style="zoom:33%;" /> 

首先明确这两个链表是单链表，一旦二者相交，而每个节点只有一个next指针。必然是这个形状的。想要找出交点同样利用追逐问题，让两个指针以相同的速度从AB两个链表的头结点开始走，当走完之后从对方的头结点开始走。这能保证二者的路程都是AD+DC+BD+DC，速度相同，路程相同，二者必然会同时到达终点，既然能同时到达终点，必然会同时到达交点，因为交点之后是同一段路。
### 代码实现
```c
struct ListNode *getIntersectionNode (struct ListNode *headA,struct ListNode *headb)
{
//传入两个链表的头结点，接下来让两个链表循环走完整个路程，只要指针重合就退出
struct ListNode *p = heada;
struct ListNode *q = headb;
while(p != q)//这里直接对比地址
{
	//需要判断下是否走到尽头，因为需要给他们切换头结点
	if(p->next == NULL)//这里并不是要对节点进行什么操作，只要走完全程即可，所以这里只要p到达尾结点即可
	{
		p = headb;
	}else{
	p = p->next;
	}
	if(q->next == NULL)
	{
	q = heada;
	}else
	{
	q = q->next;
	}
}
return q;
}
```
重点就是要把那个图想出来，只要走完二者的链表那么他们的路程就是相同的，还是同一个尾结点，必然会相遇。
## 回文链表
### 题目描述
编写一个函数，检查输入的链表是否是回文的。

这里的回文指的是比如1->2->2->1这样对称的就是回文链表.

输入:1->2->2->1

输出：true

注意这里的输入是函数参数，输出是函数返回值

### 解题思路

利用双指针找到链表的中间位置，然后将后半段反转，将后半段依次与前半段比较。

### 代码实现

```c
bool isPalinrome(struct ListNode *head)
{
//将代码分成两个循环，第一个专门用来找到中间位置，准确说是有一个中间位置的时候选中间，当有两个中间位置的时候选择第二个中间位置。
struct ListNode *mid = head;
struct ListNode *lad = head;
while(lad !=NULL && lad->next != NULL)
{
lad = lad->next->next;
mid = mid->next;
}//此时mid为中间或者中间的下一项，而lad为尾结点或者NULL
//接下来分为两种讨论，要么中间+尾结点，要么是下一项+NULL，其实没有必要，无论怎么样，我们最后让反转过来的后半部链表与整体链表对比就可以了。直到后半部分链表为NULL。

struct ListNode *p = mid;
struct ListNode *q = NULL;
struct ListNode *g = NULL;
while(p != NULL)//当p等于NULL说明此时已经全部反转了，并且g = 尾结点
{
	q = p->next;//保存下一项
	g = p;//保存上一项
	p->next = g;//指向上一项
	p = q;//进行位移
}
//此时将反转过的后半部链表与整个链表比较，直到遍历整个后半部链表，这样就无所谓中间节点还是中间节点的下一项
struct ListNode *k = g;
struct ListNode *l = head;
while(k && l)//注意，此时原本的链表已经被我们拆分成两个了，所以此时前半段和后半段不一定谁更长，直到有一方指向NULL位置
{
if(k->val == l->val)
{
k = k->next;
l = l->next;
}else{
return false;
}
return true;
}
}
```
需要注意的是：
1.中间节点**无所谓是正中间还是后一个**，最后让前半部分和后半部比较直到有一方指向空就行
2.当我们将后半部反转的时候，就已经破坏原本的链表了，所以只能是前半部分和后半部比较，除非事先备份。

## 移除重复节点
### 题目描述
这个和移除单链表中重复节点一模一样。
## 用普通算法实现两个有序链表的合并
### 题目描述
将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成。
实例：
输入：1->2->4,1->3->4
输出：1->1->2->3->4->4
### 解题思路
#### 方法一

非递归
我理解就是打擂台，升序链表简单一些，从两边的头结点开始，谁数值大谁留下和对面的下一项开始比较。被淘汰的作为头结点。

### 代码实现
```c
typedef struct ListNode{
    int val;
    ListNode *next;
}ListNode;
struct ListNode *mergeTwoLists(struct ListNode *heada,struct ListNode *headb)
{
struct ListNode *a = heada;
struct ListNode *b = headb;
struct ListNode *head = (struct ListNode *)malloc(sizeof(struct ListNode));//动态开辟一个链表头结点内存空间
struct ListNode *c = head;
while(a && b)//直到两者有一个为NULL了
{
	if(a->val <= b->val)//即使二者相等，也只拿出一个放到c中 ，另一个自然会在下一次循环中被淘汰
	{
	c->next = a;
	a = a->next;
	}else
	{
	c->next = b;
	b = b->next;
	}
	c = c->next;//每次循环移动一位
}
//还需要将另一个链表剩下的成员依次放入
c->next = (NULL == a ? b :a);//这种用法需要查下。如果a == NULL为真，返回b，否则返回a，我们虽然是要把所有的剩余节点都存入链表c中，但其实我们只需要存入一个节点即可，他自己就连接着后边的所有节点。之前的三叉戟问题就是。
return head->next;//此时的head就是我们开辟出来的内存首地址，但是并没有数据，他的下一项才是我们要用的头结点，这样我们才能最终返回头结点，如果不开辟内存，而是自动变量的话，最终找不到头结点了。
}
```

#### 方法二

递归

创建一个将更小值存入链表的函数，内部调用传入需要比较的两者，返回值存入链表，此时头结点依旧是头结点，所以不需要把最底层的尾结点返回出来了。进入的路程是比较出来两者的大小，返回的路程是将更小值存入链表中。

```c
struct ListNdoe *mergeTwoLists(struct ListNode *l1,struct ListNode *l2)
{
    //先编写刹车条件
    if(l1 == NULL)return l2;//当l1已经遍历完的话，此时l2也许遍历完了，也许没有，所以返回l2这将是最大值。
    if(l2 == NULL)return l1;
    //接下来实现函数进入的功能，比较大小
    if(l1 <= l2)
        l1->next = mergeTwoLists(l1->next,l2);//如果l1小于l2的话，就让l1的下一项与l2进行比较，然后返回更小值，将这个更小值赋值给当前链表的下一项。这里是先找到l1的下一项，然后再赋值给l1的下一项。所以并不会影响上一步
    return l1;
     else
        l2->next = mergeTwoLists(l2->next,l1);
    return l2;
}
```

递归真的很神奇，刹车条件，进入的任务，退出的任务。

# 树

红黑树用于管理内核的CFS调度器的备选进程队列。

## 二叉树先序遍历(递归和非递归)

### 先序遍历规则

先序遍历的核心思想：

1. 访问根节点；
2. 访问当前节点的左子树
3. 如果当前节点无左子树，访问当前节点的右子树；

考察到一个节点后，即可输出该节点的值，并继续遍历其左右子树。二叉搜索树是左子树小于根节点小于右子树。平衡二叉搜索树是所有叶子结点深度差不超过1。自平衡二叉搜索树是指其操作都试图维持平衡的二叉搜索树。

### 先序遍历代码（递归）
感觉二叉树很适合递归，只需要写一个获取根节点，检测左子树，如果左子树不存在检测右子树即可。
```c
//这是将输入输出都自己编写的方式。LeetCode上是只需要自己编写输出函数，但是大厂的笔试题是这种都需要自己编写的。
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define TElemType int
//构造节点的结构体
typedef struct BiTNode{
	TElemType data;//数据域
	struct BiTNode *lchild,*rchild;
}BiTNode ,*BiTree;//BiTNode是结构体的类型在动态创建内存的时候用到，而*BiTree是指向结构体类型的指针。

//初始化树的函数
void CreateBiTree(BiTree *T){//这里不太理解为什么要设置形参是结构体指针的指针，设置一重指针不可以么，传入的也是地址。
(*T) = (BiTree)malloc(sizeof(BiTNode));
(*T) ->data = 1;
(*T)->lchild = (BiTree)malloc(sizeof(BiTNode));
(*T)->rchild = (BiTree)malloc(sizeof(BiTNode));
//创建左子树的节点
(*T)->lchild->data = 2;
(*T)->lchild->lchild = (BiTree)malloc(sizeof(BiTNode));
(*T)->lchild->rchild = (BiTree)malloc(sizeof(BiTNode));
//创建一节点的右子树
(*T)->lchild->rchild->data = 5;
(*T)->lchild->rchild->lchild = (BiTree)malloc(sizeof(BiTNode));
(*T)->lchild->rchild->rchild = (BiTree)malloc(sizeof(BiTNode));
//右子树
(*T)->rchild->data = 3;
(*T)->rchild->lchild = (BiTree)malloc(sizeof(BiTNode));
(*T)->rchild->rchild = (BiTree)malloc(sizeof(BiTNode));
//
(*T)->rchild->lchild->data = 6;
(*T)->rchild->lchild->lchild = (BiTree)malloc(sizeof(BiTNode));
(*T)->rchild->lchild->lchild = (BiTree)malloc(sizeof(BiTNode));
//
(*T)->rchild->rchild->data = 7;
(*T)->rchild->rchild->lchild = NULL;
(*T)->rchild->rchild->rchild = NULL
//
(*T)->lchild->lchild->data = 4;
(*T)->rchild->rchild->lchild = NULL;
(*T)->rchild->rchild->rchild = NULL;
}
//模拟操作节点元素的函数，输出节点本身的数值
void PrintBiT(BiTree elem)
{
printf("%d",elem->data);
}
//先序遍历
void PreOrderTraverse(BiTree T){
if(T){//如果传入实参
	PrintBiT(T);//打印头结点的数值
	PreOrderTraverse(T->lchild);
	PreOrderTraverse(T->rchild);//只需要打印
}
//如果节点为空，返回上一层
return;
}

int main(){
	BiTree Tree;
	CreateBiTree(&Tree);//如果是在函数中动态开辟空间的话，为了把开辟的地址传出来，这里需要传入地址，但如遇Tree在外面就开辟了空间，那么直接将这个Tree指针传入就可以了，因为此时我们是将地址传入了。
	printf("先序遍历:\n");
	PreOrderTraverse(Tree);
}
```
这个先序遍历二叉树，感觉没啥难度。这里主要是输入输出一起实现了。

### 先序遍历代码(非递归)

循环的内容应该是输出当前结点的数值，然后判断当前结点的左子树是否存在，存在就指针指向左子树，不存在就右子树。当指针指向叶子结点的时候就需要回溯了退回到叶子结点的父节点，当指向右侧的叶子结点就回溯到其父节点的父节点。

这里的回溯指的是用一个数组来缓存每次遍历到的节点的右子树。有趣的是这里实际上是用数组实现的一个栈（先进后出），共有两个循环，第一个循环实现栈的弹出，当栈空了就结束了。嵌套一个循环是实现栈的压入，将每一次访问节点的右子树压入栈。遍历左子树。当指针变成NULL退出，开始出栈，按照顺序从底层的右子树不断的退回到根节点的右子树。

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define TElemType int//这里是将int宏替换成了可辨识的字符串，因为不是指针所以和typedef关键字没区别
typedef struct BiTNode{//内核的链表就不这样，每个节点中没有数据域，只有上下的指针，这样可以让每个包含链表节点的父结构类型不同，通过宏container_of找到节点的父结构。
    TElemType data;//数据域
    struct BiTNode *lchild,*rchild;//左右孩子指针
}BiTNode,*BiTree;
//定义了二叉树的节点之后就是定义栈了
int top = -1;
BiTree a[20];//创建一个栈，还需要创建压栈和出栈函数
//初始化树
void CreateBiTree(BiTree *T)//传入的是二重指针
{
    //创建根节点
    (*T) = (BiTree)malloc(sizeof(BiTNode));
    (*T)->data = 1;
    (*T)->lchild = (BiTree)malloc(sizeof(BiTNode));
    (*T)->rchild = (BiTree)malloc(sizeof(BiTNode));
    //根节点的左子树
    (*T)->lchild->data = 2;
    (*T)->lchild->lchild = (BiTree)malloc(sizeof(BiTNode));
    (*T)->lchild->rchild = (BiTree)malloc(sizeof(BiTNode));
    //根节点的左子树的左子树
    (*T)->lchild->lchild->data = 4;
    (*T)->lchild->lchild->lchild = NULL;
    (*T)->lchild->lchild->rchild = NULL;
    //根节点左子树的右子树
    (*T)->lchild->rchild->data = 5;
    (*T)->lchild->rchild->rchild = NULL;
    (*T)->lchild->rchild->lchild = NULL;
    //根节点右子树
    (*T)->rchild->data = 3;
    (*T)->rchild->rchild = (BiTree)malloc(sizeof(BiTNode));
    (*T)->rchild->lchild = (BiTree)malloc(sizeof(BiTNode));
    //根节点的右子树的左子树
    (*T)->rchild->lchild->data = 6;
    (*T)->rchild->lchild->lchild = NULL;
    (*T)->rchild->lchild->rchild = NULL;
    //根节点的右子树的右子树
    (*T)->rchild->rchild->data = 7;
    (*T)->rchild->rchild->lchild = NULL;
    (*T)->rchild->rchild->rchild = NULL;
}
//压栈函数，将右子树压入栈数组中
void Push(BiTree *a,BiTree p)//前者a是一个二重指针对应指针数组a
{
    a[++top] = p;//这里是将该右子树的地址压入栈，并不是对我们传入的指针进行操作什么所以不需要使用二重指针
}
//弹栈函数，这里只是修改了（数组的当前索引）栈指针
void Pop(void)
{
    if(top == -1)
    {
        return;
    }
    top--;
}
void PrintBiT(BiTree p)
{
    printf("%d",p->data);
}

//获取栈顶元素，毕竟出栈函数只是修改了当前栈的索引，并没有提取出元素
BiTree GetTop(BiTree *a)
{
    return a[top];
}
//先序遍历
void PreOrderTraverse(BiTree Tree)//传入根节点
{
    BiTree p;
    //无论做什么，先将根节点压栈
    Push(a,Tree);//第一个参数应该传入指针数组的地址，这里就传入a就可以，如果&a表示的是整个数组的地址，此时如果自加地址的话就是增加整个数组的地址，此时的a表示的是数组首元素的地址。
    //进入大循环，在大循环中实现出栈
    while(top != -1){//当栈内有数据的话循环，并在循环中压栈出栈，直到将整个二叉树遍历结束。最后一次循环的时候p在最右侧的右子树，出栈后top == -1，然后进入小循环输出，跳出小循环跳出大循环
        p = GetTop(a);//从数组a中获取节点指针。
        Pop();//出栈
        
        while(p)//小循环中遍历左子树以及压栈右子树,p为NULL时说明此时已经到达最左侧的左子树叶子结点，跳出循环进行回溯
        {
            if(p->rchild)//因为右子树不一定存在所以判断
            {
                Push(a,p->rchild);//这里将右子树压入栈中
            }
            PrintBiT(p);
            p = p->lchild;
        }
    }
}

int main(void)
{
    BiTree Tree;
    CreateBiTree(&Tree);//因为二叉树是在函数内部分配的内存。想要把指向该内存的指针带出来就需要传入地址。
    PreOrderTraverse(Tree);
    return 0;
}
```

关于这个二叉树的先序遍历的非递归要比递归方式麻烦一些，因为二叉树本身结构的特点，当遍历到最左侧的叶子结点之后需要回溯到父节点来访问其右子树。这里巧妙的借助了栈的特点先进后出。

整个循环中的操作就是打印当前节点数据，将右子树压栈，访问其左子树。当循环到叶子结点后将压栈的右子树依次出栈。出栈后继续访问右子树的左子树，如果为NULL就继续出栈，继续访问上一层的右子树。这个方法利用了二叉树先序遍历的顺序特点以及栈先入后出的特点。很精妙。

## 二叉树中序遍历(递归和非递归)

### 中序遍历规则

4251637

找到根节点，遍历根节点的左子树，找到节点2，遍历节点2的左子树，找到节点4打印，打印节点2，遍历节点2的右子树，找到节点5打印，打印节点1，遍历节点1的右子树，找到节点3，遍历节点3的左子树，找到节点6，遍历节点6的左子树，没有，打印节点6，打印节点3，遍历节点3的右子树，找到节点7，遍历节点3的左子树，找到节点6，遍历节点6的左子树没有，打印节点6，打印节点3，遍历节点3的右子树，找到节点7，遍历节点7的左子树，没有，打印节点7，遍历节点7的右子树，没有，退出。

<img src="C:\Users\MACHENIKE\AppData\Roaming\Typora\typora-user-images\1675906395662.png" alt="1675906395662" style="zoom:25%;" />

### 中序遍历代码(递归)

创建二叉树、判断当前指针是否为空，然后调用自身传入左子树，打印节点，调用自身传入右子树。相当于一直往左子树走，走到头以后打印当前节点，然后往该节点的右子树走，访问每个节点的顺序都是左中右。

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define TElemType int
//定义二叉树的节点类型
typedef struct BiTNode{//这里的BiTNode指的是结构体名称
    TElemType data;//数据域
    struct BiTNode * lchild, *rchild;//注意，这里不能使用BiTree
}BiTNode,*BiTree;//这里是定义了结构体类型的别名为BiTNode以及指向该结构体的指针
//创建二叉树
void CreateBiTree(BiTree *T)
{
    //节点1
    (*T) =  (BiTree)malloc(sizeof(BiTNode));
    (*T)->data = 1;
    (*T)->lchild = (BiTree)malloc(sizeof(BiTNode));
    (*T)->rchild = (BiTree)malloc(sizeof(BiTNode));
    //节点1的左子树
    (*T)->lchild->data = 2;
    (*T)->lchild->lchild = (BiTree)malloc(sizeof(BiTNode));
    (*T)->lchild->rchild = (BiTree)malloc(sizeof(BiTNode));
    //节点2的左子树
    (*T)->lchild->lchild->data = 4;
    (*T)->lchild->lchild->lchild = NULL;
    (*T)->lchild->lchild->rchild = NULL;
    //节点2的右子树
    (*T)->lchild->rchild->data = 5;
    (*T)->lchild->rchild->lchild = NULL;
    (*T)->lchild->rchild->rchild = NULL;
    //节点1的右子树
    (*T)->rchild->data = 3;
    (*T)->rchild->lchild = (BiTree)malloc(sizeof(BiTNode));
    (*T)->rchild->rchild = (BiTree)malloc(sizeof(BiTNode));
    //节点3的左子树
    (*T)->rchild->lchild->data = 6;
    (*T)->rchild->lchild->lchild = NULL;
    (*T)->rchild->lchild->rchild = NULL;
    //节点3的右子树
    (*T)->rchild->rchild->data = 7;
    (*T)->rchild->rchild->lchild = NULL;
    (*T)->rchild->rchild->rchild = NULL;
}
//显示函数
void PrintBiT(BiTree elem){
    printf("%d",elem->data);
}
//中序遍历
void INOrderTraverse(BiTree T)
{
    if(T)//刹车条件是当找到叶子节点
    {//把这个函数当成是对每个节点的操作，先找节点的左子树，然后打印节点，找节点的右子树，对所有的节点都是这么操作的。
        INOrderTraverse(T->lchild);//先遍历其左子树
        PrintBiT(T);//返回路上打印当前点，然后遍历当前点的右子树
        INOrderTraverse(T->rchild);//进入右子树之后也是先找其左子树。
    }
    return;
}
int main()
{
    BiTree T;
    CreateBiTree(&T);
    INOrderTraverse(T);
}
```

### 中序遍历代码(非递归)

---

回顾下先序遍历代码，小循环中打印当前点，判断是否存在右子树存在就压栈，然后让指针移动到左子树。一个循环中将三个节点都操作了。因为需要最后打印右子树所以将右子树压栈了。

---

非递归的话，创建二叉树，创建堆，在小循环中把左子树压栈。在大循环中出栈打印，然后将当前节点的右子树压栈。第一次打印最左侧的左子树，然后其右子树为空不打印，然后打印最左侧左子树的父节点，然后将其右子树压栈，下一次循环中打印右子树。

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define TElemType int
//定义二叉树的节点类型
typedef struct BiTNode{//这里的BiTNode指的是结构体名称
    TElemType data;//数据域
    struct BiTNode * lchild, *rchild;//注意，这里不能使用BiTree
}BiTNode,*BiTree;//这里是定义了结构体类型的别名为BiTNode以及指向该结构体的指针
//创建二叉树
void CreateBiTree(BiTree *T)
{
    //节点1
    (*T) =  (BiTree)malloc(sizeof(BiTNode));
    (*T)->data = 1;
    (*T)->lchild = (BiTree)malloc(sizeof(BiTNode));
    (*T)->rchild = (BiTree)malloc(sizeof(BiTNode));
    //节点1的左子树
    (*T)->lchild->data = 2;
    (*T)->lchild->lchild = (BiTree)malloc(sizeof(BiTNode));
    (*T)->lchild->rchild = (BiTree)malloc(sizeof(BiTNode));
    //节点2的左子树
    (*T)->lchild->lchild->data = 4;
    (*T)->lchild->lchild->lchild = NULL;
    (*T)->lchild->lchild->rchild = NULL;
    //节点2的右子树
    (*T)->lchild->rchild->data = 5;
    (*T)->lchild->rchild->lchild = NULL;
    (*T)->lchild->rchild->rchild = NULL;
    //节点1的右子树
    (*T)->rchild->data = 3;
    (*T)->rchild->lchild = (BiTree)malloc(sizeof(BiTNode));
    (*T)->rchild->rchild = (BiTree)malloc(sizeof(BiTNode));
    //节点3的左子树
    (*T)->rchild->lchild->data = 6;
    (*T)->rchild->lchild->lchild = NULL;
    (*T)->rchild->lchild->rchild = NULL;
    //节点3的右子树
    (*T)->rchild->rchild->data = 7;
    (*T)->rchild->rchild->lchild = NULL;
    (*T)->rchild->rchild->rchild = NULL;
}
//显示函数
void PrintBiT(BiTree elem){
    printf("%d",elem->data);
}
//创建堆
BiTree a[20] = {0};
TElempty top = -1;
//创建压栈函数
void Push(BiTree *a,BiTree T)//指针数组、指针
{
    a[++top] = T;
}
//创建出栈函数
void Pop()
{
    if(top == -1)
    {
        return;
    }
    top--;
}
//创建获取栈顶元素函数
BiTree GetTop(BiTree *a)
{
    return a[top];
}
//中序遍历二叉树非递归算法
void INOrderTraverse1(BiTree Tree)
{
    BiTree p = Tree;
        Push(a, p);//要先将根节点压栈
    while(top != -1)
    {
        while(p=GetTop(a))//当将NULL压栈时退出
        {//在小循环中将最左侧的左子树压栈
            Push(a,P->lchild);
        }
        Pop();//因为栈顶是NULL，先让他出栈
        p = GetTop(a);//获得左子树
        PrintBiT(p);//打印当前值
        Push(a,p->rchild);//当p是叶子结点时，此时右子树为null不会进入小循环，并且每次推出小循环都会将栈顶元素出栈，当右子树不为null时，说明此时还需要遍历该右子树的左子树，所以进入小循环等到把其左侧的左子树遍历结束，再次开始出栈，直到右子树为空才会不进入小循环。
    }
}
int main()
{
    BiTree p;
    CreateBiTree(&p);
    PrintBiTree(p);      
}
```

有两种方法实现非递归的中序遍历，第一种方法如上，这种方法特点在于将一条斜线上的左子树都压栈完才会退出小循环，当不进入小循环时就依次将每个左子树的右子树压栈。当右子树为空时，会事先将栈顶空元素出栈，当右子树不为空时会遍历其左子树直到将空元素入栈，然后将栈顶空元素出栈

思路就是无论如何都要把当前能找到的左子树入栈，如果没有左子树就通过将右子树压栈，再找右子树的左子树压栈。这个算法特点是没有根节点的概念，只存在左子树和右子树。相比之下先序遍历确实简单，我们往往最先找到的是根节点，而最先输出的也是根节点，只要在小循环中直接把当前节点输出就好了。

另一种方法也是一样的思想，先找其左子树，当找完其左子树之后再去通过找右子树的方式找到新的左子树，小循环中就是用来让左子树压栈，大循环中是输出节点并压栈右子树。只要右子树不为空就要在下一次循环中进入小循环继续找左子树。
```c
void InOrderTraverse2(BiTree Tree)
{
BiTree p;
    p = Tree;
while(top!=-1 || p)//循环条件需要判断遍历整个二叉树或者当前右子树不为空，两者都为空的时候表示遍历结束
{
    while(p)//小循环中遍历当前能遍历的左子树并压栈。直到p为空
    {
        Push(a,p);//先入栈可以避免NULL入栈，第二次进入循环的时候p是右子树，
        p = p->lchild;
    }//每一次退出小循环，说明此时把能找到的左子树都找到，而中序遍历的左根右，直接输出。
    p = GetTop(a);//别忘了当前p是null需要把栈顶给他
    PrintBiT(p);//直接打印。
    Pop();//出栈。
    p = p->rchild;//此时左子树输出了。接下来判断下其是否有右子树，如果没有的话，不进入小循环，而是继续出栈打印。但是第二次循环的时候p就不是叶子结点了，此时已经打印了两次把左和根打印了，接下来就需要查看右子树了。此时右子树存在那么进入小循环，当前最应该打印的就是右子树的左子树。如果此时找不到的话，不进入小循环，在下一次大循环中将这个右子树打印。不进入小循环，在下一次大循环中继续出栈打印，此时打印的就是上一个左子树了。
    
}
}
```

第二种理解的比较好，只要栈的索引或者当前指针不为空就不算遍历结束，小循环中遍历能找到的左子树，大循环中打印，并试图寻找右子树。找到了就小循环，找不到就出栈吃老本。不过判断条件与第一种不同。小循环是找不到节点就吃老本，找到了就开辟新的左子树。当老本吃光了并且找不到新节点才退出大循环。

## 二叉树后序遍历(递归和非递归)

### 后序遍历规则

二叉树后序遍历的实现思维是：1.访问左子树；2.访问右子树；3.完成该节点的左右子树的访问后再访问节点。

### 后序遍历举例

<img src="C:\Users\MACHENIKE\AppData\Roaming\Typora\typora-user-images\1675996745803.png" alt="1675996745803" style="zoom:25%;" />

如上图中，对此二叉树进行后序遍历的操作过程为：

4526731

对此二叉树进行后序遍历 的操作过程为：

1. 从根节点1开始，遍历该节点的左子树。
2. 遍历节点2的左子树；
3. 遍历节点4的左子树，但是此时节点4并没有左子树，也没有右子树，所以访问节点4，回退到节点2，遍历节点2的右子树。
4. 由于节点5并没有左右字数，访问节点5之后，返回节点2，此时节点2的左右字数遍历完成，访问节点2
5. 回退到节点1，遍历节点1的右子树
6. 遍历节点3的左子树
7. 节点6没有左右子树，访问节点6，回退到节点3，遍历节点3的右子树
8. 节点7并没有左右子树，访问节点7，回退到节点3，访问节点3
9. 回退到节点1，访问节点1

### 后续遍历代码(递归)

其实思路很清晰，在每一次递归中只对一个节点进行处理。每个节点的处理方式都应该是访问其左子树，访问其右子树，最后访问其节点。
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
//创建二叉树节点类型
typedef struct BiTNode{
	int data;
	BiTNode *lchild,*rchild;
}BiTNode ,*BiTree;

//创建二叉树函数
void CreateBit(BiTree *T)
{
//创建节点1
(*T) = (BiTree)malloc(sizeof(BiTNode));
(*T)->data = 1;
(*T)->lchild = (BiTree)malloc(sizeof(BiTNode));
(*T)->rchild = (BiTree)malloc(sizeof(BiTNode));
//创建节点2
(*T)->lchild->data = 2;
(*T)->lchild->lchild = (BiTree)malloc(sizeof(BiTNode));
(*T)->lchild->rchild = (BiTree)malloc(sizeof(BiTNode));
//创建节点3
(*T)->rchild->data = 3;
(*T)->rchild->lchild = (BiTree)malloc(sizeof(BiTNode));
(*T)->rchild->rchild = (BiTree)malloc(sizeof(BiTNode));
//创建节点4
(*T)->lchild->lchild->data = 4;
(*T)->lchild->lchild->lchild = NULL;
(*T)->lchild->lchild->rchild = NULL;
//创建节点5
(*T)->lchild->rchild->data = 5;
(*T)->lchild->rchild->lchild = NULL;
(*T)->lchild->rchild->rchild = NULL;
//创建节点6
(*T)->rchild->lchild->data = 6;
(*T)->rchild->lchild->lchild = NULL;
(*T)->rchild->lchild->rchild = NULL;
//创建节点7
(*T)->rchild->rchild->data = 7;
(*T)->rchild->rchild->lchild = NULL;
(*T)->rchild->rchild->rchild = NULL;
}

//创建打印函数
void PrintBiT(BiTree p)
{
    printf("%d",p->data);
}
void PreOrderTraverse(BiTree T)
{
    BiTree p = T;
    if(p)
    {
        PreOrderTraverse(p->lchild);
        PreOrderTraverse(p->rchild);
        PrintBiT(p);
    }
    return;
}
int main(void)
{
    BiTree p;
    CreateBit(&p);
    PreOrderTraverse(p);
}
```

二叉树的先序中序后序在代码上区别不大，思路就是每一次递归都是针对一个节点进行的。不要用前进和归途的思想。因为二叉树每个节点的流向是两种，所以需要递归两次。每个节点都应该遍历左子树、右子树并且打印当前节点的数据域，顺序不同只不过导致了三个语句的次序。

递归是不需要栈来实现回溯的，返回自然就回到上一层了。

### 后序遍历代码(非递归)

```c
#include<stdlib.h>
#include<stdio.h>
#include<string.h>
//创建二叉树节点
typedef struct BiTNode {//这里还肩负着声明结构体类型和结构体指针类型，所以要加上typdef
    int data;
    BiTNode* lchild, * rchild;
}BiTNode, * BiTree;

typedef struct SNode {
    BiTree ptr;
    int num;
}SNode;
//创建二叉树
void CreateBiTree(BiTree* T)
{
    //根节点
    (*T) = (BiTree)malloc(sizeof(BiTNode));
    (*T)->data = 1;
    (*T)->lchild = (BiTree)malloc(sizeof(BiTNode));
    (*T)->rchild = (BiTree)malloc(sizeof(BiTNode));
    //节点1的左子树
    (*T)->lchild->data = 2;
    (*T)->lchild->lchild = (BiTree)malloc(sizeof(BiTNode));
    (*T)->lchild->rchild = (BiTree)malloc(sizeof(BiTNode));
    //节点1的右子树
    (*T)->rchild->data = 3;
    (*T)->rchild->lchild = (BiTree)malloc(sizeof(BiTNode));
    (*T)->rchild->rchild = (BiTree)malloc(sizeof(BiTNode));
    //节点2的左子树
    (*T)->lchild->lchild->data = 4;
    (*T)->lchild->lchild->lchild = NULL;
    (*T)->lchild->lchild->rchild = NULL;
    //节点2的右子树
    (*T)->lchild->rchild->data = 5;
    (*T)->lchild->rchild->lchild = NULL;
    (*T)->lchild->rchild->rchild = NULL;
    //节点3的左子树
    (*T)->rchild->lchild->data = 6;
    (*T)->rchild->lchild->lchild = NULL;
    (*T)->rchild->lchild->rchild = NULL;
    //节点3的右子树
    (*T)->rchild->rchild->data = 7;
    (*T)->rchild->rchild->lchild = NULL;
    (*T)->rchild->rchild->rchild = NULL;
}

SNode a[20];//这并不是指针数组了，而是结构体数组
int top = -1;
//创建入栈函数，这里的入栈函数与先序中序不太一样，这里栈的类型并不是二叉树节点类型，而是包含指向二叉树节点的指针以及标志的自定义节点
void Push(SNode* a, SNode p)//传入结构体数组，并且要对这个数组操作。此时形参应该是一重指针，传入数组名。之前是二重指针，传入指针数组名
{
    a[++top] = p;
}
//创建出栈函数
void Pop(void)
{
    if (top == -1)
    {
        return;//每次都忘记top还有可能为-1
    }
    top--;
}
SNode GetTop(SNode* a)//这里的形参不一定是指针，因为有返回值，需要传入地址这样返回值就是地址的内容，地址是传入的不会被释放，如果形参是数组的话，传入数组就是值传递，返回值是地址为局部变量的相同值的数组。返回值是值传递结束就会被释放。传入指针其实有被操作的风险。如果这里传入的是SNode类型的变量，而不是指针，实际上我们就是传入数组元素，直接返回a，那这个函数没啥意义了。这里[]相当于一次解引用。借用结构体中的指针把地址当成值传递。
{
    return a[top];
}
//创建打印函数
void PrintBit(BiTree p)
{
    printf("%d", p->data);
}

//创建后续遍历非递归算法
//先序遍历是循环嵌套循环，大循环出栈，小循环中打印当前节点，如果有右子树入栈，指向左子树。中序遍历同样是循环嵌套循环，大循环直接进入小循环，小循环中将能找到的左子树入栈，大循环中出栈打印节点，并将此时的右子树入栈，直到栈空了并且指针为空时跳出。先序遍历中节点左子树右子树分的很清楚。中序遍历中只有左子树和右子树的概念。当前节点被当成左子树。
//后序遍历因为需要将左子树遍历完、右子树遍历完之后才能打印当前节点。需要设置标志位。
//这种方式类似于中序遍历，只不过是需要判断下出栈的元素是否遍历了右子树，如果没有遍历需要继续遍历右子树并压栈，如果此时左子树右子树都遍历了最后才打印节点。
void PreOrderTraverse(BiTree T)
{
    BiTree p = T;//传入了根节点
    //接下来应该为这个根节点创建自定义结构体，标志赋值。
    SNode s;//创建临时变量存储压栈元素
    //还要创建临时变量存储指向节点的指针p的标志
    int tag;
    while (p || top != -1)//同样是遍历整个二叉树并且指针为NULL时退出
    {
        while (p) {//当指针为NULL时此时左子树遍历完毕
            //先为当前节点创建结构体，然后压栈
            s.ptr = p;
            s.num = 0;//标志位为0表示此节点的左子树已经被遍历了
            Push(a, s);//传入的结构体包含指针，而结构体是存入数组中，不影响。
            p = p->lchild;//因为是先压栈然后遍历，所以最终压栈的元素并不是NULL
        }
        //先得到当前指针的结构体，看看标志情况
        s = GetTop(a);//获取栈顶元素，结构体
        Pop();
        //将结构体中的成员值取出来
        p = s.ptr;
        tag = s.num;
        if (tag == 0)//如果这些节点只进行了左子树遍历，接下来进行右子树遍历，修改完标志之后还要重新压栈。其实这些指向节点的指针位置并没有发生变化。因为每次出栈修改完标志就入栈了。
        {
            s.ptr = p;//节点是不会变的，我们只是修改下标志，然后去遍历他的右子树
            s.num = 1;//修改标志位
            Push(a, s);//重新压栈，索引top不变。
            p = p->rchild;//进行该节点的右子树遍历。
        }
        else {
            //此时p所指向的节点是左右子树都已经遍历完了。
            PrintBit(p);
            p = NULL;//因为p节点的左右子树都已经遍历完成，防止再次进入小循环中遍历其左子树
        }
    }
}

int main(void)
{
    BiTree p;
    CreateBiTree(&p);
    PreOrderTraverse(p);
}
```

先序遍历非递归的思路是大小循环，大循环中出栈，小循环中先打印当前节点数据域，然后判断是否有右子树有就压栈，让指针指向左子树，下一次小循环中打印左子树，等到小循环跳出了再把右子树出栈。

中序遍历非递归的思路是大小循环，大循环跳出条件是栈空了并且指针也空了。说明遍历了能遍历的并且所有都遍历了。直接进入小循环，只要指针非空就循环下去，小循环中先压栈，然后找他的左子树。小循环就是把所有的左子树都压栈直到找不到，跳出小循环，此时p为空，栈顶元素非空，出栈，打印，找他的右子树，下一次小循环就是找右子树的左子树了。因为左根右顺序，需要先把左子树打印出来。

后序遍历非递归的思路和中序遍历很像，左右根，需要左右子树遍历完才能打印根节点，需要自定义结构体保存节点指针和标志位，大小循环和中序遍历非递归条件一样，大循环之后直接接小循环，小循环中对自定义结构体赋值然后压栈，后序遍历中栈存储的是自定义结构体。同样是先找他的左子树。跳出小循环之后出栈，判断下当前节点标志位，如果没有遍历右子树需要进入if遍历右子树，这里和小循环中一样，因为出栈完就压栈了所以存入的自定义结构体中的指针依旧是出栈的指针，修改的是标志。如果进入else说明此时左右子树都遍历了，下一步就是打印，然后把p设置为null，这是不希望再遍历p的左子树了。这个节点结束了。这里不需要担心所谓的浅拷贝。地址作为值传递，不会出现指针称为另一个指针的别名的。就是通过指针传递值。拷贝构造函数才是导致浅拷贝。

先序中序后序三者的大小循环判定条件相同，都是p为空，栈也空退出大循环，p为空退出小循环。

二叉树递归很简单，非递归就是回溯会用到栈。非递归只能用学过的，自己想太难了。

## 层次遍历

### 层次遍历规则

按照二叉树中的层次从左到右一次遍历每层中的节点。通过使用队列的数据结构，从树的根节点开始，依次将其左孩子和右孩子入队。每次队列中一个节点出队，都将其左孩子和右孩子入队 。直到树中所有节点都出队。出队节点的先后顺序就是层次遍历的最终结果。这个好理解，每次出队的节点就把其左右子树入队，左侧先出队，左侧的左右子树同样在该层中先出队。

### 层次遍历举例

<img src="C:\Users\MACHENIKE\AppData\Roaming\Typora\typora-user-images\1676167346118.png" alt="1676167346118" style="zoom:33%;" />

1234567

1. 根节点1入队
2. 根节点1出队，23入队
3. 2出队，45入队，
4. 3出队，67入队，
5. 不断循环，直到队列内部为空。

需要注意的是队列要设置两个索引都是从0开始就i++，-1开始就++i，这没啥可说的，但是队列先入先出的特点就在于从队头开始存入，自然就从对头开始出队。

```c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#define TElemType int//宏定义，所有的二叉树都是进行了这个定义，直接int不好么，，
//创建二叉树节点，这是第一个要定义的，节点类型后边都会用到
typedef struct BiTNode {//结构体成员是从上往下一次存储的，地址是从低到高
    TElemType data;
    BiTNode* lchild, * rchild;
}BiTNode, * BiTree;
//创建队列
BiTree a[20] = { 0 };//对于指针数组可以这么初始化，但是结构体数组就不可以了。
TElemType rear = 0;//这里是0那么用到索引就是i++
TElemType front = 0;
//创建二叉树
void CreateBiTree(BiTree* T)//因为要把创建的二叉树带出来，需要指针的地址
{
    //创建根节点
    (*T) = (BiTree)malloc(sizeof(BiTNode));
    (*T)->data = 1;
    (*T)->lchild = (BiTree)malloc(sizeof(BiTNode));
    (*T)->rchild = (BiTree)malloc(sizeof(BiTNode));
    //创建节点1的左子树
    (*T)->lchild->data = 2;
    (*T)->lchild->lchild = (BiTree)malloc(sizeof(BiTNode));
    (*T)->lchild->rchild = (BiTree)malloc(sizeof(BiTNode));
    //创建节点1的右子树
    (*T)->rchild->data = 3;
    (*T)->rchild->lchild = (BiTree)malloc(sizeof(BiTNode));
    (*T)->rchild->rchild = (BiTree)malloc(sizeof(BiTNode));
    //创建节点2的左子树
    (*T)->lchild->lchild->data = 4;
    (*T)->lchild->lchild->lchild = NULL;
    (*T)->lchild->lchild->rchild = NULL;
    //创建节点2的右子树
    (*T)->lchild->rchild->data = 5;
    (*T)->lchild->rchild->lchild = NULL;
    (*T)->lchild->rchild->rchild = NULL;
    //创建节点3的左子树
    (*T)->rchild->lchild->data = 6;
    (*T)->rchild->lchild->lchild = NULL;
    (*T)->rchild->lchild->rchild = NULL;
    //创建节点3的右子树
    (*T)->rchild->rchild->data = 7;
    (*T)->rchild->rchild->lchild = NULL;
    (*T)->rchild->rchild->rchild = NULL;
}
//创建获取队头元素函数
BiTree GetTop(BiTree* a)
{
    return a[front];
}
//创建打印队头函数
void PrintBiTree(BiTree* a)
{
    printf("%d", a[front]->data);
}
//创建入队函数
void Enterqueue(BiTree* a, BiTree p)
{
    a[rear++] = p;
}
//创建出队函数
void Exitqueue(void)
{
    if (front == rear)
    {
        return;
    }
    front++;
}
//创建层次非递归函数
void level(BiTree Tree)
{
    BiTree p = Tree;
    //根节点入队
    Enterqueue(a, p);
    while (rear > front)//当队列为空结束循环
    {
        p = GetTop(a);
        //将根节点出队
        PrintBiTree(a);
        Exitqueue();
        if (p->lchild != NULL)
        {
            Enterqueue(a, p->lchild);
        }
        if (p->rchild != NULL)
        {
            Enterqueue(a, p->rchild);
        }
    }
}
int main(void)
{
    BiTree p;
    CreateBiTree(&p);
    level(p);
}
```

这里的队头和队尾都是**不断增加的**，队头应该小于队尾，等于的时候说明此时队列空了。这是用非递归实现的，让根节点入队出队打印，然后左子树存在就入队，右子树存在就入队，进入下一次循环，**每次循环入队三个，出队一个**，直到左右子树不存在就只有出队，然后队列为空就结束。

## 求二叉树的深度

### 题目描述

输入一颗二叉树的根节点，求树的深度。从根节点到叶子节点依次经过的节点形成树的一条路径，最长路径的长度为树的深度。
之前先序中序后序是不关注树的平衡性的，即使最长路径和最短路径相差很多也不影响算法。层次遍历也不影响。
### 解题思路
这个树的深度感觉可以通过循环来实现，每次遍历左右子树，只要p不为空就加1，直到p为空。

考虑以下几种情况：

- 如果二叉树为空，深度为0；
- 如果二叉树只有根节点，深度为1；
- 只有左子树，深度为左子树深度+1；
- 只有右子树，深度为右子树深度+1；
- 左右子树都有，深度为左右子树最大深度+1；

这是采用递归的思路实现的，其实就是对每个节点遍历他们的左右子树，对于叶子节点左右子树为空，触发刹车条件，返回0每一次递归让返回值+1，返回到节点的时候把左右子树的返回值比较下，实际上就是比较左右子树谁的递归层次高。返回值需要判断下大小问题。

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
//创建二叉树节点
typedef struct BiTNode{
    int data;
    BiTNode *lchild,*rchild;
}BiTNode ,*BiTree;
//创建二叉树
void CreateBiTree(BiTree *T)
{
    //创建根节点
    (*T) = (BiTree)malloc(sizeof(BiTNode));//这就是malloc的特点了，返回的指针需要强转，malloc是函数需要加上()，new对于变量直接new a就可以。对于类型需要加括号
    (*T)->data = 1;
    (*T)->lchild = (BiTree)malloc(sizeof(BiTNode));
    (*T)->rchild = (BiTree)malloc(sizeof(BiTNode));
    //创建根节点的左子树
    (*T)->lchild->data = 2;
    (*T)->lchild->lchild = NULL;
    (*T)->lchild->rchild = NULL;
    //创建根节点的右子树
    (*T)->rchild->data = 3;
    (*T)->rchild->lchild = (BiTree)malloc(sizeof(BiTNode));
    (*T)->rchild->rchild = (BiTree)malloc(sizeof(BiTNode));
    //创建节点3的左子树
    (*T)->rchild->lchild->data = 4;
    (*T)->rchild->lchild->lchild = NULL;
    (*T)->rchild->lchild->rchild = NULL;
    //创建节点3的右子树
    (*T)->rchild->rchild->data = 5;
    (*T)->rchild->rchild->lchild = NULL;
    (*T)->rchild->rchild->rchild = NULL;
}

int maxdepth(BiTree p)
{
    //先添加刹车条件
    if(p == NULL)
    {
        return 0;
    }
    int lchilddepth = maxdepth(p->lchild);
    int rchilddepth = maxdepth(p->rchild);
    return lchilddepth > rchilddepth ? lchilddepth+1 : rchilddepth+1;
}
int main(void)
{
    BiTree p;
    CreateBiTree(&p);
    printf("%d", maxdepth(p));
}
```

这里忘记打印了，并且a>b ? a:b这个公式让我忘了。

---

回忆下链表

反转链表：设置两个指针，递归做法是先递归到尾结点，然后让指向尾结点的指针指向前一个节点。

链表有环求入环点：快慢指针速度差一半，同时从头节点出发，直到相遇，此时快指针走了两倍于慢指针的路程，头节点到入环点为a，环的周长是r，走了N圈，相遇点距离入环点为b。a+Nr+b = 2 *(a+b)，a = Nr-b，此时只要让快指针回到原点，并速度变成慢指针一样，慢指针不动。此时二者再次移动会在入环点相遇。

单链表求交点：两条链表相交，让两个指针分别从两个头节点出发，相同的速度，只有一个尾结点，当走完自己的路之后再走一遍对方的路。路程是相等的，速度是相等的，必然会相遇并走完剩下的路，从交点处开始相遇。

两个有序链表的合并：打擂台，谁输了加入链表，赢的人和后边的人继续打。

----

## 如何判断二叉树是否相等

### 题目描述

给两个二叉树的根节点p和q，编写一个函数检验这两颗树是否相同。如果两个树在结构上相同，并且节点具有相同的值，认为他们是相同的。

### 解题思路

如果只是单纯的使用某种顺序遍历二叉树应该不行。

采用先序遍历方法遍历二叉树，并把遍历的节点值保存在数组中，并且每个节点的空子树叶存储下来。

本身先序遍历就要用到栈，还要保存到数组中，就是把printf函数换成入队函数，空子树也要存储下来就要修改函数顺序或者判定条件修改。

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
typedef struct BiTNode {
    int data;
    BiTNode* lchild, * rchild;
}BiTNode, * BiTree;
void CreateBiTree(BiTree* T)
{
    //创建节点1
    (*T) = (BiTree)malloc(sizeof(BiTNode));
    (*T)->data = 1;
    (*T)->lchild = (BiTree)malloc(sizeof(BiTNode));
    (*T)->rchild = (BiTree)malloc(sizeof(BiTNode));
    //创建节点2
    (*T)->lchild->data = 2;
    (*T)->lchild->lchild = (BiTree)malloc(sizeof(BiTNode));
    (*T)->lchild->rchild = (BiTree)malloc(sizeof(BiTNode));
    //创建节点3
    (*T)->rchild->data = 3;
    (*T)->rchild->lchild = (BiTree)malloc(sizeof(BiTNode));
    (*T)->rchild->rchild = (BiTree)malloc(sizeof(BiTNode));
    //创建节点4
    (*T)->lchild->lchild->data = 4;
    (*T)->lchild->lchild->lchild = NULL;
    (*T)->lchild->lchild->rchild = NULL;
    //创建节点5
    (*T)->lchild->rchild->data = 5;
    (*T)->lchild->rchild->lchild = NULL;
    (*T)->lchild->rchild->rchild = NULL;
    //创建节点6
    (*T)->rchild->lchild->data = 6;
    (*T)->rchild->lchild->lchild = NULL;
    (*T)->rchild->lchild->rchild = NULL;
    //创建节点7
    (*T)->rchild->rchild->data = 7;
    (*T)->rchild->rchild->lchild = NULL;
    (*T)->rchild->rchild->rchild = NULL;
}


//创建栈
BiTree a[200] = { 0 };
int top = -1;
//创建入栈函数
void Push(BiTree* a, BiTree p)
{
    a[++top] = p;
}
//创建栈顶元素
BiTree GetTop(BiTree* a)
{
    return a[top];
}
//创建出战函数
void Pop(void)
{
    if (top == -1)
    {
        return;
    }
    top--;
}
//创建队列
int b[200] = { 0 };
int rear = -1;
int front = 0;
//创建入队函数
void Enterqueue(int* b, BiTree p)
{
    if(p == NULL)
    {
        b[++rear] = 0;
        return ;
    }
    b[++rear] = p->data;
}
//创建出队函数
void Exitqueue()
{
    if (front == rear)
    {
        return;
    }
    front++;
}
//采用先序遍历方法遍历二叉树并把遍历的节点存储在数组中
void PreBiTree(BiTree tree, BiTree* a)
{
    BiTree p = tree;
    Push(a, p);
    while (p || top != -1)
    {
        p = GetTop(a);
        Pop();
        while (p)
        {
            Enterqueue(b, p);
            if (p->rchild)
            {
                Push(a, p->rchild);
            }
            p = p->lchild;
            if (p == NULL)
            {
                Enterqueue(b, p);
            }
        }
    }
}
int main(void)
{
    BiTree p;
    CreateBiTree(&p);
    PreBiTree(p, a);
    while (front != rear + 1)
    {
        printf("%d", b[front++]);
    }
}
```

之前打印不出数，问题在于p，入队的时候传入了0，然后0->data这一步出问题了，使用if额外判定这种情况即可。这种方式下，因为当左子树为空的时候就不会去遍历其右子树了，所以叶子节点之后只跟随一个0，12405036070，事实证明这里先序遍历+队列自己写也可以实现检测二叉树结构。

---

下面介绍下指南中的方法，是使用先序遍历递归实现的。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef struct BiTNode {
    int data;
    BiTNode* lchild,*rchild;
}BiTNode, * BiTree;
void CreateBiTree(BiTree* T)
{
    //创建根节点
    (*T) = (BiTree)malloc(sizeof(BiTNode));
    (*T)->data = 1;
    (*T)->lchild = (BiTree)malloc(sizeof(BiTNode));
    (*T)->rchild = (BiTree)malloc(sizeof(BiTNode));
    //创建根节点的左子树
    (*T)->lchild->data = 2;
    (*T)->lchild->lchild = (BiTree)malloc(sizeof(BiTNode));
    (*T)->lchild->rchild = (BiTree)malloc(sizeof(BiTNode));
    //创建根节点的右子树
    (*T)->rchild->data = 3;
    (*T)->rchild->lchild = (BiTree)malloc(sizeof(BiTNode));
    (*T)->rchild->rchild = (BiTree)malloc(sizeof(BiTNode));
    //创建节点2的左子树
    (*T)->lchild->lchild->data = 4;
    (*T)->lchild->lchild->lchild = NULL;
    (*T)->lchild->lchild->rchild = NULL;
    //创建节点2的右子树
    (*T)->lchild->rchild->data = 5;
    (*T)->lchild->rchild->lchild = NULL;
    (*T)->lchild->rchild->rchild = NULL;
    //创建节点3的左子树
    (*T)->rchild->lchild->data = 6;
    (*T)->rchild->lchild->lchild = NULL;
    (*T)->rchild->lchild->rchild = NULL;
    //创建节点3的右子树
    (*T)->rchild->rchild->data = 7;
    (*T)->rchild->rchild->lchild = NULL;
    (*T)->rchild->rchild->rchild = NULL;
}
//使用递归算法不需要回溯，不需要栈，但是这里要实现一个数组，用来存储二叉树的元素。局部变量的数组即可。
void Preorder(BiTree tree, int* arr, int* i)//传入二叉树节点、数组，用到递归，索引需要从外部获取
{
    (*i)++;//每次递归i都会加一
    //创建刹车条件
    if (tree == NULL)
    {
        //递归开始返回，并且将当前叶子结点的子树以0的方式入队
        *(arr + *i) = 0;//之前分析过，数组的索引就是距离当前地址的偏移，可以是负数，这里arr是数组名，一维数组名所以是首元素的地址，如果偏移会变成第二个元素的地址，解引用就是取值
        return;
    }
   
    *(arr + *i) = tree->data;//将当前节点入队就是打印节点
    Preorder(tree->lchild, arr, i);
    Preorder(tree->rchild, arr, i);
}
//创建比较函数，之前自己写的就没有创建比较函数
int compare(BiTree a, BiTree b)
{
    //防止浪费时间，先判断下两个根节点是否为空
    if (a == NULL || b == NULL)
    {
        printf("二叉树为空");
        return 0;
    }
    //创建数组arr1和arr2
    int arr1[100];
    int arr2[100];
    memset(arr1, 0, 100 * sizeof(int));
    memset(arr2, 0, 100 * sizeof(int));
    int i = 0;//这里要注意，不可以使用int i,j=0;这种方式，求&i,&j的时候会出错，此时只是对j赋予了初值，i是随机数。应该是int i=0,j=0;
    int j = 0;
    Preorder(a, arr1, &i);
    Preorder(b, arr2, &j);
    if (i != j)
    {
        printf("二叉树大小对不上");
        return 0;
    }
    //比较数组
    for (int a = 0;a < i;a++)//这里如果能获得索引值可以让索引值作为循环次数
    {
        if (arr1[a] != arr2[a])
        {
            printf("数组索引%d不匹配", a);
            return 0;
        }
    }
    printf("两个二叉树相同");
    return 0;
}
int main(void)
{
    BiTree t1;
    CreateBiTree(&t1);
    compare(t1, t1);
    return 0;
}
```

这是采用先序遍历递归算法，和非递归的区别在于，非递归遍历到第一个叶子节点的左子树就会退出了，然后出栈获得别的节点。而递归是会把叶子结点的左子树和右子树都遍历到，最后会得到两个0，而非递归只有一个0，有一个要注意的地方，不要定义全局数组，而是定义局部数组，传入函数中，这样一个函数就可以对多个数组操作。定义全局数组往往还有定义全局索引。这里就是把打印变成了存入数组中，根据循环次数作为索引。然后比较数组大小以及数组中每个元素的大小。如果是叶子节点的子树为NULL就设置为0

对于二叉树的操作使用递归是一种简便算法，学习中可以写非递归来熟悉结构，面试中应以递归为主。

## 如何判断二叉树是否是平衡二叉树

### 题目描述

输入一颗二叉树的根节点，判断该树是不是平衡二叉树。如果二叉树中任意节点的左右子树的深度相差不超过1，他就是一颗平衡二叉树。

### 解题思路

初步想法是求二叉树的深度，之前求得是所有路径中的最大深度。现在变成求每个节点的左右子树深度，递归中每次判断下左右子树传回来的两个int值相差是否超过1，如果每个节点的左右子树深度相差都不超过1，那他就是一个平衡二叉树。每次返回之前判断下是否超过1，然后再返回最大深度。只有返回最大深度才有比较的意义

```c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
typedef struct BiTNode {
    int data;
    BiTNode* lchild, * rchild;
}BiTNode, * BiTree;
int flag = 0;
void CreateBiTree(BiTree* T)
{
    //创建根节点
    (*T) = (BiTree)malloc(sizeof(BiTNode));//这就是malloc的特点了，返回的指针需要强转，malloc是函数需要加上()，new对于变量直接new a就可以。对于类型需要加括号
    (*T)->data = 1;
    (*T)->lchild = NULL;
    (*T)->rchild = (BiTree)malloc(sizeof(BiTNode));
    
    //创建根节点的右子树
    (*T)->rchild->data = 3;
    (*T)->rchild->lchild = (BiTree)malloc(sizeof(BiTNode));
    (*T)->rchild->rchild = (BiTree)malloc(sizeof(BiTNode));
    //创建节点3的左子树
    (*T)->rchild->lchild->data = 4;
    (*T)->rchild->lchild->lchild = NULL;
    (*T)->rchild->lchild->rchild = NULL;
    //创建节点3的右子树
    (*T)->rchild->rchild->data = 5;
    (*T)->rchild->rchild->lchild = NULL;
    (*T)->rchild->rchild->rchild = NULL;
}
//创建判断二叉树左右子树深度的函数
int IsBalance(BiTree tree)
{
    if (tree == NULL)
    {
        return 0;
    }
    int a = IsBalance(tree->lchild);
    int b = IsBalance(tree->rchild);
    if (abs(a - b) > 1)
    {
        flag = -1;
    }
    return a > b ? a + 1 : b + 1;

}
int main(void)
{
    BiTree tree;
    CreateBiTree(&tree);
    int c = IsBalance(tree);
    printf("最大深度为%d", c);
    printf("结果为%d", flag);
}
```

这是我自己写的程序，结果创建的二叉树有问题，以前写的没有问题，递归的时候还是要每个节点都判断下其左右子树，不能只判断根节点的，设置全局变量，这样即使递归次数再多也跟我们没关系了，只看全局变量数值。平衡二叉树定义：节点的左右子树深度差不超过1，并且其左右子树也是平衡二叉树。用到了abs函数。

指南的方法是创建求最大深度的函数，然后创建判断是否平衡的函数，在后一个函数中调用前一个函数并递归，感觉有点麻烦了。最大深度需要递归，平衡判断也需要递归。

# 数组

## 最大子序和

### 题目描述

给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。所谓的最大和，指的就是在数组nums中的某一段连续的元素和是比其他段要大。

### 解题思路

数组的题上来就这么难吗，

#### 方法一

直接循环两次，小循环中从首元素开始，挨个相加，每次加完都和最大值比较下，不断的替换，最后小循环中能得到一个从首元素开始相加，连续子数组的最大和。大循环就是从第二个元素开始，和最大值比。

```c
int maxSubArray(int *nums,int numsSize){
    int max = nums[0];
    int tmp = 0;
    for(int i=0;i<numsSize;i++)
    {
        int tmp = 0;//每次循环重置tmp
        for(int j=i;j<numsSize;j++)
        {
            tmp +=nums[j];
            if(tmp>max)
            {
                max = tmp;
            }
        }
    }
    return max;
}
```

因为是连续地址，数组的头尾不相连的。

第二种方法用到了递归，将数组分成三份，先求左边数组最大和，再求右边数组的最大和。每次递归都会吧左右数组的范围缩小，直到最后左右两边的数组元素个数为零或者一返回。对于这个求中间的部分，没有看懂，直接放弃。分治法是比较高端的解法了。

循环嵌套循环的解法最先想到，但是在leetcode上会给出测试用例元素超多导致超时。这道题没做完

## 原地移除元素

### 题目描述

给你一个数组nums和一个值val，需要原地溢出所有数值等于val的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用O(1)额外空间并原地修改输入数组。元素的顺序可以改变，不需要考虑数组中超出新长度后面的元素。

### 解题思路

一边遍历数组，对每个数组元素进行比对，如果与val相同就删除之后需要让后续元素前进一位。循环结束后获得修改后的数组大小，sizeof 数组名就可以。数组名代表的是整个数组大小，对数组名解引用得到的是首元素内容。&a + 1此时是偏移整个数组，所以a的内容就是整个数组。

---

指南中的思路是复写数组，设置快慢指针，快指针去寻找不等于val的元素，这是需要保留的元素赋值给慢指针，慢指针是只有复写之后才会移动。当快指针遍历完整个数组后，将此时慢指针所指向的内容及以后的内容清空。

```c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int a[10] = { 0,1,2,1,-2,1,4,1,1,1 };
void  removeElement(int* nums, int numsSize, int val)
{
    int* slow = nums;
    int* fast = nums;
    int t = 0;
    for(int i = 0;i<numsSize;i++)
    {
        if (*fast == val)
        {
            //进行复写
            *slow = *fast;
            fast++;
            slow++;
            t++;
        }
        else {
            fast++;
        }
    }
    //后续元素不需要管
    for (int j = 0;j<t;j++)
    {
        printf("%d", nums[j]);
    }
}
int main(void)
{
    removeElement(a, sizeof(a) / sizeof(int), 1);
    return 0;
}
```

当指针遍历完整个数组后继续向后+1的时候，此时指针并不指向空，指针本身的地址仅仅是上一个地址+1这里是指针加法，指针的内容是0。和链表二叉树不同，那里我们自定义了尾结点和叶子结点里的指针指向NULL，但是数组这里并没有指向NULL，内容是0，这是未初始化的存储单元的默认值。所以循环要使用for而不是while
指南上和我写的差不多，他是把nums数组名当成慢指针了，也没有问题。

## 合并两个有序数组

### 题目描述

给两个有序整数数组nums1和nums2，请将nums2合并到nums1中，使得nums1称为一个有序数组。

### 解题思路

这和合并两个有序链表一样，打擂台，谁小下去变成数组的第一个元素。

---

方法一：分别遍历两个数组nums1和nums2，申请nums3的空间存放二者排序的结果。

方法二：不用申请额外空间，从后向前遍历两个数组，统一合并到nums1中。这里为什么要从后向前遍历呢。

### 代码实现

#### 方法一

```c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int a[10] = { 0,1,1,1,2 };
int b[5] = { 1,2,3,4,5 };
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n)
{
    //传入数组指针，数组大小，元素个数
    //创建第三个数组nums3到时候赋值给nums1
    int* nums3 = (int*)malloc(sizeof(nums1) + sizeof(nums2));
    //开始轮询，直到一个数组全部轮询完
    int i = 0, j = 0, k = 0;
    while (i != m && j != n)//先把小数组轮询完
    {
        if (nums1[i] < nums2[j])
        {
            nums3[k] = nums1[i];
            k++;
            i++;
        }
        else {
            nums3[k] = nums2[j];
            k++;
            j++;
        }
    }
    //此时轮询完一个数组了，但是哪个数组不知道
    if (j == n)//此时轮询完了n,还需要轮询m剩余部分
    {
        for (int t = k;t < m + n;t++)
        {
            nums3[t] = nums1[i];
            i++;
        }
    }
    else
    {
        for (int t = k;t < m + n;t++)
        {
            nums3[t] = nums2[j];
            j++;
        }
    }
    for (int z = 0;z < m + n;z++)
    {
        nums1[z] = nums3[z];
    }
   
}
int main(void)
{
    merge(a,sizeof(a),5,b,sizeof(b),5);
    for (int i = 0;i < 10;i++)
    {
        printf("%d", a[i]);
    }

    return 0;
}
```

遇到的问题就是while判定条件，把&&写成||，这个错误犯太多次了，并且自己设的数组不是顺序数组。

#### 方法二

这种方法之前没理解，将nums2与nums1数组的内容插入到nums1数组的后边。如果从前往后排序的话因为会覆盖nums1的数组，所以需要申请额外的空间存放结果，而从后往前排序就不会覆盖元素了。因为这里默认的是数组nums1的空间 非常大，其自身的元素并没有完全占满空间 ，并且此时是把nums1和nums2两个数组的元素填充到nums1中，所以并不会从数组1最后元素开始填充，而是在m+n-1索引处填充，等待覆盖数组1元素的时候该元素已经被填充后边了。

```c
void merge2(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n)
{
    //先获得两个数组最后元素的索引
    int M = m - 1;
    int N = n - 1;
    //在获得填充的索引
    int MN = m + n - 1;

    //进入循环开始比较并插入
    while (M != -1 && N != -1)
    {
        if (nums1[M] > nums2[N])
        {
            nums1[MN] = nums1[M];//将较大值插入队列中
            M--;
            MN--;
        }
        else {
            nums1[MN] = nums2[N];
            N--;
            MN--;
        }
    }
    if (N == 0)
    {
        //当数组2的元素遍历结束后，此时数组1中剩余的元素本身就存在于数组1队头中，此时不需要执行了
        //正常来说即使元素数量相同的两个数组，最后也是
        return;
    }else if (M == 0)
    {
        //数组1遍历结束，将数组2的元素插入到数组1中
        for (int i = N;i >= 0;i--)
        {
            nums1[MN] = nums2[i];
            MN--;
        }
        return;
    }

}
int main(void)
{
    merge2(a,sizeof(a),5,b,sizeof(b),5);
    for (int i = 0;i < 10;i++)
    {
        printf("%d", a[i]);
    }

    return 0;
}
```

出问题了，需要从队头遍历的时候判定条件是i!=m||j!=n，这是没问题的，因为索引本身就比元素个数小1，所以当等于m-1的时候是可以继续遍历的。

这里的问题是从后到前，索引应该包括0，所以条件是m!=-1||n!=-1。不然的话会导致第一个元素没有遍历。

## 查找常用字符

### 题目描述

给定仅有小写字母组成的字符串数组A，返回列表中的每个字符串中都显示的全部字符组成的列表。A里面包括多个字符串，将每个字符串都包含的字符挑出来，存放到新的数组中，重复几次就挑几个出来。

### 解题思路

用一个二维数组存储每个单词出现的a-z的个数，然后按照列遍历找到每个字符在所有单词中出现的最小个数，该个数就是结果中需要添加的个数。

---

二维数组对应的是数组指针

指针数组对应的是二重指针。

```c
int a[3][3] = {1,2,3,4,5} == {{1,2,3},{4,5,0},{0,0,0}};//优先把行存满了才会到下一行。
int(*p)[3] = a;//数组指针p指向的类型是有三个元素的数组地址。这里的a如果作为地址赋值给指针，表示的是一行的地址。&a作为指针表示整个数组的地址，如果是一维数组应该是int(*p)[3] = &b;
p;//第一行地址
*p;//表示第一行第一列地址
**p;//表示元素内容
p[0] == *(p);
*p[1] == *(*(p+1));//因为p是行地址，此时偏移1就是偏移整个行此时p+1表示第二行地址，所以*p[1]表示第二行首元素内容。
//要注意的是数组指针声明时的[3]表示指向数组的元素个数是3
//p[3]表示的是*(p+3)。
//数组指针int *p[3]后边的[3]就是表明所指向的数组维度而已。
```

这里并没有用到数组指针，字符串数组被当成二维数组了。创建100行、每行26列的二维数组。

字符串数组本身既是二维数组也是指针数组，一般的指针数组里面的成员是一个指针，如果使用A[i] [j]这样搞的话相当于* (* (A+i)+j)所以，这对于指针数组没有意义，确实需要两次解引用，但是并不需要j偏移。字符串数组既可以解引用两次，也可以偏移两次。

创建一个二维数组，每个单词占一行，100行，26列，每个元素表示单词中的26字母出现的次数。

之后进行两次循环，比较每一列中的最小值，如果最小值为0表示并不是所有单词都重合，如果最小值大于0表示都重合，根据次数填充到数组中，最后返回数组。

```c
//创建打印重合字符函数
char** commonChars(const char** A, int ASize, int* returnSize) {//返回值是二重指针，返回一个指针数组
    if (A == NULL || ASize == 0)//如果传入的指针数组是空的，或者单词数量是零，直接退出
    {
        (*returnSize) = 0;
        return NULL;
    }
    //创建一个二维数组，用来记录每个单词的重合字符个数
    int res[100][26] = { 0 };//一百个单词，共有26个字母
    char** rslt = (char**)malloc(sizeof(char*) * 100);//这里是分配内存大小为100个字符指针的大小，32位机的指针是4字节，那就是400字节的空间。
    //此时二重指针指向的空间创建完毕，每个元素都是指向字符类型的指针，还需要给这些指针进行初始化
    for (int i = 0;i < 100;i++)
    {
        rslt[i] = (char*)malloc(sizeof(char) * 2);//对每个元素进行初始化，分配两字节大小的空间
    }
    //刚才初始化了一个二重指针，接下来把res二维数组进行填充，根据给定的数组，把重合字符的数量填充到res数组中。
    for (int i = 0;i < ASize; i++)//对每个单词遍历
    {
        for (int j = 0;j < strlen(A[i]); j++)//遍历每个单词的字符
        {
            //将结果存入res二维数组中，这里的列表示26字母，需要知道当前单词字符对应于列数
            res[i][A[i][j] - 'a']++;//这里是自动进行ASCII码转换，因为字符串数组的特殊性，虽然认为是指针数组，但依旧可以使用两个中括号找到具体的字符，而因为字符在ASCII码上排序是连续的，所以减去a字符就依次对应26列了。最后自加表示此字母存在。
        }
    }
    int idx = 0;
    //此时获得了一个二维数组res，知道每个字母出现次数，接下来就是比较下每一列中最小值
    for (int i = 0;i < 26;i++)
    {
        int min = res[0][i];//这是比较每列中的每行
        for (int j = 1;j < ASize; j++)
        {
            if (res[j][i] < min)
            {
                min = res[j][i];//先比较出这列的最小值
            }
        }
        while (min > 0)//只要有一个等于零的，这列就不需要看了。
        {
            *(*(rslt + idx) + 0) = i + 'a';//右值是把字符从ASCII码还原成字符，左值是*(rslt+idx)这是表示指向字符类型的指针，当时是每个指针分配了两字符的空间，之后的0表示偏移，最外层的解引用*表示内容。
            *(*(rslt + idx) + 1) = '\0';//第二个字符就是终止符
            idx++;
            min--;//每写一次字符就自减
        }
    }
    //此时已经遍历了所有的列，并把每个都重复的字符都存入rslt中。
    (*returnSize) = idx;//最后有多少个字符数量存入变量中
    return rslt;
}
```

总结下，就是创建了两个数组，一个是二维数组用来对比所有单词中26个字母出现的次数，一个是指针数组，用来存放重合的字母。

## 寻找数组的中心索引

### 题目描述

给定一个整数类型的数组nums，请编写一个能够返回数组中心索引的方法。所谓的数组中心索引指的是：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。如果数组不存在中心索引，返回-1，如果有多个中心索引，返回最靠近左侧的那一个。

### 解题思路

方法一：S是数组的和，当索引i是中心索引时，位于i左边数组元素的和leftsum满足S-nums[i]-leftsum。只需要判断当前索引i是否满足即可。

方法二：滑动窗口，先设定一个初始位置0，已其为中心分别计算左、右的和，然后比较不相等就右移，更新左、右和即可。

### 代码实现

#### 方法一

其实就是整两个循环，第一个循环是遍历整个数组求出sum，第二个循环是判断下左值是否等于sum-当前索引-左值。

```c
int pivotIndex(int *nums,int numsSize)
{
    //先判断下数组元素个数
    if(numsSize<3)
    {
        return -1;
    }
    int sum = 0,right = 0,left = 0;
    for(int i = 0;i <numsSize ;i++)
    {
        sum+=nums[i];//计算数组和
    }
    for(int i = 0;i < numsSize;i++)
    {
        //此循环中依次比较是否相等
        left += nums[i];
        if(left == (sum - nums[i] - left))
        {
            return i;
        }
    }
    return -1;
}
```

两个循环，先得到数组总和，在第二个循环中不断的给left增加，给right减少，然后在此循环中判断两者是否相等，相等的话，此时的索引就是中心索引。

方法二就不学了。

## 数组中数字出现的次数

### 题目描述

一个整型数组nums里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

### 解题思路

我不理解时间复杂度和空间复杂度是什么意思，

---

异或运算^的特点

- 零和任何数异或等于该数。
- 任何数和自身异或等于0。
- 异或运算满足交换律。
- 异或就是不进位的加法。

将数组中成对的数放在前面先运算，成对的数会变成0，达到消去成对的数的目的。

此时数组中剩下两个不同的数异或，得到的结果mask是这两个数不同位上值为1，相同的为0。

以mask的最低的值为1的位(设为a0位)来区分这两个数，其中一个数a0位等于1，另一个等于0。

接下来通过x &(-x)得到a0=1，其他位等于0的结果。

同样将数组中其他的数，也分成两组：a0=0组和a0=1组，这样保证了两个不同的数分在两组，也保证了成对的数必定在其中一组，而不会一对数分在两组。

最后对两组的数进行异或运算，最后得到的两个数即所求。

### 代码实现

```c
int singleNumbers(int *nums,int numsSize,int *returnSize)
{//传入的数组有要求，成对放前面，单独的放后面。并且单独的只有两个。
    int mask = 0;
    for(int i = 0; i < numsSize ; i++)
    {
        mask ^=nums[i];//循环结束后最后的两个不同的元素体现在mask上
    }
    mask = mask &(-1 * mask);//这一步是将mask的a0=1，其他位置零
    int m1 = 0,m2 = 0;
    for(int i = 0;i < numsSize; i++)
    {
        if((nums[i] & mask) == 0)//判断数组所有元素的a0位，因为单独的元素是放在最后面，将不同的数赋值给两个变量，最后得到的就是两个单独的元素对应在m1和m2上了。
        {
            m1 ^= nums[i];
        }else
        {
            m2 ^=nums[i];
        }
    }
    *returnSize =2;
    int *a = (int *)malloc(2*sizeof(int));
    a[0] = m1;
    a[1] = m2;
    return a;
}
```

这个代码有点傻，只适用于只有两个数字出现一次，并且还要把这两个元素放在数组的最后，唯一有用的就是对于异或的运用了。相同为0，不同为1

## 数组中数字出现的次数II

### 题目描述

在一个数组nums中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。

### 解题思路

理论基础：某一数字出现3次，则他们**每一位**的和分别可以被三整除。

1. 分别给数组中所有数字不同位分别求和，结果记录为temp，int型要分别求32次。
2. 如果第i位的求和结果temp能被3整除，说明只出现了1次的那个数字该位为0，否则为1。
3. 根据第二步结果，给result的第i位置1或0。

没看懂，直接跳过

## 数组中缺失的元素

### 题目描述

给定一个包含0/1/2...n中n个数的序列，找出没有出现在序列中的那个数。

### 解题思路

方法一：哈希数组

这里的想法应该是创建哈希数组，散列表是没有排序功能的，但是可以根据键值对直接找到索引，从小到大依次寻找，找不到的就是没有的那个数字。

方法二：异或

之前使用异或是因为多个成对出现的，找出唯一数字，利用自身异或为0找到唯一数字，这里怎么找呢。创建一个0-n范围的n+1元素的数组，循环遍历，只要有为零的就说明存在，不为零的说明不存在。

方法三：求和

数列和与0-n的数列和进行相减，差就是缺的那个数字。

### 代码实现

#### 方法一

这里将序列作为键值也就是索引数组，相应索引加一，然后找元素为0的。

```c
int missingNumber(int* nums,int numsSize)
{
    int hash[50000] = {0};
    for(int i = 0;i < numsSize; i++)
    {
        hash[nums[i]] = 1;//这里就是用nums数组作为索引
    }
    for(int i = 0 ;i <numsSize; i++)
    {
        if(hash[i] == 0)
        {
            return i;
        }
    }
    return -1;
}
```

#### 方法二

利用异或中与自身异或运算为0的特点，创建一个无缺的序列，然后循环中对有缺序列的每个元素进行轮询，轮询一遍后只要出现0就说明不缺少这个元素。

但是指南中提出的方式没看懂

```c
int missingNumber(int *nums,int numsSize)
{
    int res = numsSize;
    for(int i = 0; i <numsSize; i++)
    {
        res^=nums[i];
        res^=i;
    }
    return res;
}
```

这个程序始终看不懂。

方法三太简单了，不写了。

## 按奇偶排序数组

### 题目描述

给定一个非负整数数组A，返回一个数组，在该数组中，A的所有偶数元素之后跟着所有奇数元素。可以返回满足此条件的任何数组作为答案。

### 解题思路

定义额外数组和两个头尾下标，遍历原数组，将偶数从前往后放，奇数从后往前放。

其实很简单，就是判断能否被2整除。

### 代码实现

```c
int* sortArrayByParity(int* A, int ASize)
{
    int* B = (int*)malloc(sizeof(int) * ASize);
    int head = 0;
    int tail = ASize - 1;
   for(int i=0;i<ASize;i++)
    {
        if (A[i] % 2 == 0)
        {
            B[head++] = A[i];
        }
        else {
            B[tail--] = A[i];
        }
    
    }
   
    return B;
}
```

while的循环条件没有for鲜明。关于头尾索引为了方便使用单独的变量表示，不要用i表示每一个变量。

## 数组是否存在重复元素

### 题目描述

给定一个整数数组和一个整数k，判断数组中是否存在两个不同的索引i和j，使得nums[i] = nums[j]，并且i和j的差的绝对值最多为k。

### 解题思路

我的想法就是循环嵌套循环，找到不同索引下相同数值然后判断索引差是否大于k。这种方法提交的时候显示超时，LeetCode上是排序然后比较相邻值，或者哈希表。

指南中的方法是创建一个结构体，成员包含数组的值和索引。

```c
typedef struct node_t{
    int value;
    int index;
}node;//数组的值和索引用来填充到结构体中，其实和映射有点像，这里是键值对
int cmp(void *a,void *b)//创建一个比较函数，结构体数组需要有顺序才可以
{
    if((((node *)a)->value) > (((node *)b)->value))
        return -1;
    else if((((node *)a)->value) == (((node *)b)->value))
        return 0;
    else return 1;
}
//创建结构体数组并判断相同值的索引绝对值差与k的关系
bool containsNearbyDuplicate(int *nums,int numsSize,int k)
{
    node array[10000] = {0};
    //初始化结构体，然后进行排序，再将每个值相同的元素拿出来比较下索引差
    for(int i = 0;i <numsSize ;i++)
    {
        array[i].value = nums[i];
        array[i].index = i;
    }
    qsort(array,numsSize,sizeof(node),(_CoreCrtNonSecureSearchSortCompareFunction)cmp);
    for(int i = 0;i <numsSize;i++)
    {
        for(int j= 1+j;j<numsSize;j++)
        {//依次判断下是否相等，如果值相等的话就判断下索引
            if(array[i].value == array[j].value)
            {
                if((array[j].index - array[i].index)<=k)
                    return true;//这里没考虑到绝对值问题，如果不进行排序的话，就不需要考虑绝对值问题了。
            }else{
                break;//只有排序情况下才添加break，因为排序之后身边的项不等于自身的话，就没有等于的了，不添加排序函数的话，去掉break
            }
        }
    }
    return false;
}
```

指南中的qsort无法运行，cmp的返回值不符合，需要强转成_CoreCrtNonSecureSearchSortCompareFunction类型。这里的qsort必须有，不然那代码结果不正确。

总结：这种方式就是采用了结构体数组，其实直接循环遍历原数组也可以。

### leetcode

这里就是单纯的采用排序，比较相邻元素的方法。

```c
int cmp(void *a,void *b)
{
    return *(int *)a-*(int*)b;
    
}

bool containsDuplicate(int* nums, int numsSize){
qsort(nums,numsSize,sizeof(int),cmp);
for(int i = 0;i < numsSize-1;i++)
{
    if(nums[i] == nums[i+1])
        return true;
}
return false;
}
```

只需要遍历一次即可。如果不考虑排序qsort函数的话。qosrt传入数组地址、数组大小、比较元素大小、比较函数其中函数返回值为两者相减即可

## 有序数组出现次数超过25%的元素

### 题目描述

提供一个非递减的有序整数数组，已知这个数组中恰好有一个整数，他的出现次数超过数组元素总数的25%，找出并返回这个整数。

### 解题思路

方法一：将每个元素放进哈希表，遍历哈希表求次数相等的元素。

方法二：数组有序，且某元素出现次数超过25%，那么对于此元素第一次出现位置，加25%数组长度，必定仍然为其自身。

将元素的值作为索引，对数组元素+1，然后比较数组中每个元素的值。

### 代码实现

#### 方法一

```c
int findSpecialInteger(int *arr,int arrSize){
    if(arrSize < 1)return -1;
    int flag[100000] = {0};//创建一个数组
    for(int i = 0;i <arrSize ;i++)
    {
        flag[arr[i]]++;//将arr数组中的值作为索引自加
    }
    //此时flag数组中凡是不非零就说明存在
    int cnt = arrSize * 0.25;
    for(int i = 0;i <100000; i++)
    {
        if(cnt < flag[i])//判断下是否有元素出现次数大于25%
            return i;
    }
    return -1;
}
```

#### 方法二

```c
int findSpecialInteger(int *arr,int arrSize){
    for(int *p = arr,*q = arr+arrSize/4;;p++,q++)
    {
        if(*p == *q)return *p;//这里有点像滑动窗口，只要有满足自身往后数组/4长度仍然等于自己的就是了。
    }
    return 0;
}
```

## 有效的山脉数组

### 题目描述

给定一个整数数组A，如果他是有效的山脉数组就返回true，否则返回false。

所谓的山脉数组指的就是有上升坡度，有下降坡度的数组。但不能有平缓的坡度。

### 解题思路

方法一：先编写函数找出数组中最大的数的下标，这个下标之前的数应该是**严格递增**的，这个下标之后的数应该是**严格递减**的。

方法二：上山步数和下山步数相加等于总长度-1。

### 代码实现

#### 方法一

先找出最大值的索引，如果是山脉数组的话应该是先严格递增，后严格递减，所以接下来要创建判断山脉数组函数 ，函数内部先判断是否是严格递增，然后判断是否是严格递减。如果都满足返回1表示是山脉数组，如果不是就返回0。

```c
int max(int* A, int ASize)
{
    int index = 0, max = A[0];//接下来在循环中找出最大值赋值给max
    for (int i = 0;i < ASize; i++)
    {
        if (max < A[i])
        {
            max = A[i];
            index = i;
        }

    }
    return index;//返回最大值的下标
}
bool validMountainArray(int* A, int ASize)
{
    if (ASize < 3)//数组长度小于3为假，因为小于3无法构成山脉数组
    {
        return 0;//表示非山脉数组
    }
    int res = max(A, ASize);//传入
    if (res == 0 || res == ASize - 1)//最大值在首元素或者尾元素上
    {
        return 0;
    }
    //判断是否严格递增
    for (int i = 0;i < res;i++)
    {
        if (A[i] > A[i + 1])
        {
            return 0;
        }
    }
    for (int j = res; j < ASize-1;j++)
    {
        if (A[j] < A[j+1])
        {
            return 0;
        }
    }
    return 1;
}
```

总结：就是利用了山脉数组的特性，先增后减。

#### 方法二

这方法是利用上山步数和下山步数相加等于ASize-1，当处于上山的时候要确保下山步数为0，处于下山的时候确保上山步数大于0

```c
bool validMountainArray(int *A,int ASize)
{
    if(ASize < 3)
    {
        return false;
    }
    int inc = 0;
    int dec = 0;
    for(int i = 0; i < ASize-1; i++)
    {
        if(A[i] < A[i+1] && dec = 0)//处于上山并且下山步数为0
        {
            inc++;//上山步数+1
        }else if(A[i+1] > A[i] && inc>0)
        {
            dec++;
        }
    }
    //遍历整个数组后，判断下上山和下山步数是否为ASize-1，因为循环中并没有考虑一直上升，一直下降，平东等情况
    if((inc +dec == ASize -1)&&(inc >0 && inc < ASize-1)&&(dec >0&& dec<ASize-1))
    {
        return true;
    }
    return false;
}
```

总结：这种方法其实不需要最后if判断条件那么多，只需要循环中return即可。

## 最长连续递增序列

### 题目描述

给定一个未经排序的整数数组，找到最长且连续的递增序列，并返回该序列的长度。

### 解题思路

方法一：先判断长度是否小于2，然后整一个循环判断上一项是否小于后一项，如果是计数+1，不是计数重置，第一次把计数保存给max，每次判断是否大于max，最后把max返回。

方法二：滑动窗口

### 代码实现

```c
int findLengthOfLCIS(int *nums,int numsSize){
    if(numsSize == 0)//这里必须区分，因为涉及到连续数组的长度
        return 0;
    if(numsSize == 1)
        return 1;
    int length = 1;//此时长度至少是1了
    int max = 1;
    for(int i = 0;i <numsSize - 1;i++)
    {//循环中判断下每一段连续增长数组的长度
        if(nums[i] < nums[i+1])
            length++;
        else
            length = 1;//重置
        if(max < length)
            max = length;
    }
    return max;
}
```

这些没啥可说的，需要注意的就是连续增长数组长度0和1需要区分下。

方法二不写了。所谓的滑动窗口之前遇到过，这个没看懂

数组学完了，感觉这部分的题有点绕，重点不是遍历，插入删除，而是玩一些花样。

# 字符串

## 有效的括号：

### 题目描述

给定一个只包括'('、')'、'{'、')'、'['、']'的字符串，判断字符串是否有效。

有效字符串：

- 左括号必须用相同类型的右括号闭合。
- 左括号必须以正确的顺序闭合。
- 注意空字符串可被认为是有效字符串。

### 解题思路

这是一道很简单的题目，用栈可以很轻松的实现，当左括号出现的时候入栈，当右括号出现的时候出栈，如果匹配就继续，不匹配就错误当字符串遍历完成以后，栈内仍有字符串就错误，用一个数组进行和一个记录栈顶值的int进行了栈的模拟。这里用到了栈，二叉树的非递归方式中的中序和后序就是需要回溯用到了栈。

### 代码实现

```c
char s[] = {"({[]})"};
bool isValid(char* s) {
    int len = strlen(s);//字符串长度
    char stack[100] = "";//存入栈中
    int top = -1;//栈索引    
    //创建一个循环，不断提取字符串字符
    for (int i = 0; i < len; i++)
    {
        if (s[i] == '(' || s[i] == '{' || s[i] == '[')
        {
            //左括号就存入栈中
            stack[++top] = s[i];
        }
        else {
            if (top == -1)//如果没有左括号入栈的话
            {
                return false;
            }
            if (s[i] == ')')
            {
                if (stack[top] != '(')
                    return false;
                else
                    top--;
            }
            if (s[i] == '}')
            {
                if (stack[top] != '{')
                    return false;
                else
                    top--;
            }
            if (s[i] == ']')
            {
                if (stack[top] != '[')//这里整反了
                    return false;
                else
                    top--;
            }
        }
    }
    if (top == -1)
        return true;
    
        return false;
}
```

## 字符串数字相加

### 题目描述

给定两个字符串形式的非负整数num1和num2，计算他们的和。

### 解题思路

### 代码实现

```c
char res[5103] = {'\0'};//创建一个空的字符串数组
char *addStrings(char *num1,char *num2){
    short s1 = strlen(num1),s2 = strlen(num2),len = 5101,carry = 0;//获得两个字符串的长度
    for(s1--,s2--;s1>=0 || s2>=0 ||carry;)//s1和s2长度-1作为初始值，直到s1和s2遍历完并且carry也为0
    {
        //长度为0时，数值取0
        carry += (s1 >= 0?num1[s1--] - 48:0) + (s2>=0?num2[s2--] - 48:0);//如果s1大于等于0为真的话，取当前值-48（这里的意思是把字符变成数字，48表示的是ASCII码中的0），然后s1自减否则取0结果加上s2的。这一行就是把两个字符串相加成int类型的变量。
        res[len--] = carry %10 + 48;//这里取余又是什么意思，+48是变成字符类型，
        carry /=10;//carry = carry / 10
    }
    return &res[len+1];
}
```

这个代码就没看懂。

## 二进制求和

### 题目描述

给你两个二进制字符串，返回他们的和（用二进制表示）。输入为非空字符串且只包含数字1和0。

### 解题思路

这种不管是十进制的加减还是二进制的加减本质都是一样的。

### 代码实现

代码上就是把%10变成了%2，把/10变成了/2

这两道题始终没弄明白。直接过。

## 反转字符串

### 题目描述

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组char[]的形式给出。不要给另外的数组分配额外的空间，原地修改输入数组、使用O(1)的额外空间解决这一问题。假设数组中的所有字符都是ASCII码表中的可打印字符。

### 解题思路

常规题目，定义两个变量，同时从开头和结尾遍历，交换字符即可。

之前移除特定元素的时候采用快慢指针遍历数组，快指针寻找不被移除的元素，慢指针停留在需要移除的元素上，将快指针指向的元素给慢指针。

这里就是采用一个缓冲区存放需要交换的数组。

### 代码实现

```c
void swap(char *s,int start,int end)
{
    //实现两个数组元素的交换，被覆盖量保存到缓冲区防止被覆盖
    while(start < end)//这里不相等还不可以，偶数字符数量的话，无法相等。
    {
        char temp = s[start];
        s[start] = s[end];
        s[end] = temp;
        start++;
        end--;
    }
}
void reverseString(char* s,int sSize)
{
    int start = 0;
    int end = sSize-1;
    swap(s,start,end);
}
```

没啥可说的。

## 反转字符串中的单词

### 题目描述

给定一个字符串，需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

### 解题思路

毫无疑问，空格是个关键，只是反转空格隔开的每个单词中字符的顺序。

只需要找到字符串中每个单词的开始位置和结束位置，然后交换这两个位置的字符同时开始位置右移动结束位置左移动即可。

实际上就是反转函数不变，输入的start和end有说法了，是每个单词的开始位置和结束位置，不再是整体的位置了。

### 代码实现

```c
void swap(char *s,int start,int end)
{
    while(start < end)
    {
        char temp = s[start];
        s[start] = s[end];
        s[end] = temp;
        start++;
        end++;
    }
}
char *reverseWords(char *s)
{
    int i = 0;
    int start = 0;
    int end = 0;
    int len = strlen(s);
    while(s[end++] != '\0')
    {
        if(s[end]==' '||s[end]== '\0')//当遇到这两个条件时，说明已经包含一个单词了，可以进行反转
        {
            swap(s,start,end-1);//不包括空格和结束符
            start = end+1;//跳过空格，从新的单词开始继续遍历
        }
    }
    return s;
}
```

特点就是找到每个单词的首尾。

## 反转字符串中的元音字母

### 题目描述

编写一个函数，以字符串作为输入，反转该字符串中的元音字母。

### 解题思路

反转字符串差不多的方法，在反转前判断下是否是元音字母。需要在增加一个函数用来判断是否是元音字母。并且此时反转的是若干个不连续的字母，反转函数不加循环，分别从数组的头和尾开始查询。

### 代码实现

```c
void swap(char *str,int start,int end)
{
	char temp = s[start];
    s[start] = s[end];
    s[end] = temp;
}//此函数就是单纯的反转start和end
int vomel(char c)
{
    if(c == 'a' || c == 'e' || c == 'i' || c== 'o' || c == 'u' || c=='A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')
        return 1;
    else 
        return 0;
}
void reverseVowels(char *s){
    int i = 0;
    int j = strlen(s)-1;//分别定义两个头尾的索引
    while(i < j)
    {
        while(i < j && !vomel(s[i]))
            i++;//直到i所在的元素是元音退出
        while(i < j && !vomel(s[j]))
            j--;
        swap(s,i,j);
        i++;
        j--; 
    }
        return ;
}
```

特点是与前两种不同，这是对离散的单个元素进行反转。

## 验证回文串

### 题目描述

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。空格也可以忽略。

### 解题思路

回文串判断，首尾比较，忽略大小写，可以先都转换成小写

只考虑数字和字母，可以使用isalpha,isdigit，数字字母返回非零，不是返回0，来过滤

考虑空指针或空串的场景。

### 代码实现

实际上就是从头和尾开始遍历数组，首先是判断是否是非数字和非字母，然后判断数字和字母情况下两个元素是否相等，不相等直接返回，相等就移位。代码明天实现吧。

aba这种属于回文串，根据p<q的条件，两个指针会同时遍历到

```c
bool isPalindrome(char* s) {
    int len = strlen(s);
    //判断下传入的字符串
    if (len == 0)
        return true;
    if (len == 1)
        return true;
    //定义头指针和尾指针
    char* p = s;
    char* q = s + len - 1;
    while (p < q)//从头尾遍历整个字符串数组
    {
        while ((!(isalpha(*p)) && !(isdigit(*p))) && (p < q))//跳过非字符和非数字的元素，这里的两个函数对于非字符和非数字返回0，既不是字符也不是数字的情况下，还没有遍历完数组
        {
        p++;
        }
        while ((!(isalpha(*q)) && !(isdigit(*q))) && (p < q)){
        q++;
        }
        //此时数组长度超过2，并且p和q所指向的元素只有字符和数组两种形式
        if (tolower(*p) != tolower(*q))
            return false;
        p++;
        q++;
    }
    return true;
}
```

## 验证回文字符串II

### 题目描述

给定一个非空字符串s，最多删除一个字符。判断是否能称为回文字符串。

### 解题思路

检查到前后不一致的字符，必须删除一个且只能删除一个，删除之后检查剩下的字符串是否为回文。

以abdda为例，此时两个指针指向b和d，只要保证(i+1,j)或(i,j-1)则整个字符串就是回文串。其实就是在不考虑其中一个元素的情况下，判断下剩余未被遍历的元素是否能组成回文串。

### 代码实现

```c
char s[] = { "adbba" };
//需要创建两个函数，一个是判断局部是否回文，一个是调用该函数的函数
bool isPalindrome(char* start, char* end)
{
    while (start <= end)//这里的小于等于其实和小于没区别，无非就是中间的元素是否判断，判断了也没用，0/1个元素都是回文
    {
        if (*start != *end) {//判断下局部的字符串是否属于回文
            return false;
        }
        start++;
        end--;
    }
    return true;
}
bool validPalindrome(char* s)
{
    int len = strlen(s);
    char* start = s;
    char* end = s + len - 1;
    while (start <= end)
    {
        //进入遍历字符串
        if (*start != *end)
        {
            //进入选择，分别删除两个指针的元素，判断剩余元素是否为回文
            if (isPalindrome(start + 1, end))
            {
                return true;
            }
            if (isPalindrome(start, end - 1))
            {
                return true;
            }
            return false;
        }
        start++;
        end--;
    }
    return true;
}
```

## 根据字符串出现频率进行排序

### 题目描述

给定一个字符串，请将字符串里的字符按照出现的频率降序排列。

### 解题思路

字符范围为0-128，利用数组去构建哈希表：

1. 首先对字符串进行变量，取得每个字符出现的次数保存在数组count中
2. 循环遍历count数组，每次找出最大值所对应的索引，将其值赋为0，然后将索引所对应的字符赋值到字符串s中。

### 代码实现

所谓的哈希表就是将字符作为索引找到对应的数组count元素，然后加1，已经是很常见的操作。 先来一个循环初始化哈希表，给每个字符出现的次数标记好，然后整个大循环，嵌套一个小循环，小循环中找到最频繁的字符，大循环中将每次找到的最频繁的字符写入数组，然后将该字符对应哈希表中的标记取消。

代码明天写

```c
char* frequencySort(char* s) {
    //创建哈希表
    int flag[128] = { 0 };   
    int len = strlen(s);
    if (len <= 2)
    {
        return s;
    }
    for (int i = 0; i < len; i++)
    {
        printf("%d",s[i]);
        flag[s[i]]++;
        printf("f = %d\r\n", flag[s[i]]);
    }
    //此时哈希表初始化完成，接下来遍历哈希表找到当前最大值，然后将对应的当前最大值装入数组中，继续循环，直到所有都循环结束  
    int i = 0;
    int k = 0;
    while (i < len)
    {
        int max = 0;
        int index = 0;        
        for ( k = 0; k < 128; k++)
        {
            if (max < flag[k])
            {
                max = flag[k];//重复次数
                index = k;//索引号
            }
        }
        if(max!=0)
        {
            flag[index] = 0;
        }
        //找到当前最大值max之后根据索引号将元素导入num数组中
        for (k = 0;k < max;k++)
        {
            s[i++] = index;
        }
    }
    return s;
}
```

这道题其实不难，尝试过自己写，结果稀碎，好多细节需要注意，先弄一个循环把每个元素出现的次数记录，然后弄一个大循环嵌套小循环，第一个嵌套小循环用来找到记录的最大值及其索引，第二个嵌套小循环用来把索引传入数组中。

## 字符串中的单词

### 题目描述

统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。请注意，你可以假定字符串里不包括任何不可打印的字符。

### 解题思路

好简单，遍历字符串，查找非数字和非字符的元素个数+1就是单词个数了。

指南中说的是统计前一个为空格且自身不是空格的数量即可。但是标点符号没有考虑到。

### 代码实现

```c
int countSegments(char* s)
{
    //先判断下字符串是否为空
    if (s[0] == '\0')
        return 0;
    //判断下字符串中的单词个数，要求是前一个为空格或逗号，而当前值不是空格
    int len = strlen(s);
    int cnt = 0;
    for (int i = 0;i < len;i++)
    {
        if ((i == 0 || s[i - 1] == ' ' || s[i - 1] == ',') && s[i] != ' ')
        {
            cnt++;
        }
    }
    return cnt;
}
```

判断条件是首元素以外的前一个元素为空格或者逗号，当前元素不为空格。

## 前k个高频单词

### 题目描述

给一非空的单词列表，返回前k个出现次数最多的单词。返回的答案应该按单词出现频率由高到低排序，如果不同的单词有相同的出现频率，按字母顺序排序。

本题并不是给一个字符串，而是给一个字符串数组。

### 解题思路

qsort的结构体的排序，注意字典序是如何排序的。代码明天写。

### 代码实现

```c
const char* words[] = { "is","i","a","a","d","d","d" };
typedef struct node {
    char word[20];
    int num;
}NODE;
int cmp1(const NODE* a, const NODE* b) {
    return (b->num - a->num);//用来记录word出现的次数
}
int cmp2(const NODE* a, const NODE* b) {
    return strcmp(a->word, b->word);//这是对比下ASCII码大小
}
char** topkFrequent(const char** words, int wordsSize, int k, int* returnSize) {
    NODE* node = (NODE*)malloc(sizeof(NODE) * wordsSize);//申请一个结构体大小的内存
    char** ret = (char **)malloc( sizeof(char*) * wordsSize);
    int node_len = 0;
    for (int i= 0;i < wordsSize; i++) {
        bool flag = false;
        for (int j = 0;j < node_len; j++)
        {
            if (strcmp(words[i], node[j].word) == 0)//words是字符串数组，比较下是否存在，如果存在记录自加。
            {
                node[j].num++;
                flag = true;
                break;
            }
        }
        if (!flag)//如果前面没有出现过，就新增一个节点
        {
            strcpy_s(node[node_len].word, words[i]);
            node[node_len].num = 1;
            node_len++;//每次增加一个节点，整体循环多一次
        }
    }
    qsort(node, node_len, sizeof(NODE),(_CoreCrtNonSecureSearchSortCompareFunction)cmp2);//排序字符串
    qsort(node, node_len, sizeof(NODE),(_CoreCrtNonSecureSearchSortCompareFunction)cmp1);//排序出现次数
    for (int i = 0;i < k;i++)
    {
        ret[i] = node[i].word;//ret是一个字符串数组，所以是二重指针，指向的数组的元素都是字符串指针元素。而char * = "xx"字符串指针指向一段字符串是可以的。
    }
    *returnSize = k;
    return ret;
}
```

这道题时间跨度很大，所以我也是花费了挺久的时间理解的。就是寻找整个字符串数组中出现的前k个高频词。采用了结构体数组管理。两个成员分别是单词和出现次数。整一个循环嵌套循环用于初始化一个结构体数组，将给定的字符串数组变成结构体数组。然后对这个结构体数组进行排序，需要根据出现次数和单词的ASCII码大小进行排序。所以要排两次。要注意当初在初始化结构体数组的时候就把重复的元素转换成出现次数了。所以数组中都是唯一的元素。

## 检测大写字母

### 题目描述

给定一个单词，你需要判断单词的大写使用是否正确。

我们定义，在以下情况时，单词的大写用法是正确的。

全部字母都是大写，比如USA。单词中都不是大写。如果单词不只含有一个字母，只有首字母大写，否则定义这个单词没有正确使用大写字母。

### 解题思路

其实这种题很好做的，就是遍历这个字符串，让每一个字符减去z的ASCII码，如果大于零就是大写的字符，还要设置非数字和非符号。

检测大写字母的个数

当字符串全为大写字母或者没有一个大写字母，返回true

当字符串第一个为大写并且后面的不为大写字母时，返回true

其余情况返回false。

```c
bool detectCapitalUse(const char* word) {
    //先获得字符串的长度
    int len = strlen(word);
    int cnt = 0;
    //判断下每一个字符是否是大写
    for (int i = 0;i < len; i++)
    {
        if ((word[i] < 'Z') && (word[i] > 'A'))
        {
            cnt++;//用来记录大写字母数量
        }
    }
    if ((cnt == len-1) || (cnt == 0))//这里要注意cnt是需要等于len-1的
        return true;
    else if ((word[0] < 'Z') && (word[0] > 'A') && (cnt == 1))//只有首元素是大写字母
        return true;
    else
        return false;
}
```

没啥可说的。采用了阈值的方式实现的大写字母辨认。

## 最长的公共前缀

### 题目描述

编写一个函数来查找字符串数组中的最长公共前缀。所有的输入只包含小写字母。

### 解题思路

其实这种题很熟悉了，其实就是循环读取字符，然后判断当前字符是否是公共，如果是就保存然后读取下一个字符，如果不是就退出。

以第一个字符串为基准进行竖向扫描，将每个字符串的前col个字符进行一次比较。

### 代码实现

```c
char * longestCommonPrefix(char **strs,int strsSize)
{
    if(0 == strsSize)return "";
    char *s0 = strs[0];
    for(int col = 0;s0[col]!='\0';col++)//此循环中判断基准
    {
        for(int row = 1;row < strsSize;row++)
        {
            if(s0[col] != strs[row][col])
            {
                s0[col] = '\0';//提前结束
                return s0;
            }
        }
    }
    return s0;
}
```

如果需要遍历字符串的话，结束符\0作为遍历结束的标志。循环嵌套循环，大循环遍历列，小循环遍历行。如果小循环遍历发现不相等的字符，设置结束符然后退出。否则自然退出。运行的时候我发现无法对指针进行操作，LeetCode上跑不明白。

## 最长特殊序列I

### 题目描述

给你两个字符串，请你从这两个字符串中找出最长的特殊序列。最长特殊序列定义如下：该序列为某些字符串独有的最长子序列。不能是其他字符串的子序列。子序列可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。输入为两个字符串，输出最长特殊序列的长度，如果不存在则返回-1

### 解题思路

其实和上一道题反着来的，上一道是求最大公共序列，这里就是求最大不公共序列。

- 如果两个字符串长度不一致，则较长的字符串本身不可能是短字符串的子序列直接返回其长度即可
- 如果两个字符串内容相等，那么他们独有的最长子序列不存在，返回-1

### 代码实现

```c
int findLUSlength(char *a,char *b)
{
    int lenA = strlen(a);
    int lenB = strlen(b);
    if(strcmp(a,b) == 0)//对比下两个字符串，如果相等返回0
        return -1;
    return lenA>lenB?lenA:lenB;
}
```

## 最长特殊序列II

### 题目描述

给定字符串列表 ，需要找出最长的特殊序列。最长特殊序列定义如下：该序列为某字符串独有的最长子序列。子序列可以通过**删去字符串中的某些字符**实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为自身的子序列。

输入是一个字符串列表，输出是最长特殊序列的长度。如果最长特殊序列不存在，返回-1。

1. 将整个字符串数组按照长度降序排序
2. 统计各个字符串出现的次数
3. 寻找可以作为整个字符串数组的最长序列

### 代码实现

这道题没有读懂。跳过吧

## 计数二进制子串

### 题目描述

给定一个字符串s，计算具有相同数量0和1的非空连续子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的，重复出现的子串要计算他们出现的次数。

### 解题思路

假设最简单的情况000111，先遍历，前面的0的数量为curr = 3，遍历到1时，pre = curr赋值为3，然后curr = 1表示现在1的个数，只要curr<=pre，比如curr= 1，那么可以组成01,；curr = 2，可以组成0011，直到出现下一次0，然后那么prev就是1的个数，curr表示0001110。

这道题从题目描述到解题思路我都没有读懂

### 代码实现

```c
int countBinarySubstrings(char *s)
{
    int n = 0,pre = 0,curr = 1,len = strlen(s)-1;
    for(int i = 0;i < len; i++)
    {
        if(s[i] == s[i+1])
            curr++;//如果当前数字等于下一个数字curr自加
        else{
            pre = curr;//如果此时不相同
            curr = 1;
        }
        if(pre >=curr)n++;//如果此时0的数量大于1就让增加n的数量
    }
    return n;//返回的是对应于0数量的1的数量。如果是000110那么就返回2，也就是0011
}
```

## 实现字符串的库函数

### strcpy

```c
void mycpy(char *s1,char *s2)//就是将s2拷贝到s1
{
    while(*s1++ = *s2++);
}
```

### strlen

```c
int mylen(char *s1)
{
    char *p = s1;
    while(*p++);//这里的++运算符优先级高于*，所以是*(p++)这里p本来指向首元素，不断的自加地址，直到超出字符串范围，此时p就是指向\0
    return p - s1 - 1;//p减去s1地址就是整个字符串长度+结束符，但是strlen不包括结束符长度，所以还需要-1减去一个字符就是结束符。
}
```

### strcat

```c
void mycat(char *s1,char *s2)
{
    while(*s1++);
    s1--;//去掉第一个字符串的结束符
    while(*s1++ = *s2++);//将两个字符串拼接起来
}
```

### atoi

```c
int myatoi(char *str)
{
    if(str == NULL)
    {
        printf("Invalid Input");;
        return -1;
    }
    while(*str == ' ')//去掉字符串开始的空格
    {
        str++;
    }
    int nSign =(*str == '-')?-1:1;//确定符号位
    if(*str == '+'||*str == '-')
    {
        str++;
    }
    int nResult = 0;
    while(*str>='0' && *str <= '9')//字符串中的数字部分
    {
        nResult = nResult * 10 + (*str - '0');
        str++;
    }
    while(*str == ' ')
    {
        str++;
    }
    if(*str != '\0')
    {
        printf("Invalid Input");
        return -1;
    }
    return nResult *nSign;
}
```

这个就是将字符串转化为int类型，之前的驱动模块中就有涉及到浮点数运算，就是把字符串发送给用户空间，进行浮点数运算。

### itoa

取整数输入值转换为相应进制数字的字符串。

### memmove

从str2复制n个字符到str1。

# 排序算法及其改进方法

## 快速排序

### 基本思想

我们从数组中选择一个元素，我们把这个元素称之为中轴元素，然后把数组中所有小于中轴元素的元素放在其左边，所有大于或等于中轴元素的元素放在其右边，显然，此时中轴元素所处的位置的是有序的。也就是说，我们无须再移动中轴元素的位置。

从中轴元素那里开始把大的数组切割成两个小的数组（两个数组都不包括中轴元素），接着通过递归的方式，让中轴元素左边的数组和右边的数组也重复同样的操作，直到数组的大小为1，此时每个元素都处于有序的位置。

具体步骤：

1. 从数列中挑出一个元素，称为基准(pivot)；
2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面(相同的数可以到任一边)。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区(partition)操作；
3. 递归地把小于基准值元素的子数列和大于基准值元素的子数列排序；

最好时间复杂度：O(NlogN)

最坏时间复杂度：O(N2)

最坏时间复杂度：O(NlgN)

空间复杂度：O(logN)

稳定排序：否

原地排序：是

### 代码实现

整一个while循环，在这个循环中同时从数组头和数组尾进行遍历，数组尾找到比基准小的元素，数组头找到比基准大的元素，然后两者进行交换位置，等到两边遍历到同一个位置的时候，说明此时整个数组遍历结束，该点左侧是小于基准，由此大于基准，然后将这两侧分为两个数组，重复上述操作，直到将数组分成不可再分的时候，此时对整个数组进行了排序。

```c
void Quick_Sort(int *arr,int begin,int end)
{
    if(begin > end)
    {
        return;//判断递归终止条件
    }
    int tmp = arr[begin];
    int i = begin;
    int j = end;
    while(i != j)
    {
        while( arr[j] >= tmp && j > i)//不满足条件就循环
            j--;
        while(arr[i] <= tmp && j>i)
            i++;
        if(j > i)
        {
            int t =arr[i];
            arr[i] = arr[j];
            arr[j] = t;//这里是朴实无华的交换元素
         }
    }
    arr[begin] = arr[i];
    arr[i] = tmp;
    Quick_Sort(arr,begin,i-1);//递归前半部分
    Quick_Sort(arr,i+1,end);//递归后半部分
}
```

### 改进方案

1. 选取随机数作为枢轴

   但是随机数的生成本身是一种代价，根本减少不了算法其余部分的平均运行时间。

2. 使用左端、右端和中心的中值作为枢轴元

   经验得知，选取左端、右端和中心元素的中值会减少快排约14%的比较。

3. 每次选取数据集中的中位数做枢轴

   选取中位数的可以在O(n)时间内完成。

   上面三种是通过选择不同的基准来获得优化

4. 快速排序在处理小规模的数据时表现不好，这个时候可以改用插入排序。

5. 对于一个每个元素都完全相同的一个序列来讲，快速排序也会退化到O(n^2)

   要将这种情况避免，可以这样做：

   在分区的时候，将序列分为3堆，一堆小于中轴元素，下次递归调用快速排序的时候，只需对小于和大于中轴元素的两堆数据进行排序，中间等于中轴元素的一堆已经放好。
   
   这种是额外考虑了等于基准元素的要求。

## 冒泡排序

### 基本思想

把第一个元素与第二个元素比较，如果第一个比第二个大，则交换他们的位置。接着继续比较第二个与第三个元素，如果第二个比第三个大，则交换他们的位置。（这不就是快速排序的思想么，区别在于不选择基准，就是相邻比较，快速排序理解为是冒泡的一种改良版）

对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，这步做完后，最后的元素会是最大的数。除去最右的元素，对剩余的元素做相同的工作，如此重复下去直到排序完成。（给人的感觉确实就像冒泡一样，不断的将更大值往右移，当移到最右侧的时候结束，然后开始从头将第二大的值右移）

### 具体步骤

1. 比较相邻的元素，如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾最后一对。这步做完后，最后的元素会是最大的值。
3. 针对所有的元素重复以上的步骤，除了最后一个
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一堆数字需要比较。

最好时间复杂度：O(N)

最坏时间复杂度：O(N2)

平均时间复杂度：O(N2)

空间复杂度：O(1)

稳定排序：是

原地排序：是

### 代码实现

每执行一个for，就会选出当前遍历的最大值放在右端。然后遍历除了最右侧元素之外的其他元素。

```c
void bubbleSort(int *arr,int n)
{
    int m,i,j;
	for(i = 0;i < n-1; i++)//找到n个最大值移到最右侧，此时排序完整个数组
    {
        for(j = 0; j < n-1-i; j++)//找出当前循环范围内的最大值，并移动到最右侧
        {
            if(arr[j] > arr[j + 1])
            {
                m = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = m;//如果左侧大于右侧就交换
            }
        }
    }
}
```

### 改进

1. 一般的冒泡排序方法有可能会在已经排好序的情况下继续比较，改进的冒泡排序，设置了一个哨兵flag，如果一次for循环没有进行交换，则元素已经排好序，由哨兵控制退出循环（一次for循环中一次交换都没有发生说明相邻元素小于左侧元素）
2. 有序区的长度和排序的轮数是相等的。比如第一轮排序过后的有序区长度是1，第二轮排序过后的有序区长度是2。实际上，数列真正的有序区可能会大于这个长度。比如例子中仅仅第二轮，后面5个元素实际都已经属于有序区。因此后面的许多次元素比较是没有意义的。如何避免这种情况呢？我们可以在每一轮排序的最后，记录下最后一次元素交换的位置，那个位置也就是无序数组的边界，再往后就是有序区了。下一次排序就从边界处排序了。

## 堆排序

### 基本思想

将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根节点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的n-1个序列重新构造 成一个堆，这样就会得到n个元素中的次大值。如此反复执行，便能得到一个有序序列。

### 具体步骤

1. 将待排序序列构造成一个二叉树
2. 然后子树与节点进行比较，将更大值与节点交换，直到子树与根节点进行比较交换。
3. 此时，整个序列的最大值就是堆顶的根节点。
4. 将其与叶子节点从右到左进行交换，此时最右侧叶子节点就为最大值。
5. 然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列。其实就是从最右侧的叶子结点放到序列的最右端。最后的根节点放到序列的最左端

可以看到在构建大顶堆过程中，元素的个数逐渐减小，最后就得到一个有序序列。

最好时间复杂度：O(NlogN)

最坏时间复杂度：O(NlogN)

平均时间复杂度：O(NlogN)

空间复杂度：O(1)

稳定排序：否

### 代码实现

这个堆排序首先是生成一个堆，然后比较每个子节点与其父节点，

```c
void heapify(Mytype tree[],int n,int i)
{
    if(i >= n)
    {
        return ;
    }
    int c1 = 2 *i+1;
    int c2 = 2 *i+2;
    int max = i;
    if(c1 < n && tree[c1] > tree[max])
    {
        max =c1;
    }
    if(c2 < n && tree[c2] > tree[max])
    {
        max = c2;
    }
    if(max != i)
    {
        swap(tree,max,i);
        heapify(tree,n,max);
    }
}
int build_heap(Mytype tree[],int n)
{
    int last_node = n-1;
    int parent = (last_node-1)/2;
    int i;
    for(i = parent;i >= 0; i--)
    {
        heapify(tree,n,i);
    }
}
int HeapSort(Mytype tree[],int n)
{
    build_heap(tree,n);
    int i;
    for(i = n-1;i >=0;i--)
    {
        swap(tree,i,0);
        heapify(tree,i,0);
    }
}
```

本身这个堆排序我是看懂了思路的，我认为这个完全没必要，就是瞎折腾。代码写的更是垃圾。不看了。

## 插入排序

### 基本思想

每一步将一个待排序的记录，插入到前面已经排好序的有序序列中去，直到插完所有元素为止。

### 具体步骤

1. 将待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描。
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置。
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置。
5. 将新元素插入到该位置后；
6. 重复步骤2~5.

最好时间复杂度：O(N)

最坏时间复杂度：O(N2)

平均时间复杂度：O(N2)

空间复杂度：O(1)

稳定排序：是

原地排序：是

### 代码实现

```c
void InsertSort(Mytype a[],int n)
{
    for(int i = 1;i < n ;i++)
    {
        if(a[i]<a[i-1])//如果后者大于前者直接插入，也就是不需要处理，如果后者小于前者就需要插入到0-前者-1的范围之内。最终实现排序
        {
            int j = i-1;
            int x = a[i];//需要将x插入到0~j的范围内。
            while(j>-1 && x<a[j])//这个循环意思是i>0并且插入值小于前者此时就循环，直到遍历到最前端或者插入值大于前者了才结束
            {
                a[j+1] = a[j];//没看懂
                j--;
            }
            a[j+1] = x;//插入值插入到j+1位置上，此位置
        }
    }
}
```

反正就是把当前元素看成一个已排序的序列，如果后者大于当前值就直接插入到序列，其实就是没有操作，如果小于前者，就插入到前者的序列中。代码也是没看懂，写的不好。

两个循环，大循环中依次比较前后者关系，小循环中找出插入点。

### 改进

在插入某个元素之前需要先确定该元素在有序数组中的位置，原始的做法是对有序数组中的元素逐个扫描，当数据量比较大的时候，这是一个很耗时间的过程，可以采用二分查找法改进，这种排序也被称为二分插入排序。

## 选择排序

### 基本思想

首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。然后，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这个方法称之为选择排序。

这种方法就是将依次找到最小的元素放到头部，冒泡排序是两两之间依次比较，更大值交换到右侧，直到最大值放到最右端，小循环结束，返回大循环。

### 具体步骤

1. 首先在未排序序列中找到最小的元素，存放到排序序列的起始位置。
2. 再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾。
3. 重复第二步，直到所有元素均排序完毕。

最好时间复杂度：O(N2)

最坏时间复杂度：O(N2)

平均时间复杂度：O(N2)

空间复杂度：O(1)

稳定排序：否

原地排序：是

```c
int FindMaxPos1(Mytype arr[],int i,int n)//这个函数就是用来找到i之后的最大值
{
    int max = i;
    while(i+1<n)//因为这里的max会变成i+1，所以判断i+1是否出界，其实这个函数也是两两之间比较，找出i~n范围内最大值
    {
        if(arr[max]<arr[i+1])
        {
            max = i+1;
        }
        i++;
    }
    return max;
}
int FindMinPos1(int arr[],int i,int n){
    int min = i;
    while(i+1<n){
        if(arr[min]>arr[i+1])
        {
            min = i+1;
        }
        i++;
    }
    return min;
}
void SelectSort1(int arr[],int n)
{
    for(int i = 0;i < n; i++)
    {
        int pos = FindMinPos1(arr,i,n);
        if(pos!=i)
        {
            swap(arr,pos,i);
        }
    }
}
```

这个选择排序和冒泡排序其实没啥区别，都是两个循环，大循环遍历整个数组，小循环找出当前范围内的最大值。区别在于选择排序是找出最小值，冒泡排序是找出最大值。

### 改进

简单选择排序，每趟循环只能确定一个元素排序后的定位。我们可以考虑改进为每趟循环确定两个元素(当前最大和最小记录)的位置，从而减少排序所需的循环次数。改进后对n个数据进行排序，最多只需进行n/2趟循环。

## 归并排序

### 基本思想

归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案修补在一起。实际上就是将数据序列划分为越来越小的半子表，再对半子表排序，最后再用递归方法将排好序的半子表合并成越来越大的有序序列。

### 具体步骤

1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；
3. 比较两个指南所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一个位置；
4. 重复步骤3直到某一指针达到序列尾
5. 将另一序列剩下的所有元素直接复制到合并序列尾。

最好时间复杂度：O(NlogN)

最坏时间复杂度：O(NlogN)

平均时间复杂度：O(NlogN)

空间复杂度：O(N)

稳定排序：是

原地排序：是

### 代码实现

选择排序是找出当前最大值与首尾元素交换。冒泡排序是两两比较，将更大值交换到队尾。

```c
#include<iostream>
#define MAXSIZE 10
using namespace std;
void merging(int *list1,int list1_size,int *list2,int list2_size)
{
    int i,j,k,m;
    int temp[MAXSIZE];
    i=j=k=0;
    while(i < list1_size && j < list2_size)//遍历最短数组
    {
        if(list1[i] < list2[j])
        {
            temp[k++] = list1[i++];//将较小值赋值给temp数组，
        }else{
            temp[k++] = list2[j++];//赋值之后自加
        }
    }
    while(i < list1_size)//较短的数组被分配，如果此时i<数组长度，说明该数组是较长数组
    {
        temp[k++] = list1[i++];
    }
    while(j < list_size)
    {
        temp[k++] = list2[j++];
    }
    //此时两个数组都已经按照从小到大分配到temp数组中了。
    for(m = 0;m < (list1_size + list2_size);m++)
    {
        list1[m] = temp[m];//赋值给list1数组
    }
}
void MergeSort(int k[],int n)
{
    if(n > 1)
    {
        int *list1 = k;
        int list1_size = n/2;
        int *list2 = k +n/2;//将k数组分成前后两部分，k表示首元素地址，而n/2表示一半长度
        int list2_size = n - list1_size;
        MergeSort(list1,list1_size);//不断的细分数组直到数组只有一个元素为止。
        MergeSort(list2,list2_size);
        merging(list1,list1_size,list2,list2_size);//在递归返回期间进行排序。
    }
}
int main()
{
    int i,a[10] = {5,2,6,0,3,9,1,7,4,8};
    cout << "排序前的数组是：";
    for(i = 0;i < 10; i++)
    {
        cout<< a[i];
    }
    cout << end1;
    MergeSort(a,10);
    cout<<"排序后的数组是："
        for(i=0;i<10;i++)
        {
            cout<<a[i];
        }
    cout<<end1;
    return 0;
}
```

非递归就不看了

## 改进方法

归并排序的时间复杂度为O(nlgn)，一般来讲，基于从单个记录开始两两归并的排序并不是特别提倡，一种比较常见的改进就是结合插入排序，即先利用插入排序获得较长的有序子序列，然后再两两归并(改进后的归并亦是稳定的，因为插入排序是稳定的)。

原因：尽管插入排序的最坏情况是O(n^2)，看起来大于归并的最坏情况O(nlgn)，但通常情况下，由于插入排序的常数因子使得它在n比较小的情况下能运行的更快一些，因此，归并时，当子问题足够小时，采用插入排序是比较合适的。

## 希尔排序

### 基本思想

希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；

希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时，在对全体记录进行依次直接插入排序。

### 具体步骤

选择一个增量序列t1，t2,tk，其中ti>tj,tk=1;

按增量序列个数k，对序列进行k趟排序；

每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m的子序列，分别对各子表进行直接插入排序，仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。

最好时间复杂度：O(Nlog^2N)

最坏时间复杂度：O(Nlog^2N)

平均时间复杂度：O(NlogN)

空间复杂度：O(1)

稳定排序：否

原地排序：是

### 代码实现

这段代码整了三个循环嵌套，第一个循环是将数组对半分直到不可再分。第二个循环是遍历每次获得的数组索引直到数组结尾。第一次是数组的后半部，第二次是数组的后3/4部分，最后一次是整体数组。第三个循环没看懂

```c
void shell_sort(int arr[],int len)
{
    int gap,i,j;
    int temp;
    for(gap = len >> 1;gap > 0;gap >>=1)
    {
        for(i = gap;i < len;i++)
        {
            temp = arr[i];
            for(j = i- gap;j >=0 && arr[j] > temp; j -= gap)
                arr[j+gap] = arr[j];
            arr[j + gap] = temp;
        }
    }
}
```

代码确实没问题，能跑出来，但我也确实看不懂，第三个循环理解不了。

### 改进

在扫描分组数据使不必要每次都交换，找到最终的位置直接插入待处理元素即可。

## 总结

总结下排序算法的刷题心得，排序算法很明显要比数据结构难很多。

- 快速排序找出**中轴元素**，大于中轴元素在右侧，小于在左侧。从中轴元素处将数组切割为两个小数组，同样寻找小数组的中轴元素。递归的思想。
- 冒泡排序是**两两比较**，更大值交换到右侧，第一次循环找出最大值放到最右侧，下一次循环不考虑最右侧，直到剩下最左侧元素。非递归。
- 堆排序，利用二叉树的形状，没看懂
- 插入排序将第一个元素当成已排序队列，其余元素为待排序序列，将待排序序列中的元素依次**插入已排序队列**中。非递归
- 选择排序是找到数组中**最小的元素**与第一个元素进行**交换**。非递归
- 归并排序是**针对两个已排序序列合并问题的**。将两个序列的较小值放入新序列中，直到遍历完一个序列，将另一个序列剩余部分直接放入即可。
- 希尔排序，没看懂。

# leetcode

经过长达五十天的上午学习，终于将指南中的算法题做完了。目前感觉数据结构还可以，而排序算法有点难。总共能有五十道题。时间跨度太大忘了不少了。

1. 数组中存在重复元素

   从小到大进行排序，两两间相同元素则重复。只需要一个for即可

   ```c
   #include<stdio.h>
   int cmp(void *a,void *b)
   {
       return *(int *)a-*(int*)b;
       
   }
   
   bool containsDuplicate(int* nums, int numsSize){
   qsort(nums,numsSize,sizeof(int),cmp);
   for(int i = 0;i < numsSize-1;i++)
   {
       if(nums[i] == nums[i+1])
           return true;
   }
   return false;
   }
   ```

2. 最大子数组和

   循环嵌套循环会导致超时，一个循环加两个判断，循环就是遍历整个数组，判断连续子数组+当前数组元素与当前元素的大小。如果连续子数组整体为负数，就没必要相加了这里直接打断导致不需要循环了，直接从当前元素开始吧。每次循环中的连续子数组都要与最大值比较，从而得到所有循环中的连续子数组的最大值。和循环嵌套循环的区别在于多了一次判断、少了一次循环。

   ```c
   int maxSubArray(int* nums, int numsSize) {
       int pre = 0, maxAns = nums[0];
       for (int i = 0; i < numsSize; i++) {
           pre = fmax(pre+nums1[i],nums1[i]);//当前数组元素与当前数组元素+之前所有元素和的比较。如果之前所有元素和为负数则从当前元素开始重新相加，选出起始位置
           maxAns = fmax(maxAns,pre);//选出连续子数组
       }
       return maxAns;
   }
   ```

3. 两数之和

   找出数组中的两个数之和等于target，直接循环嵌套循环，不过小循环不需要从0开始遍历，直接从j=i+1也就是大循环中的下一个元素，毕竟两数相加j只需要遍历i之后的元素即可。之前没刷到过这个题

   ```c
   int* twoSum(int* nums, int numsSize, int target, int* returnSize){
      int* ret = (int*)(malloc(sizeof(int)*2));
       for(int i = 0;i < numsSize;i++)
       {
           for(int j = i+1;j <numsSize;j++)
           {
               if((nums[i]+nums[j]) == target)
               {
                   ret[0] = i;
                   ret[1] = j;
                   *returnSize = 2;
                   return ret;
                   
               }
           }
       }
       *returnSize = 2;
   return NULL;
   }
   ```

4. 合并两个有序数组

   和指南上的方法大差不差，从后向前合并就不需要额外空间。

   ```c
   void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){
   int i=m-1;
   int j=n-1;
   
   while((i>=0)&&(j>=0))
   {
       if(nums1[i]<nums2[j])
       {
           nums1[nums1Size-1] = nums2[j];
           j--;
           nums1Size--;
       }else{
           nums1[nums1Size-1] = nums1[i];
           i--;
           nums1Size--;
       }
   }
   if(i<0)//nums1数组为空或者循环后nums2数组还有剩余
   {
   while(j>=0)
   {
       nums1[nums1Size-1] = nums2[j];
           j--;
           nums1Size--;
   }
   }
   if(j<0)//nums1数组为空或者循环后nums2数组还有剩余
   {
   while(j>=0)
   {
       nums1[nums1Size-1] = nums1[i];
           i--;
           nums1Size--;
   }
   }
   }
   ```

5. 两个数组的交集II

   相比于链表的交集难点在于从两个链表头出发然后从对方的链表头再次出发会同时到达终点，必然也同时到达交点处。而数组不考虑路程的概念，这里指的是共有元素，不考虑前后元素连接。对于cmp函数重点是返回值为A-B，前一个减后一个，从小到大顺序

   ```c
   int cmp( void *a, void *b)
   {
       int A = *(int*)a;
       int B = *(int*)b;
       return A-B;
   }
   
   int* intersect(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){
   qsort(nums1,nums1Size,sizeof(int),cmp);
   qsort(nums2,nums2Size,sizeof(int),cmp);
   *returnSize = 0;
   int i = 0;
   int j = 0;
   int *ret = (int*)malloc(sizeof(int)*(nums1Size>nums2Size?nums2Size:nums1Size));
   while(i<nums1Size&&j<nums2Size)
   {
       if(nums1[i]>nums2[j])
       {
           j++;
       }else if(nums1[i]<nums2[j])
       {
           i++;
       }else if(nums1[i]==nums2[j])
       {
           ret[(*returnSize)++]=nums1[i];
           i++;
           j++;
       }
   }
   return ret;
   }
   ```

   这道题其实是找出两个数组中的重复元素。

6. 买卖股票的最佳时机

   实际上就是循环嵌套循环，内部取更大值，分别取每天为买入日，之后的天为卖出日，比较不同卖出日的利益，再比较不同买入日的利益。求得最大利益超时了

   类似之前求最大子数组，本来是循环嵌套循环+一次max用来比较最大值。但是这种方式会导致执行超时，考虑到时间复杂度，采用循环+max+min，一次循环遍历整个数组，循环中求当前数组元素下的最大利益，以及当前数组元素下的最小价格。用当前值减去最小价格与上一个最大利润比较。
   
   ```c
   int maxProfit(int* prices, int pricesSize){
   int a = 0;
   int max = 0;
   int minprice = 1e9;
   for(int i=0;i < pricesSize;i++)
   { 
       minprice = fmin(minprice,prices[i]);//选出从哪个价格开始
           a = fmax(a,prices[i]-minprice);//选出结束价格
           
   }
   if(max<0)
       return 0;
   else
       return  a;
   }
   ```

   循环嵌套循环+max/min都可以变成一个循环+两个max/min，两个求极值先求出起始元素，然后求出结尾元素。要么是连续相加要么是两点相减。特点是一个随循环变化的变量影响着起点和终点。这个变量不一定出现在两个极值中，但是一定出现两次。
   
7. 重塑矩阵

   这里比较巧妙，并不是直接将二维数组导入到一维数组再导入到二维数组。这样空间复杂度会上升。对索引操作下，将二维索引变成一维索引再变回二维索引。二维数组实际上是一维数组只不过其中的每个元素都是一行。所以有行数个元素。

   ```c
   int** matrixReshape(int** mat, int matSize, int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes){
   int m = matSize;
   int n = *matColSize;
   if(n*m!=r*c)//说明元素个数不相等，无法重塑
   {
       *returnSize = m;
       *returnColumnSizes = matColSize;
       return mat;
   }
   //创建缓冲区作为返回值
   int **temp = (int**)(malloc(sizeof(int*)*r));//在二维数组中一行是一个元素，有行数个元素
   *returnSize = r;//行数
   *returnColumnSizes = (int*)malloc(sizeof(int)*r);//每个列的大小，还是行数
   for(int i =0;i<r;i++)//遍历这一列
   {
       (*returnColumnSizes)[i] = c;//每行有c个元素
       temp[i] = (int*)malloc(sizeof(int)*c);//二维数组，所以一行中每个元素都要分配空间。分配一行元素个数的空间。
   }
   for(int i = 0;i <m*n;i++)//此时i不代表索引而是二维索引的一维表现形式
   {
       temp[i/c][i%c] = mat[i/n][i%n];//这里要除以列数，也就是一行的元素个数,4*5,15/5=3第三行，15%5=0第0列。(3,0)就是这里实现的二维数组的索引用一维表示
   }
   return temp;
   }
   ```

   难点是什么时候乘行数，什么时候乘列数，以及二维索引一维表示。
   
8. 杨辉三角

   特点是最左列和最右列值为1，同样是创建指针数组，不过其中的指针元素指向的数组维度不同。分别是1/2/3...，元素值是左上右上元素的和。
   
   ```c
   int** generate(int numRows, int* returnSize, int** returnColumnSizes){
   int**ret = (int*)malloc(sizeof(int*)*numRows);
   *returnSize = numRows;
   *returnColumnSizes = (int*)malloc(sizeof(int)*(numRows));//指针数组中共有numRows个指针
   for(int i = 0;i <numRows;i++)
   {
       (*returnColumnSizes)[i] = i+1;//相当于(*((*returnColumnSizes)+i))这里的偏移是针对每个指针元素的偏移。而不是对整体数组的偏移，所以()[]形式。
       ret[i] = (int*)malloc(sizeof(int)*(i+1));
       ret[i][0] = 1;
       ret[i][i] = 1;
       for(int j=1;j<i;j++)//最外侧的两列是i,0和i,i所以j从第三行开始
       {
           ret[i][j] = ret[i-1][j]+ret[i-1][j-1];
       }
   }
   return ret;
   }
   ```
   
9. 解数独

   每行、每列、每3*3框内不能出现重复元素。采用三个标记数组，二维、二维、三维、表示每行中出现1-9元素的个数。标记完，在该循环中判断是否大于1。

   ```c
   bool isValidSudoku(char** board, int boardSize, int* boardColSize){
       int row[boardSize][boardSize];
       int col[boardSize][boardSize];
       int sub[boardSize/3][boardSize/3][boardSize];
       memset(row,0,sizeof(row));
       memset(col,0,sizeof(col));
       memset(sub,0,sizeof(sub));
   for(int i = 0;i <boardSize;i++)
   {
       for(int j =0;j < *boardColSize;j++)
       {
           if(board[i][j]!='.')
           {
               int index = board[i][j] - '0'-1;//因为1-9，索引是0-8
               row[i][index]++;
               col[j][index]++;
               sub[i/3][j/3][index]++;
               if(row[i][index]>1||col[j][index]>1||sub[i/3][j/3][index]>1)//直接在该循环中判断，不然单独判断还需要单独循环
               {
                   return false;
               }
           }
       }
   }
   return true;
   }
   ```

10. 矩阵置零

    同样是设置两个标志数组，当元素为0时，标志着该行、该列的标志数组元素为true，然后再次遍历，只要标志为真，数组为0

    ```c
    void setZeroes(int** matrix, int matrixSize, int* matrixColSize){
        bool row[matrixSize];
        bool col[*matrixColSize];
        memset(row,0,sizeof(row));
        memset(col,0,sizeof(col));
    for(int i =0;i<matrixSize;i++)
    {
        for(int j=0;j<*matrixColSize;j++)
        {
            if(matrix[i][j] == 0)
            {
                row[i] = true;
                col[j] = true;
            }
        }
    }
    for(int i=0;i<matrixSize;i++)
    {
        for(int j = 0; j <*matrixColSize;j++)
        {
            if(row[i]||col[j])
            {
                matrix[i][j]= 0;
            }
        }
    }
    }
    ```

11. 字符串中的第一个唯一字符索引

    这道题比较恶心，如果只是单纯使用标记数组只能返回具体的字符，而无法获得在原字符串中的对应索引。使用哈希表增加信息量。第一个循环存储次数，第二个循环找出次数为1对应的索引。
    
    ```c
    #include "uthash.h"//包含的头文件
    struct hashTable{
        int key;
        int value;
        UT_hash_handle hh;//这个是自动初始化
    };
    
    int firstUniqChar(char * s){
     struct hashTable* a = NULL;
    int len = strlen(s);
    
    for(int i = 0;i < len; i++)
    {
         struct hashTable * temp;
        int ikey = s[i];
        HASH_FIND_INT(a,&ikey,temp);//在结构体数组a中查找ikey值对应的结构体，找到就赋值给temp指针，这里的键值是地址
        if(temp==NULL)
        {
            temp = (struct hashTable*)malloc(sizeof(struct  hashTable));//为结构体指针分配一个结构体大小的空间用来指向。
            temp->key = ikey;
            temp->value = 1;
            HASH_ADD_INT(a,key,temp);//将temp添加到a中，这里key要使用结构体成员名称
        }else{
            temp->value++;
        }
    }
    for(int j = 0;j < len;j++)
    {
        int nkey = s[j];
         struct hashTable* temp;
        HASH_FIND_INT(a,&nkey,temp);
        if(temp->value == 1&&temp!=NULL)
        {
            return j;
        }
    }
    return -1;
    }
    ```
    
12. 赎金信

    两个字符串，要求后者完全包含前者，字符顺序不所谓，要求次数全包含，采用哈希表

    ```c
    struct hashTable{
        int key;
        int value;
        UT_hash_handle hh;
    };
    
    bool canConstruct(char * ransomNote, char * magazine){
    struct hashTable* a1 = NULL;//创建结构体数组指针
    struct hashTable *a2 = NULL;
    int lenr = strlen(ransomNote);
    int lenm = strlen(magazine);
    for(int i = 0;i <lenr; i++)
    {
        int rkey = ransomNote[i];
        struct hashTable* temp;
        HASH_FIND_INT(a1,&rkey,temp);
        if(temp==NULL)
        {
            temp = (struct hashTable*)malloc(sizeof(struct hashTable));
            temp->key = rkey;
            temp->value = 1;
            HASH_ADD_INT(a1,key,temp);
        }else{
            temp->value++;
        }
    }
    
    for(int i = 0;i <lenm; i++)
    {
        int mkey = magazine[i];
        struct hashTable* temp;
        HASH_FIND_INT(a2,&mkey,temp);
        if(temp==NULL)
        {
            temp = (struct hashTable*)malloc(sizeof(struct hashTable));
            temp->key = mkey;
            temp->value = 1;
            HASH_ADD_INT(a2,key,temp);
        }else{
            temp->value++;
        }
    }
    
    for(int j = 0;j < lenr;j++)
    {
        int key = ransomNote[j];
        struct hashTable* temp1;
        struct hashTable* temp2;
        HASH_FIND_INT(a1,&key,temp1);
        HASH_FIND_INT(a2,&key,temp2);
        if(temp1!=NULL&&temp2!=NULL)
        {
            if(temp1->value <= temp2->value)
            {
                if(j == lenr-1)
                {
                    return true;
                }
            }else{
                return false;
            }
        }else{
            return false;
        }
    
    }
    return false;
    
    }
    ```

13. 有效的字母异位词

    同样的操作，利用哈希表比较每个字符的出现次数。

    ```c
    struct hashTable{
        int key;
        int value;
        UT_hash_handle hh;
    };
    
    bool isAnagram(char * s, char * t){
    int lens = strlen(s);
    int lent = strlen(t);
    struct hashTable * a1 = NULL;
    struct hashTable * a2 = NULL;
    if(lens!=lent)
    {
        return false;
    }
    for(int i = 0;i < lens;i++)
    {
        int key = s[i];
        struct hashTable*temp;
        HASH_FIND_INT(a1,&key,temp);
        if(temp==NULL)
        {
            temp = (struct hashTable*)malloc(sizeof(struct hashTable));
            temp->key = key;
            temp->value = 1;
            HASH_ADD_INT(a1,key,temp);
        }else{
            temp->value++;
        }
    }
    
    for(int i = 0;i < lens;i++)
    {
        int key = t[i];
        struct hashTable*temp;
        HASH_FIND_INT(a2,&key,temp);
        if(temp==NULL)
        {
            temp = (struct hashTable*)malloc(sizeof(struct hashTable));
            temp->key = key;
            temp->value = 1;
            HASH_ADD_INT(a2,key,temp);
        }else{
            temp->value++;
        }
    }
    for(int i = 0;i <lent;i++)
    {
        int key = s[i];
        struct hashTable*temp1;
        struct hashTable*temp2;
        HASH_FIND_INT(a1,&key,temp1);
        HASH_FIND_INT(a2,&key,temp2);
        if(temp1==NULL||temp2==NULL//这里需要先判断空的情况，然后在调用指针。
        {
            return false;
        }
        if(temp1->value == temp2->value)
        {
            if(i == lent-1)
            {
                return true;
            }
        }else{
            return false;
        }
    }
    return false;
    }
    ```

14. 环形链表

    Y=NR-X公式，while循环直到快慢指针重合，此时的重合点距离交点为X。如果只是判断是否具有环形的话就是重合点的next指针是否为空。让快指针在头结点的下一个节点，慢指针从头结点出发，如果没有环两者不可能相遇。就判断尾结点
    
    ```c
    /**
     * Definition for singly-linked list.
     * struct ListNode {
     *     int val;
     *     struct ListNode *next;
     * };
     */
    bool hasCycle(struct ListNode *head) {
        struct ListNode* slow = head;
        if(head==NULL||head->next==NULL)
        {
            return false;
        }
        struct ListNode* fast = head->next;
        while(slow!=fast)
        {
            if(fast==NULL||fast->next==NULL)//说明有尾结点
            {
                return false;
            }
            fast = fast->next->next;
            slow = slow->next;
        }
        return true;
     
    }
    ```
    
15. 合并两个有序链表

    将两个升序链表合并为一个，打擂台就行，单链表只能从前往后了。数组从后往前可以实现原地合并。

    ```c
    /**
     * Definition for singly-linked list.
     * struct ListNode {
     *     int val;
     *     struct ListNode *next;
     * };
     */
    
    
    struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2){
    struct ListNode*head = (struct ListNode*)malloc(sizeof(struct ListNode));
    struct ListNode *list3 = head;//保留头结点。
    while(list1!=NULL&&list2!=NULL)
    {
        if(list1->val > list2->val)
        {
            list3->next = list2;
            list2 = list2->next;
            list3 = list3->next;//指向下一个节点
        }else{
            list3->next = list1;
            list1 = list1->next;
            list3 = list3->next;
        }
    }
    if(list1==NULL)
    {
        list3->next = list2;//list3节点已经有归属了，这里需要指向下一个节点
    }else if(list2==NULL)
    {
        list3->next = list1;
    }
    return head->next;//这样可以返回头结点
    }
    ```

16. 移除链表元素

    这道题也有讲究。如果使用递归实现的话很简单，刹车条件就是当前值为NULL，下一项是本身函数返回值。返程途中返回值是上一项的next指针需要指向的节点，所以如果head不为val返回自身，否则返回下一项。
    
    如果使用迭代的话对于头结点没有前一项的问题，创建虚拟节点指向头结点即可。这里和删除重复节点区别在于，重复节点是快慢指针，快指针遍历剩余链表来和慢指针匹配，如果相同删除快指针，所以头结点是不会被删除的。
    
    ```c
    struct ListNode* removeElements(struct ListNode* head, int val){
    if(head == NULL)
    {
        return NULL;//刹车条件
    }
    head->next = removeElements(head->next,val);//递归，针对当前节点的下一项如何操作
    return head->val == val?head->next:head;//针对当前节点的上一项
    }
    ```
    
    迭代方式
    
    ```c
    struct ListNode* removeElements(struct ListNode* head, int val){
    struct ListNode* virual = (struct ListNode*)malloc(sizeof(struct ListNode));
    virual->next = head;
    struct ListNode* temp = virual;
    while(temp->next!=NULL)
    {
        if(temp->next->val == val)
        {
            temp->next = temp->next->next;
        }else{
            temp = temp->next;
        }
    }
    return virual->next;
    }
    ```
    
17. 反转链表
    
    同样是递归和迭代都可以，利用递归的前程和返程进行操作
    
    ```c
    struct ListNode* reverseList(struct ListNode* head){
    if(head == NULL||head->next == NULL)
    {
        return head;//返回最终的节点
    }
    //记录当前节点信息
    struct ListNode *now = head;
    struct ListNode *then = now->next;
    head = reverseList(then);//只是为了返回最终节点
    //开始反转，回程
    then->next = now;
    now->next = NULL;
    return head;
    
    }
    ```
    
    迭代方式
    
    ```c
    struct ListNode* reverseList(struct ListNode* head){
    if(head == NULL||head->next == NULL)
    {
        return head;
    }
    struct ListNode *left = NULL;
    struct ListNode *middle = head;
    struct ListNode *right = NULL;
    
    while(middle!=NULL)
    {
        right = middle->next;
        middle->next = left;
        left = middle; 
        middle = right;
    }
    return left;
    
    }
    ```
    
    经常顺序搞混导致超时。
    
18. 删除排序链表中的重复元素

    ```c
    struct ListNode* deleteDuplicates(struct ListNode* head){
        if(head == NULL|| head->next == NULL)
        {
            return head;
        }
    struct ListNode *current = head;
    
    while(current)
    {
        struct ListNode *p = current;
        
        while(p->next!=NULL)
        {
            if(p->next->val == current->val)
            {
                p->next = p->next->next;
            }else{
                p = p->next;
            }
        }
        current = current->next;
    }
    return head;
    }
    ```

19. 有效的括号

    利用了栈的先进后出特点本质上还是数组。
    
    ```c
    char pairs(char a) {
        if (a == '}') return '{';
        if (a == ']') return '[';
        if (a == ')') return '(';
        return 0;
    }
    
    bool isValid(char* s) {
        int n = strlen(s);
        if (n % 2 == 1) {
            return false;
        }
        int stk[n + 1], top = 0;//这里是int类型数组。
        for (int i = 0; i < n; i++) {
            char ch = pairs(s[i]);
            if (ch) {
                if (top == 0 || stk[top - 1] != ch) {
                    return false;
                }
                top--;
            } else {
                stk[top++] = s[i];
            }
        }
        return top == 0;//这里很有灵性。
    }
    
    ```
    
    这道题不难，但是需要考虑的条件很多。
    
20. 用两个栈实现一个队列

    这个是他妈的神仙题，直接放弃。

21. 二叉树先序遍历

    ```c
    int* preorderTraversal(struct TreeNode* root, int* returnSize) {
        int* res = malloc(sizeof(int) * 2000);
        *returnSize = 0;
        if (root == NULL) {
            return res;
        }
    
        struct TreeNode* stk[2000];
        struct TreeNode* node = root;
        int stk_top = 0;
        while (stk_top > 0 || node != NULL) {
            while (node != NULL) {
                res[(*returnSize)++] = node->val;//这里很重要，*和++两个运算符优先级一样，从右到左执行，所以必须将*放在括号内。
                stk[stk_top++] = node;
                node = node->left;
            }
            node = stk[--stk_top];
            node = node->right;
        }
        return res;
    }
    
    ```
    
    神奇，自己写的就报错，官方就没问题，明明都一样。这里的方法其实和指南上的没区别，只是没有判断右子树是否存在这一步，其实不存在就不存在。然后将子函数在函数内部展开。两个循环，外层条件栈空以及指针NULL，外层循环就是出栈赋值给指针。内层条件是指针空表示当前左子树遍历结束，内层循环是先输出根节点，然后将右子树入栈，指针指向左子树。循环外的根节点不需要入栈，直接赋值给p即可。
    
22. 二叉树的中序遍历

    两个循环条件和前序一样，只不过第二个循环中是为了遍历左子树存入栈中，跳出循环之后出栈，输出，赋值右子树，这里其实是将根也作为左子树一起输出了，只不过是从下往上输出，这就是左->根的顺序，然后每次都赋值右子树，这就是左->根->右

    ```c
    /**
     * Definition for a binary tree node.
     * struct TreeNode {
     *     int val;
     *     struct TreeNode *left;
     *     struct TreeNode *right;
     * };
     */
    
    
    /**
     * Note: The returned array must be malloced, assume caller calls free().
     */
    int* inorderTraversal(struct TreeNode* root, int* returnSize){
    *returnSize = 0;
        int* res = malloc(sizeof(int) * 501);
        struct TreeNode** stk = malloc(sizeof(struct TreeNode*) * 501);
        int top = 0;
    
    
    
    while (root != NULL || top > 0) {
    
        while (root != NULL) {
        
            stk[top++] = root;
                root = root->left;
        }
        //此时p为NULL所以出栈获得叶子结点
        root = stk[--top];//先出栈，此时root==NULL
        res[(*returnSize)++] = root->val;
        root = root->right;
    
    }
    return res;
    
    }
    ```

23. 二叉树的后序遍历

    leetcode上的方法比指南上的好一些，不需要额外设置结构体来判断每个节点的右子树是否遍历，大小循环条件都一样，小循环中将当前节点入栈并遍历其左子树，跳出小循环表明该节点的左子树遍历结束，此时出栈获得遍历的最后一个节点，判断下该节点的右子树是否存在或者已遍历，如果遍历了直接打印，如果没遍历就去遍历其右子树，每次打印一个节点就把节点记录下来，如果有节点的右子树是该节点则已经遍历完了。

    ```c
    /**
     * Definition for a binary tree node.
     * struct TreeNode {
     *     int val;
     *     struct TreeNode *left;
     *     struct TreeNode *right;
     * };
     */
    
    
    /**
     * Note: The returned array must be malloced, assume caller calls free().
     */
    
    int* postorderTraversal(struct TreeNode* root, int* returnSize){
    //左右根，需要判断当前根节点的左右子树都遍历结束后才能输出
    *returnSize = 0;
    int*res = (int*)malloc(sizeof(int)*2000);
    struct TreeNode*stk[2000];
    int top = 0;
    
    struct TreeNode* prev = NULL;
    while(root!=NULL||top>0)
    {
        while(root!=NULL)
        {
    
            stk[top++] =root;
            
            root = root->left;      
        }
        root = stk[--top];
        
        if(root->right == NULL || root->right == prev){//如果当前节点右子树为空或者右子树已经遍历了，就打印当前节点
            //此时都遍历了
            res[(*returnSize)++] = root->val;
            prev = root;//将当前节点记录到prev，表示当前节点已经遍历
            root = NULL;//防止当前节点被遍历
           // printf("%d",res[(*returnSize)-1]);
           
        }else 
        {
            stk[top++] = root;//拿出来检查下该节点是否遍历右子树，然后放回去标记以遍历
            root =root ->right;
        }
    }
    
    return res;
    }
    ```

    前中后序遍历的大小循环条件一样，小循环中做的事情也一样，压栈然后遍历其左子树，前序遍历中额外打印当前节点，中序大循环中是出栈、打印、遍历右子树。后序遍历中是出栈、判断是否已遍历右子树如果没有就去遍历，如果有就打印。

24. 二叉树的层序遍历

    每出队一个节点就让其子节点入队，队列的先进先出特点确保节点同一层出队后就是子节点出队，循环就是队列不为空。循环前根节点入队。*returnsize是行数， *returncolumnsize是一维数组，表示每行中有多少列。这里需要返回一个二维数组，大循环中嵌套一个小循环，在小循环中将当前层的所有节点出队并将所有该节点的子节点入队，以层为单位进行队列操作。如果必须返回二维数组的话，只能采用这种方法
    
    ```c
    /**
     * Definition for a binary tree node.
     * struct TreeNode {
     *     int val;
     *     struct TreeNode *left;
     *     struct TreeNode *right;
     * };
     */
    
    
    /**
     * Return an array of arrays of size *returnSize.
     * The sizes of the arrays are returned as *returnColumnSizes array.
     * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
     */
    int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
    
    int rear = 0;//队尾
    int head = 0;//队头
    struct TreeNode* arr[2000];//队列
    int **res = (int**)malloc(sizeof(int*)*2000);//预设两千行
    arr[rear++] = root;
    *returnSize = 0;
    if(root==NULL)return NULL;
    int ColumnSizes[2000];
    while(rear!=head)
    {
         res[*returnSize] = (int*)malloc(sizeof(int)*(rear-head));//创建当前层大小的内存
        ColumnSizes[(*returnSize)] = rear-head;//一维数组
        //获得遍历当前层的开头和结尾
        int start = head;
        head = rear;//队列中剩余的是同一层的节点，所以遍历完队头到达当前队尾位置
        for(int i = start;i<head;i++)//遍历一层中的所有
        {
            res[*returnSize][i-start] = arr[i]->val;
            if(arr[i]->left) arr[rear++] = arr[i]->left;
            if(arr[i]->right) arr[rear++] = arr[i]->right;
        }
        (*returnSize)++;//行数
    }
    (*returnColumnSizes) = (int*)malloc(sizeof(int)*(*returnSize));
    for(int i = 0;i < *returnSize; i++)
    {
        (*returnColumnSizes)[i] = ColumnSizes[i];
    }
    return res;
    }
    ```
    
25. 二叉树的最大深度

    我真的是傻了，直接使用递归就可以

    ```c
    /**
     * Definition for a binary tree node.
     * struct TreeNode {
     *     int val;
     *     struct TreeNode *left;
     *     struct TreeNode *right;
     * };
     */
    
    
    int maxDepth(struct TreeNode* root){
    
    if(root==NULL)
    return 0;
    
        int a = maxDepth(root->left);
        int b = maxDepth(root->right);
    
    return a > b?a+1:b+1;
    }
    ```

26. 对称二叉树

    判断二叉树是否轴对称，如果是判断两个二叉树是否相等就是遍历并且把NULL也保存到队列中即可。所谓的轴对称指的是根的左子树等于其右子树，递归判断根的左子树和右子树。递归中比较两个节点是否为空，如果不为空并且值相等就比较其子树

    ```c
    /**
     * Definition for a binary tree node.
     * struct TreeNode {
     *     int val;
     *     struct TreeNode *left;
     *     struct TreeNode *right;
     * };
     */
     bool check(struct TreeNode*l,struct TreeNode* r)
     {
         if(l ==NULL &&r==NULL)
         return true;//如果两个左右子树指针为空表示相等
         if(l==NULL||r==NULL)//如果有一个为空表示不对称
         return false;
         //如果此时没到叶子节点，继续递归
         if(l->val==r->val)//如果两个节点值相等比较其左右子树
         return check(l->left,r->right)&&check(l->right,r->left);//两个节点对称返回true，每个节点都如此则整个二叉树对称
         else
         return false;//如果值不相等就无了
     }
    bool isSymmetric(struct TreeNode* root){
        return check(root,root);
    }
    ```

27. 反转二叉树

    将整个二叉树进行镜像对称。实际上可以使用递归实现，只要让每个节点的左子树等于右子树即可。

    ```c
    /**
     * Definition for a binary tree node.
     * struct TreeNode {
     *     int val;
     *     struct TreeNode *left;
     *     struct TreeNode *right;
     * };
     */
    
    
    struct TreeNode* invertTree(struct TreeNode* root){
    if(root == NULL)
    return NULL;
    struct TreeNode* left = invertTree(root->left);
    struct TreeNode* right= invertTree(root->right);
    //此时left和right为NULL，已经到了每个叶子节点的子树了
    root->left = right;//此时root->left为NULL，right也是NULL
    root->right = left;
    return root;//实际上传入和返回的是同一层的节点，将此节点的子树反转
    }
    ```

28. 路径总和

    判断二叉树某一条路径上所有节点值的和是否等于给定的sum，同样是用递归实现，如果叶子结点的值等于sum减去该路径上所有节点的值，就说明该路径的节点值的和等于sum。

    ```c
    /**
     * Definition for a binary tree node.
     * struct TreeNode {
     *     int val;
     *     struct TreeNode *left;
     *     struct TreeNode *right;
     * };
     */
    
    
    bool hasPathSum(struct TreeNode* root, int targetSum){
    if(root == NULL)
    {
        return false;
    }
    if(root->left==NULL&&root->right==NULL)
    {
        return targetSum==root->val;//判断下传入值和当前节点值
    }
    return hasPathSum(root->left,targetSum-root->val)||hasPathSum(root->right,targetSum-root->val);//对于非空和非叶子节点的节点进行判断当前节点的左子树和右子树，只要有一个方向能成就可以
    }
    ```

29. 二叉搜索树的搜索

    给定二叉搜索树的根节点和一个整数值，找到节点值等于该节点并返回该节点。中序遍历然后找到该节点并返回。

    ```c
    /**
     * Definition for a binary tree node.
     * struct TreeNode {
     *     int val;
     *     struct TreeNode *left;
     *     struct TreeNode *right;
     * };
     */
    
    
    struct TreeNode* searchBST(struct TreeNode* root, int val){
    
    struct TreeNode* arr[2000];
    int top = 0;
    while(root!=NULL||top>0)
    {
    
        while(root!=NULL)
        {
            arr[top++] = root;
            root = root->left;
        }
        root = arr[--top];
        if(root->val == val)
        {
            return root;
        }
        root = root->right;
    }
    return NULL;
    }
    ```

30. 二叉搜索树中的插入操作

    给定二叉搜索树的根节点和要插入树中的值，将值插入二叉搜索树。返回插入后的二叉搜索树的根节点。同样中序遍历，方法太多。

    这里的插入操作不进行中序遍历，说到底中序遍历是可以从小到大遍历，直接找到叶子节点插入。不搞什么插入到根节点的方法。

    ```c
    /**
     * Definition for a binary tree node.
     * struct TreeNode {
     *     int val;
     *     struct TreeNode *left;
     *     struct TreeNode *right;
     * };
     */
    struct TreeNode* createTree(int val)
    {
        struct TreeNode* res = (struct TreeNode*)malloc(sizeof(struct TreeNode));
        res->val = val;
        res->left = NULL;
        res->right=NULL;
        return res;
    }
    
    struct TreeNode* insertIntoBST(struct TreeNode* root, int val){
    if(root == NULL)
    {
        root = createTree(val);
        return root;
    }
    struct TreeNode* p = root;
    while(p!=NULL)
    {
        if(val<p->val)//去左子树
        {
            if(p->left==NULL)
            {
                p->left = createTree(val);//左子树为空就指向自创节点
                break;
            }else{
                p = p->left;//遍历左子树直到找到叶子节点
            }
        }else{
            if(p->right==NULL)
            {
                p->right = createTree(val);//左子树为空就指向自创节点
                break;
            }else{
                p = p->right;//遍历左子树直到找到叶子节点
            }
        }
    }
    return root;
    }
    ```

31. 验证二叉搜索树

    判断给定的根节点是否是有效的二叉搜索树。中序遍历得到一个数组，然后判断数组是否是从小到大的数组。

    ```c
    /**
     * Definition for a binary tree node.
     * struct TreeNode {
     *     int val;
     *     struct TreeNode *left;
     *     struct TreeNode *right;
     * };
     */
    bool isValidBST(struct TreeNode* root){
    struct TreeNode* arr[10000];
    int a[10000];
    int top = 0;
    int t = 0;
    while(root!=NULL||top>0)
    {
        while(root!=NULL)
        {
            arr[top++] = root;
            root = root->left;
        }
        root = arr[--top];
        a[t++] = root->val;
        root = root->right;
    
    }
    for(int i = 0;i<t-1;i++)
    {
        if(a[i]>=a[i+1])
        return false;
    }
    return true;
    }
    ```

32. 两数之和-输入二叉搜索树

    给定一个二叉搜索树的root以及k，如果root中两个节点值的和等于k则返回true，同样是变成数组形式，然后遍历数组。

    ```c
    /**
     * Definition for a binary tree node.
     * struct TreeNode {
     *     int val;
     *     struct TreeNode *left;
     *     struct TreeNode *right;
     * };
     */
    bool findTarget(struct TreeNode* root, int k){
    struct TreeNode* arr[10000];
    int top = 0;
    int a[10000];
    int t = 0;
    while(root!=NULL||top>0)
    {
        while(root!=NULL)
        {
            arr[top++] = root;
            root = root->left;
        }
        root = arr[--top];
        a[t++] = root->val;
        root = root->right;
    }
    for(int i = 0;i < t;i++)
    {
        for(int j = i+1;j<t;j++)
        {
            if(a[i]+a[j]==k)
            {
                return true;
            }
        }
    }
    return false;
    }
    ```

33. 二叉搜索树的最近公共祖先

    给定两个节点找出其的最近公共祖先，其中这个最近公共祖先可以是其本身。从根节点遍历左右子树，找到左右子树为节点值或者本身以及左或右子树为节点的。

做完美团笔试之后我发现乐鑫和美团都不考数据结构的操作，考的都是动态规划、排序算法。考了那么多的动态规划，接下来就好好做一做动态规划的题

1. 斐波那契数

   斐波那契数通常用F(n)表示，形成的序列称为斐波那契数列。该数列由0和1开始，后面的每一项数字都是前面两项数字的和。给定n，计算F(n)。就是把0和1单独列出来，注意n是索引，循环的时候条件是<n+1

   ```c
   int fib(int n){
   int res = 0;
   int arr[1000] = {0};
   
       arr[0] = 0;
       res = arr[0];
       arr[1] = 1;
       res = arr[1];
   
   
   for(int i = 2;i<n+1;i++)
   {
       arr[i] = arr[i-1]+arr[i-2];
   }
   res = arr[n];
   return res;
   }
   ```

2. 第N个泰波那契数

   泰波那契数是T0 = 0,T1 = 1;T2 = 1，并且T[n] = T[n-3]+T[n-2]+T[n-1]，给整数n，返回第n个泰波那契数Tn的值。

   ```c
   int tribonacci(int n){
   int res = 0;
   int T[1000];
   T[0] = 0;
   T[1] = 1;
   T[2] = 1;
   for(int i = 3 ;i < n+1;i++)
   {
       T[i] = T[i-3] + T[i-2] + T[i-1];
   }
   res = T[n];
   return res;
   }
   ```

3. 爬楼梯

   需要n阶爬到楼顶，每次爬1个或者2阶，有多少种不同的方法爬到楼顶 。

   这里很巧妙的利用了斐波那契数的特点，爬n阶楼梯的方法为F(n)，每次爬一个或者两个，所以F(n) = F(n-1)+F(n-2)，最后一次爬楼梯应该是在n-1处爬或者n-2处爬，所以爬n阶的方法是n-1和n-2阶楼梯方法数量的和。接下来是边界条件，爬0阶的方法为1，1阶的方法为1。因为每次只能爬1或者2所以只需要确定前两个边界即可。

   ```c
   int climbStairs(int n){
   int arr[1000];
   int res = 0;
   arr[0] = 1;
   arr[1] = 1;
   for(int i = 2;i <= n;i++)
   {
       arr[i] = arr[i-1]+arr[i-2];
   }
   return res = arr[n];
   }
   ```

4. 使用最小花费爬楼梯

   给一个整数数组，这是从楼梯第i个台阶向上爬需要的费用，可以选择爬一个或者两个，可以从0或者1开始爬，返回最低花费。

   设置数组f为爬到某一层需要的花费，那么f[0]==f[1]==0，表示爬到0阶和1阶不要钱，爬到n阶花费是f[n] = min(f[n-1]+cost[n-1],f[n-2]+cost[n-2])。这里的f[n-1]是爬到n-1的花费，cost[n-1]是从n-1往上爬的费用。

   ```c
   int minCostClimbingStairs(int* cost, int costSize){
   int f[10000];
   int res = 0;
   f[0] = 0;
   f[1] = 0;
   for(int i = 2;i <=costSize;i++)
   {
       f[i] = fmin(f[i-1]+cost[i-1],f[i-2]+cost[i-2]);
   }
   return res = f[costSize];
   }
   ```

   现在的思路就是问什么就整个数组来存放，然后是边界条件判断下，也就是数组的[0]和[1]是多少，最后是转移函数，数组是如何计算的。

5. 打家劫舍

   偷房屋的现金，限制是相邻的房屋有互相连通的防盗系统，如果两个相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算在不触发警报下，一夜能偷窃的最高金额。其实题干意思就是只能

   同样设f[n]为偷盗的金额总数，转移方程f[n] = fmax(f(i-1),f(i-2)+nums[i])要么偷到上一家结束，要么把当前家偷了。
   
   
   
   ```c
   int rob(int* nums, int numsSize){
       if(numsSize==0)
       {
           return 0;
       }
       int f[100000];
       f[0] = nums[0];
       if(numsSize==1)
       {
           return f[0];
       }
       f[1] = fmax(nums[0],nums[1]);//如果只有两家，偷钱多的。
       for(int i = 2;i <numsSize;i++)//numsSize是一共有多少家，不是索引
       {
           f[i] = fmax(f[i-1],f[i-2]+nums[i]);//转移方程如果有i家，可能目前是偷到i-1结束，可能是i-2+当前家结束，比较下谁大谁小。
       }
       return f[numsSize-1];
   }
   ```
   
6. 打家劫舍II

   区别在于房屋围成一圈，头尾相连了。此时设两个数组，要么包含头屋，要么包含尾屋，继续打家劫舍I的方法，然后将两个数组的f[numsSize-2]和d[numsSize-2]比较大小，但感觉这种方式存在问题，就是如果包含了头屋但是没有选择头屋，这就导致头屋尾屋都没选择12345，这里3+5是最优的，但是因为头屋和尾屋相连无法选择1+3+5，所以算法没问题。就是分成两个数组进行比较的

   ```c
   int rob(int* nums, int numsSize){
   int f[10000];
   int d[10000];
   if(numsSize == 0)
   {
       return 0;
   }
   if(numsSize == 1)
   {
       return nums[0];
   }
   if(numsSize == 2)
   {
       return fmax(nums[0],nums[1]);
   }
   f[0] = nums[0];
   f[1] = fmax(f[0],nums[1]);
   for(int i = 2;i < numsSize-1;i++)
   {
       f[i] = fmax(f[i-1],f[i-2]+nums[i]);
   }
   d[0] = nums[1];
   d[1] =  fmax(d[0],nums[2]);
   for(int i = 2;i < numsSize-1;i++)
   {
       d[i] = fmax(d[i-1],d[i-2]+nums[i+1]);
   }
   return fmax(d[numsSize-2],f[numsSize-2]);
   }
   ```

7. 删除并获得点数

   给一个整数数组nums，每次操作选择任意一个nums[i]，删除并获得相应点数，之后必须删除所有等于nums[i]-1和nums[i]+1的元素。

   感觉这个和打家劫舍差不多，当前点选完之后相邻点不能再选了。只不过这里是值相邻而不是地址相邻。

   创建一个数组sum，索引是nums[i]，值是nums[i]，然后不再考虑nums[]数组，就是使用sum当成小偷即可。

   ```c
   int deleteAndEarn(int* nums, int numsSize){
       int max = 0;
   for(int i = 0;i<numsSize;i++)
   {
       max = fmax(max,nums[i]);
   }
   int sum[max+1];//创建总和数组
   memset(sum,0,sizeof(sum));
   for(int i = 0;i <numsSize;i++)
   {
       sum[nums[i]] += nums[i];//相等的值都加一起，值相邻变成地址相邻
   }
   if(numsSize == 0)
   {
       return 0;
   }
   if(numsSize == 1)
   {
       return sum[nums[0]];
   }
   ------------------
   int f[100000];
   f[0] = sum[0];
   f[1] = fmax(sum[1],sum[0]);
   for(int i = 2;i <max+1;i++)
   {
   f[i] = fmax(f[i-1],f[i-2]+sum[i]);
   }
   return f[max];
   }
   ```

   不需要考虑那些sum数组中未被初始化的元素，0在算法中是不会考虑的。
   
8. 跳跃游戏

   给定一个非负整数数组nums，最初位于数组的第一个下标。数组中的每个元素代表 你在该位置可以跳跃的**最大长度**。判断是否能够到达最后一个下标。

   轮询，判断下当前索引是否小于等于能达到的最大范围，如果小于等于的话，就判断当前最大范围是否可以更新，只要最大范围达到最右侧下标说明可以到达。

   ```c
   bool canJump(int* nums, int numsSize){
       int rightmost = 0;
   for(int i = 0;i < numsSize;i++)
   {
     if(i<=rightmost)//如果索引大于最大范围说明当前索引无法到达
     {
         rightmost = fmax(rightmost,i+nums[i]);//更新最大范围
       if(rightmost >= numsSize-1)//最大范围达到最右侧下标
       {
           return true;
       }
     }
     
   }
   return false;
   
   }
   ```

9. 跳跃游戏II

   给定一个长度为n的零索引整数数组nums，初始位置为nums[0]，每个元素nums[i]表示从索引i向前跳转的最大长度。返回到达nums[n-1]的最小跳转次数。

   计算出初始位置的最大范围，将最大范围的点设为结束点，遍历整个数组，当遍历到结束点的时候将初始位置到结束点之间的最大范围用来更新结束点，此时选出了区间内的最大范围也就确定了走哪一步，所以步数+1，等到遍历到新的结束点时说明此时走完了下一步，已经确定下一步的最大范围。不需要遍历最后一个数组元素。会导致增加一步。

   ```c
   int jump(int* nums, int numsSize){
   int rightsize = 0;
   int end = 0;
   int step = 0;
   for(int i = 0;i < numsSize-1;i++)//这里减一是
   {
    if(rightsize>=i)//判断当前点是否能够走到
       {
           rightsize = fmax(rightsize,i+nums[i]);//更新当前点的最大范围
           if(i==end)//如果当前点走到最大范围说明本次移动结束，这里的意思应该是不关心具体走的哪一个元素，在当前点到最大范围中只能走一步。
           {
               end = rightsize;//结束点更新为最大范围
               step++;
           }
       }
   }
   return step;
   }
   ```
   
10. 环形子数组的最大和

    没有能看懂的C++版本

11. 乘积最大子数组

    这里和最大子数和的区别很大，最大子数和如果前边为负数不做考虑即可，但是乘积需要考虑下负负得正的问题。即使前边为负数也要考虑，这里需要使用两个数值维护，分别保存最大和最小值，判断的时候需要考虑前一个最大值与当前值的乘积、前一个最小值与当前值的乘积、当前值。

    选出最大值和最小值，其中最小值就是用来循环判断的，要保证负数变正的可能，不会参与最后返回值的运算。最大值需要保存并与每次的最大值比较，作为返回值。

    ```c
    int maxProduct(int* nums, int numsSize){
    int maxF = nums[0];
    int minF = nums[0];
    int ret = nums[0];
    for(int i =1;i <numsSize;i++)
    {
        int mx = maxF,mn = minF;//希望每次循环中的最大值和最小值是上一个循环的。
        maxF = fmax(mx*nums[i],fmax(mn*nums[i],nums[i]));//因为不支持对三个参数的比大小，这次使用了两次fmax
        minF = fmin(mx*nums[i],fmin(mn*nums[i],nums[i]));
        ret = fmax(maxF,ret);//获得所有循环的最大值
    }
    return ret;
    }
    ```

12. 乘积为正数的最长子数组长度

    这道题是上一道题的延展，求出乘积为正数的最长子数组的长度。
    
13. 杨辉三角II

    之前做过，杨辉三角就是最外侧的边是1，下方的元素是其左右上方元素的和。

    给定一个非负索引rowIndex，返回杨辉三角的第rowIndex行。索引是含有0和对角线的元素为1。

    其实就是创建一个对角的二维数组，对角线和最左侧的边为1

    ```c
    /**
     * Note: The returned array must be malloced, assume caller calls free().
     */
    int* getRow(int rowIndex, int* returnSize){
        
        *returnSize = rowIndex+1;
        int * arr[*returnSize];
        for(int i = 0;i <= rowIndex;i++)
        {
            arr[i] = (int*)malloc(sizeof(int)*(i+1));
            arr[i][0] = 1;
            arr[i][i] = 1;
            for(int j = 1;j <i;j++)
            {
                arr[i][j] = arr[i-1][j-1]+arr[i-1][j];
            }
        }
    return arr[rowIndex];
    }
    ```

14. 三角形最小路径和

    给定一个三角形triangle，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点在这里指的是下标和上一层结点的下标一致，或者是上一层结点下标+1的两个节点。也就是说如果正位于当前行的下标i，那么下一步可以移动到下一行的下标i或者i+1。

    这道题感觉利用了杨辉三角的数组形状+普通数组的最小跳跃次数问题。
    
    状态转移方程是f = min(f(i,j)+f(i-1,j-1),f(i,j)+f(i-1,j))，和斐那波契还不太一样，这里是二维数组，边界条件是最左侧列和最右侧的对角线只能是其上面元素移动得来的。最后会得到达到最下面行的每个元素的最小路径，还需要比较出哪个元素的最小路径最小。
    
    ```c
    int minimumTotal(int** triangle, int triangleSize, int* triangleColSize){//这里的triangleColSize是一个数组，元素表示每行大小。
    
        int arr[triangleSize][triangleSize];
        arr[0][0] = triangle[0][0];
        
        for(int i = 1;i<triangleSize;i++)
        {
            arr[i][0] = arr[i-1][0]+triangle[i][0];
            for(int j = 1;j<i;j++)
            {
                arr[i][j] = fmin(arr[i-1][j-1]+triangle[i][j],arr[i-1][j]+triangle[i][j]);
            }
            arr[i][i] = arr[i-1][i-1] + triangle[i][i];//此时得到了达到最后一行的每个元素所走过的最短路程，接下来需要比较出最后一行中哪个元素路程最短
        }
        int ret = arr[triangleSize-1][0];
        for(int j = 1;j<triangleSize;j++)
        {
            ret = fmin(ret,arr[triangleSize-1][j]);
        }
        return ret;
    }
    ```
    
15. 买卖股票的最佳时机II

    